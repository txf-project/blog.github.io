<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Musql常见知识点总结</title>
      <link href="/2020/05/25/Mysql%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/25/Mysql%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="说一下-MySQL-执行一条查询语句的内部执行过程？"><a href="#说一下-MySQL-执行一条查询语句的内部执行过程？" class="headerlink" title="说一下 MySQL 执行一条查询语句的内部执行过程？"></a>说一下 MySQL 执行一条查询语句的内部执行过程？</h3><ul><li>客户端先通过连接器连接到 MySQL 服务器。</li><li>连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。</li><li>分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。</li><li>优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。</li><li>优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。</li></ul><h3 id="MySQL-提示“不存在此列”是执行到哪个节点报出的？"><a href="#MySQL-提示“不存在此列”是执行到哪个节点报出的？" class="headerlink" title="MySQL 提示“不存在此列”是执行到哪个节点报出的？"></a>MySQL 提示“不存在此列”是执行到哪个节点报出的？</h3><p>此错误是执行到分析器阶段报出的，因为 MySQL 会在分析器阶段检查 SQL 语句的正确性。</p><h3 id="MySQL-查询缓存的功能有何优缺点？"><a href="#MySQL-查询缓存的功能有何优缺点？" class="headerlink" title="MySQL 查询缓存的功能有何优缺点？"></a>MySQL 查询缓存的功能有何优缺点？</h3><p>MySQL 查询缓存功能是在连接器之后发生的，它的优点是效率高，如果已经有缓存则会直接返回结果。 查询缓存的缺点是失效太频繁导致缓存命中率比较低，任何更新表操作都会清空查询缓存，因此导致查询缓存非常容易失效。</p><h3 id="如何关闭-MySQL-的查询缓存功能？"><a href="#如何关闭-MySQL-的查询缓存功能？" class="headerlink" title="如何关闭 MySQL 的查询缓存功能？"></a>如何关闭 MySQL 的查询缓存功能？</h3><p>MySQL 查询缓存默认是开启的，配置 query<em>cache</em>type 参数为 DEMAND（按需使用）关闭查询缓存，MySQL 8.0 之后直接删除了查询缓存的功能。</p><h3 id="MySQL-的常用引擎都有哪些？"><a href="#MySQL-的常用引擎都有哪些？" class="headerlink" title="MySQL 的常用引擎都有哪些？"></a>MySQL 的常用引擎都有哪些？</h3><p>MySQL 的常用引擎有 InnoDB、MyISAM、Memory 等，从 MySQL 5.5.5 版本开始 InnoDB 就成为了默认的存储引擎。</p><h3 id="MySQL-可以针对表级别设置数据库引擎吗？怎么设置？"><a href="#MySQL-可以针对表级别设置数据库引擎吗？怎么设置？" class="headerlink" title="MySQL 可以针对表级别设置数据库引擎吗？怎么设置？"></a>MySQL 可以针对表级别设置数据库引擎吗？怎么设置？</h3><p>可以针对不同的表设置不同的引擎。在 create table 语句中使用 engine=引擎名（比如Memory）来设置此表的存储引擎。完整代码如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">   <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">   username <span class="built_in">varchar</span>(<span class="number">120</span>),</span><br><span class="line">   age <span class="built_in">int</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">Memory</span></span><br></pre></td></tr></table></figure><h3 id="常用的存储引擎-InnoDB-和-MyISAM-有什么区别？"><a href="#常用的存储引擎-InnoDB-和-MyISAM-有什么区别？" class="headerlink" title="常用的存储引擎 InnoDB 和 MyISAM 有什么区别？"></a>常用的存储引擎 InnoDB 和 MyISAM 有什么区别？</h3><p>InnoDB 和 MyISAM 最大的区别是 InnoDB 支持事务，而 MyISAM 不支持事务，它们主要区别如下：</p><ul><li>InnoDB 支持崩溃后安全恢复，MyISAM 不支持崩溃后安全恢复；</li><li>InnoDB 支持行级锁，MyISAM 不支持行级锁，只支持到表锁；</li><li>InnoDB 支持外键，MyISAM 不支持外键；</li><li>MyISAM 性能比 InnoDB 高；</li><li>MyISAM 支持 FULLTEXT 类型的全文索引，InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好；</li><li>InnoDB 主键查询性能高于 MyISAM。</li></ul><h3 id="InnoDB-有哪些特性？"><a href="#InnoDB-有哪些特性？" class="headerlink" title="InnoDB 有哪些特性？"></a>InnoDB 有哪些特性？</h3><p>**1）插入缓冲(insert buffer)**：对于非聚集索引的插入和更新，不是每一次直接插入索引页中，而是首先判断插入的非聚集索引页是否在缓冲池中，如果在，则直接插入，否则，先放入一个插入缓冲区中。好似欺骗数据库这个非聚集的索引已经插入到叶子节点了，然后再以一定的频率执行插入缓冲和非聚集索引页子节点的合并操作，这时通常能将多个插入合并到一个操作中，这就大大提高了对非聚集索引执行插入和修改操作的性能。</p><p>**2）两次写(double write)**：两次写给 InnoDB 带来的是可靠性，主要用来解决部分写失败(partial page write)。doublewrite 有两部分组成，一部分是内存中的 doublewrite buffer ，大小为 2M，另外一部分就是物理磁盘上的共享表空间中连续的 128 个页，即两个区，大小同样为 2M。当缓冲池的作业刷新时，并不直接写硬盘，而是通过 memcpy 函数将脏页先拷贝到内存中的 doublewrite buffer，之后通过 doublewrite buffer 再分两次写，每次写入 1M 到共享表空间的物理磁盘上，然后马上调用 fsync 函数，同步磁盘。如下图所示</p><p><img src="/" alt="avatar" class="lazyload" data-src="https://images.gitbook.cn/Fh1qmU3TsCwz4YDcT9C92j0GWfDo"></p><p>**3）自适应哈希索引(adaptive hash index)**：由于 InnoDB 不支持 hash 索引，但在某些情况下 hash 索引的效率很高，于是出现了 adaptive hash index 功能， InnoDB 存储引擎会监控对表上索引的查找，如果观察到建立 hash 索引可以提高性能的时候，则自动建立 hash 索引。</p><h3 id="一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？"><a href="#一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？" class="headerlink" title="一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？"></a>一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？</h3><p>如果这张表的引擎是 MyISAM，那么 ID=4，如果是 InnoDB 那么 ID=2（MySQL 8 之前的版本）。</p><h3 id="MySQL-中什么情况会导致自增主键不能连续？"><a href="#MySQL-中什么情况会导致自增主键不能连续？" class="headerlink" title="MySQL 中什么情况会导致自增主键不能连续？"></a>MySQL 中什么情况会导致自增主键不能连续？</h3><p>以下情况会导致 MySQL 自增主键不能连续：</p><ul><li>唯一主键冲突会导致自增主键不连续；</li><li>事务回滚也会导致自增主键不连续。</li></ul><h3 id="InnoDB-中自增主键能不能被持久化？"><a href="#InnoDB-中自增主键能不能被持久化？" class="headerlink" title="InnoDB 中自增主键能不能被持久化？"></a>InnoDB 中自增主键能不能被持久化？</h3><p>自增主键能不能被持久化，说的是 MySQL 重启之后 InnoDB 能不能恢复重启之前的自增列，InnoDB 在 8.0 之前是没有持久化能力的，但 MySQL 8.0 之后就把自增主键保存到 redo log（一种日志类型，下文会详细讲）中，当 MySQL 重启之后就会从 redo log 日志中恢复。</p><h3 id="什么是独立表空间和共享表空间？它们的区别是什么？"><a href="#什么是独立表空间和共享表空间？它们的区别是什么？" class="headerlink" title="什么是独立表空间和共享表空间？它们的区别是什么？"></a>什么是独立表空间和共享表空间？它们的区别是什么？</h3><p><strong>共享表空间</strong>：指的是数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。 <strong>独立表空间</strong>：每一个表都将会生成以独立的文件方式来进行存储。 共享表空间和独立表空间最大的区别是如果把表放再共享表空间，即使表删除了空间也不会删除，所以表依然很大，而独立表空间如果删除表就会清除空间。</p><h3 id="如何设置独立表空间？"><a href="#如何设置独立表空间？" class="headerlink" title="如何设置独立表空间？"></a>如何设置独立表空间？</h3><p>独立表空间是由参数 innodb<em>file</em>per_table 控制的，把它设置成 ON 就是独立表空间了，从 MySQL 5.6.6 版本之后，这个值就默认是 ON 了。</p><h3 id="如何进行表空间收缩？"><a href="#如何进行表空间收缩？" class="headerlink" title="如何进行表空间收缩？"></a>如何进行表空间收缩？</h3><p>使用重建表的方式可以收缩表空间，重建表有以下三种方式：</p><ul><li>alter table t engine=InnoDB</li><li>optmize table t</li><li>truncate table t</li></ul><h3 id="说一下重建表的执行流程？"><a href="#说一下重建表的执行流程？" class="headerlink" title="说一下重建表的执行流程？"></a>说一下重建表的执行流程？</h3><ul><li>建立一个临时文件，扫描表 t 主键的所有数据页；</li><li>用数据页中表 t 的记录生成 B+ 树，存储到临时文件中；</li><li>生成临时文件的过程中，将所有对 t 的操作记录在一个日志文件（row log）中；</li><li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 t相同的数据文件；</li><li>用临时文件替换表 t 的数据文件。</li></ul><h3 id="表的结构信息存在哪里？"><a href="#表的结构信息存在哪里？" class="headerlink" title="表的结构信息存在哪里？"></a>表的结构信息存在哪里？</h3><p>表结构定义占有的存储空间比较小，在 MySQL 8 之前，表结构的定义信息存在以 .frm 为后缀的文件里，在 MySQL 8 之后，则允许把表结构的定义信息存在系统数据表之中。</p><h3 id="什么是覆盖索引？"><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a>什么是覆盖索引？</h3><p>覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键上去取数据。</p><h3 id="如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？"><a href="#如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？" class="headerlink" title="如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？"></a>如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？</h3><p>可以回表查询，如果把主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 作为主键。</p><h3 id="执行一个-update-语句以后，我再去执行-hexdump-命令直接查看-ibd-文件内容，为什么没有看到数据有改变呢？"><a href="#执行一个-update-语句以后，我再去执行-hexdump-命令直接查看-ibd-文件内容，为什么没有看到数据有改变呢？" class="headerlink" title="执行一个 update 语句以后，我再去执行 hexdump 命令直接查看 ibd 文件内容，为什么没有看到数据有改变呢？"></a>执行一个 update 语句以后，我再去执行 hexdump 命令直接查看 ibd 文件内容，为什么没有看到数据有改变呢？</h3><p>可能是因为 update 语句执行完成后，InnoDB 只保证写完了 redo log、内存，可能还没来得及将数据写到磁盘。</p><h3 id="内存表和临时表有什么区别？"><a href="#内存表和临时表有什么区别？" class="headerlink" title="内存表和临时表有什么区别？"></a>内存表和临时表有什么区别？</h3><ul><li>内存表，指的是使用 Memory 引擎的表，建表语法是 create table … engine=memory。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。</li><li>而临时表，可以使用各种引擎类型 。如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。</li></ul><h3 id="并发事务会带来哪些问题？"><a href="#并发事务会带来哪些问题？" class="headerlink" title="并发事务会带来哪些问题？"></a>并发事务会带来哪些问题？</h3><ul><li>脏读</li><li>修改丢失</li><li>不可重复读</li><li>幻读</li></ul><h3 id="什么是脏读和幻读？"><a href="#什么是脏读和幻读？" class="headerlink" title="什么是脏读和幻读？"></a>什么是脏读和幻读？</h3><p>脏读是一个事务在处理过程中读取了另外一个事务未提交的数据；幻读是指同一个事务内多次查询返回的结果集不一样（比如增加了或者减少了行记录）。</p><h3 id="为什么会出现幻读？幻读会带来什么问题？"><a href="#为什么会出现幻读？幻读会带来什么问题？" class="headerlink" title="为什么会出现幻读？幻读会带来什么问题？"></a>为什么会出现幻读？幻读会带来什么问题？</h3><p>因为行锁只能锁定存在的行，针对新插入的操作没有限定，所以就有可能产生幻读。 幻读带来的问题如下：</p><ul><li>对行锁语义的破坏；</li><li>破坏了数据一致性。</li></ul><h3 id="如何避免幻读？"><a href="#如何避免幻读？" class="headerlink" title="如何避免幻读？"></a>如何避免幻读？</h3><p>使用间隙锁的方式来避免出现幻读。间隙锁，是专门用于解决幻读这种问题的锁，它锁的了行与行之间的间隙，能够阻塞新插入的操作 间隙锁的引入也带来了一些新的问题，比如：降低并发度，可能导致死锁。</p><h3 id="如何查看-MySQL-的空闲连接？"><a href="#如何查看-MySQL-的空闲连接？" class="headerlink" title="如何查看 MySQL 的空闲连接？"></a>如何查看 MySQL 的空闲连接？</h3><p>在 MySQL 的命令行中使用 <code>show processlist;</code> 查看所有连接，其中 Command 列显示为 Sleep 的表示空闲连接，如下图所示：</p><p><img src="/" alt="avatar" class="lazyload" data-src="https://images.gitbook.cn/FhQbOAma7Hrue1H5pB3NVy9Y9VVe"></p><h3 id="MySQL-中的字符串类型都有哪些？"><a href="#MySQL-中的字符串类型都有哪些？" class="headerlink" title="MySQL 中的字符串类型都有哪些？"></a>MySQL 中的字符串类型都有哪些？</h3><p>MySQL 的字符串类型和取值如下：</p><table><thead><tr><th align="center"><strong>类型</strong></th><th align="center"><strong>取值范围</strong></th></tr></thead><tbody><tr><td align="center">CHAR(N)</td><td align="center">0~255</td></tr><tr><td align="center">VARCHAR(N)</td><td align="center">0~65536</td></tr><tr><td align="center">TINYBLOB</td><td align="center">0~255</td></tr><tr><td align="center">BLOB</td><td align="center">0~65535</td></tr><tr><td align="center">MEDUIMBLOB</td><td align="center">0~167772150</td></tr><tr><td align="center">LONGBLOB</td><td align="center">0~4294967295</td></tr><tr><td align="center">TINYTEXT</td><td align="center">0~255</td></tr><tr><td align="center">TEXT</td><td align="center">0~65535</td></tr><tr><td align="center">MEDIUMTEXT</td><td align="center">0~167772150</td></tr><tr><td align="center">LONGTEXT</td><td align="center">0~4294967295</td></tr><tr><td align="center">VARBINARY(N)</td><td align="center">0~N个字节的变长字节字符集</td></tr><tr><td align="center">BINARY(N)</td><td align="center">0~N个字节的定长字节字符集</td></tr></tbody></table><h3 id="VARCHAR-和-CHAR-的区别是什么？分别适用的场景有哪些？"><a href="#VARCHAR-和-CHAR-的区别是什么？分别适用的场景有哪些？" class="headerlink" title="VARCHAR 和 CHAR 的区别是什么？分别适用的场景有哪些？"></a>VARCHAR 和 CHAR 的区别是什么？分别适用的场景有哪些？</h3><p>VARCHAR 和 CHAR 最大区别就是，VARCHAR 的长度是可变的，而 CHAR 是固定长度，CHAR 的取值范围为1-255，因此 VARCHAR 可能会造成存储碎片。由于它们的特性决定了 CHAR 比较适合长度较短的字段和固定长度的字段，如身份证号、手机号等，反之则适合使用 VARCHAR。</p><h3 id="MySQL-存储金额应该使用哪种数据类型？为什么？"><a href="#MySQL-存储金额应该使用哪种数据类型？为什么？" class="headerlink" title="MySQL 存储金额应该使用哪种数据类型？为什么？"></a>MySQL 存储金额应该使用哪种数据类型？为什么？</h3><p>MySQL 存储金额应该使用 <code>decimal</code> ，因为如果存储其他数据类型，比如 <code>float</code> 有导致小数点后数据丢失的风险。</p><h3 id="limit-3-2-的含义是什么？"><a href="#limit-3-2-的含义是什么？" class="headerlink" title="limit 3,2 的含义是什么？"></a>limit 3,2 的含义是什么？</h3><p>去除前三条数据之后查询两条信息。</p><h3 id="now-和-current-date-有什么区别？"><a href="#now-和-current-date-有什么区别？" class="headerlink" title="now() 和 current_date() 有什么区别？"></a>now() 和 current_date() 有什么区别？</h3><p>now() 返回当前时间包含日期和时分秒，current_date() 只返回当前时间，如下图所示：</p><p><img src="/" alt="avatar" class="lazyload" data-src="https://images.gitbook.cn/FgQmCmOxXBEjTyldp7YJFSJZGdid"></p><h3 id="如何去重计算总条数？"><a href="#如何去重计算总条数？" class="headerlink" title="如何去重计算总条数？"></a>如何去重计算总条数？</h3><p>使用 distinct 去重，使用 count 统计总条数，具体实现脚本如下：</p><blockquote><p>select count(distinct f) from t</p></blockquote><h3 id="lastinsertid-函数功能是什么？有什么特点？"><a href="#lastinsertid-函数功能是什么？有什么特点？" class="headerlink" title="lastinsertid() 函数功能是什么？有什么特点？"></a>last<em>insert</em>id() 函数功能是什么？有什么特点？</h3><p>last<em>insert</em>id() 用于查询最后一次自增表的编号，它的特点是查询时不需要不需要指定表名，使用 <code>select last_insert_id()</code> 即可查询，因为不需要指定表名所以它始终以最后一条自增编号为主，可以被其它表的自增编号覆盖。比如 A 表的最大编号是 10，last<em>insert</em>id() 查询出来的值为 10，这时 B 表插入了一条数据，它的最大编号为 3，这个时候使用 last<em>insert</em>id() 查询的值就是 3。</p><h3 id="删除表的数据有几种方式？它们有什么区别？"><a href="#删除表的数据有几种方式？它们有什么区别？" class="headerlink" title="删除表的数据有几种方式？它们有什么区别？"></a>删除表的数据有几种方式？它们有什么区别？</h3><p>删除数据有两种方式：delete 和 truncate，它们的区别如下：</p><ul><li>delete 可以添加 where 条件删除部分数据，truncate 不能添加 where 条件只能删除整张表；</li><li>delete 的删除信息会在 MySQL 的日志中记录，而 truncate 的删除信息不被记录在 MySQL 的日志中，因此 detele 的信息可以被找回而 truncate 的信息无法被找回；</li><li>truncate 因为不记录日志所以执行效率比 delete 快。</li></ul><p>delete 和 truncate 的使用脚本如下：</p><blockquote><p>delete from t where username=’redis’; truncate table t;</p></blockquote><h3 id="MySQL-中支持几种模糊查询？它们有什么区别？"><a href="#MySQL-中支持几种模糊查询？它们有什么区别？" class="headerlink" title="MySQL 中支持几种模糊查询？它们有什么区别？"></a>MySQL 中支持几种模糊查询？它们有什么区别？</h3><p>MySQL 中支持两种模糊查询：regexp 和 like，like 是对任意多字符匹配或任意单字符进行模糊匹配，而 regexp 则支持正则表达式的匹配方式，提供比 like 更多的匹配方式。 regexp 和 like 的使用示例如下： select * from person where uname like ‘%SQL%’;&gt; select from person where uname regexp ‘.SQL*.’;</p><h3 id="MySQL-支持枚举吗？如何实现？它的用途是什么？"><a href="#MySQL-支持枚举吗？如何实现？它的用途是什么？" class="headerlink" title="MySQL 支持枚举吗？如何实现？它的用途是什么？"></a>MySQL 支持枚举吗？如何实现？它的用途是什么？</h3><p>MySQL 支持枚举，它的实现方式如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(</span><br><span class="line">    sex enum(<span class="string">&#x27;boy&#x27;</span>,<span class="string">&#x27;grid&#x27;</span>) <span class="keyword">default</span> <span class="string">&#x27;unknown&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>枚举的作用是预定义结果值，当插入数据不在枚举值范围内，则插入失败，提示错误 <code>Data truncated for column &#39;xxx&#39; at row n</code> 。</p><h3 id="count-column-和-count-有什么区别？"><a href="#count-column-和-count-有什么区别？" class="headerlink" title="count(column) 和 count(*) 有什么区别？"></a>count(column) 和 count(*) 有什么区别？</h3><p>count(column) 和 count() 最大区别是统计结果可能不一致，count(column) 统计不会统计列值为 null 的数据，而 count() 则会统计所有信息，所以最终的统计结果可能会不同。</p><h3 id="以下关于-count-说法正确的是？"><a href="#以下关于-count-说法正确的是？" class="headerlink" title="以下关于 count 说法正确的是？"></a>以下关于 count 说法正确的是？</h3><p>A. count 的查询性能在各种存储引擎下的性能都是一样的。 B. count 在 MyISAM 比 InnoDB 的性能要低。 C. count 在 InnoDB 中是一行一行读取，然后累计计数的。 D. count 在 InnoDB 中存储了总条数，查询的时候直接取出。</p><p>答：C</p><h3 id="为什么-InnoDB-不把总条数记录下来，查询的时候直接返回呢？"><a href="#为什么-InnoDB-不把总条数记录下来，查询的时候直接返回呢？" class="headerlink" title="为什么 InnoDB 不把总条数记录下来，查询的时候直接返回呢？"></a>为什么 InnoDB 不把总条数记录下来，查询的时候直接返回呢？</h3><p>因为 InnoDB 使用了事务实现，而事务的设计使用了多版本并发控制，即使是在同一时间进行查询，得到的结果也可能不相同，所以 InnoDB 不能把结果直接保存下来，因为这样是不准确的。</p><h3 id="能否使用-show-table-status-中的表行数作为表的总行数直接使用？为什么？"><a href="#能否使用-show-table-status-中的表行数作为表的总行数直接使用？为什么？" class="headerlink" title="能否使用 show table status 中的表行数作为表的总行数直接使用？为什么？"></a>能否使用 show table status 中的表行数作为表的总行数直接使用？为什么？</h3><p>不能，因为 show table status 是通过采样统计估算出来的，官方文档说误差可能在 40% 左右，所以 show table status 中的表行数不能直接使用。</p><h3 id="以下哪个-SQL-的查询性能最高？"><a href="#以下哪个-SQL-的查询性能最高？" class="headerlink" title="以下哪个 SQL 的查询性能最高？"></a>以下哪个 SQL 的查询性能最高？</h3><p>A. select count(*) from t where time&gt;1000 and time&lt;4500 B. show table status where name=’t’ C. select count(id) from t where time&gt;1000 and time&lt;4500 D. select count(name) from t where time&gt;1000 and time&lt;4500</p><p>答：B 题目解析：因为 show table status 的表行数是估算出来，而其他的查询因为添加了 where 条件，即使是 MyISAM 引擎也不能直接使用已经存储的总条数，所以 show table status 的查询性能最高。</p><h3 id="InnoDB-和-MyISAM-执行-select-count-from-t，哪个效率更高？为什么？"><a href="#InnoDB-和-MyISAM-执行-select-count-from-t，哪个效率更高？为什么？" class="headerlink" title="InnoDB 和 MyISAM 执行 select count(*) from t，哪个效率更高？为什么？"></a>InnoDB 和 MyISAM 执行 select count(*) from t，哪个效率更高？为什么？</h3><p>MyISAM 效率最高，因为 MyISAM 内部维护了一个计数器，直接返回总条数，而 InnoDB 要逐行统计。</p><h3 id="在-MySQL-中有对-count-做优化吗？做了哪些优化？"><a href="#在-MySQL-中有对-count-做优化吗？做了哪些优化？" class="headerlink" title="在 MySQL 中有对 count(*) 做优化吗？做了哪些优化？"></a>在 MySQL 中有对 count(*) 做优化吗？做了哪些优化？</h3><p>count(*) 在不同的 MySQL 引擎中的实现方式是不相同的，在没有 where 条件的情况下：</p><ul><li>MyISAM 引擎会把表的总行数存储在磁盘上，因此在执行 count(*) 的时候会直接返回这个这个行数，执行效率很高；</li><li>InnoDB 引擎中 count(*) 就比较麻烦了，需要把数据一行一行的从引擎中读出来，然后累计基数。</li></ul><p>但即使这样，在 InnoDB 中，MySQL 还是做了优化的，我们知道对于 count(<em>) 这样的操作，遍历任意索引树得到的结果，在逻辑上都是一样的，因此，MySQL 优化器会找到最小的那颗索引树来遍历，这样就能在保证逻辑正确的前提下，尽量少扫描数据量，从而优化了 count(</em>) 的执行效率。</p><h3 id="在-InnoDB-引擎中-count-、count-1-、count-主键-、count-字段-哪个性能最高？"><a href="#在-InnoDB-引擎中-count-、count-1-、count-主键-、count-字段-哪个性能最高？" class="headerlink" title="在 InnoDB 引擎中 count(*)、count(1)、count(主键)、count(字段) 哪个性能最高？"></a>在 InnoDB 引擎中 count(*)、count(1)、count(主键)、count(字段) 哪个性能最高？</h3><p>count(字段)&lt;count(主键 id)&lt;count(1)≈count(*) 题目解析：</p><ul><li>对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</li><li>对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</li><li>对于 count(字段) 来说，如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</li><li>对于 count(*) 来说，并不会把全部字段取出来，而是专门做了优化，不取值，直接按行累加。</li></ul><p>所以最后得出的结果是：count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)。</p><h3 id="MySQL-中内连接、左连接、右连接有什么区别？"><a href="#MySQL-中内连接、左连接、右连接有什么区别？" class="headerlink" title="MySQL 中内连接、左连接、右连接有什么区别？"></a>MySQL 中内连接、左连接、右连接有什么区别？</h3><ul><li>内连（inner join）— 把匹配的关联数据显示出来；</li><li>左连接（left join）— 把左边的表全部显示出来，右边的表显示出符合条件的数据；</li><li>右连接（right join）— 把右边的表全部显示出来，左边的表显示出符合条件的数据；</li></ul><h3 id="什么是视图？如何创建视图？"><a href="#什么是视图？如何创建视图？" class="headerlink" title="什么是视图？如何创建视图？"></a>什么是视图？如何创建视图？</h3><p>视图是一种虚拟的表，具有和物理表相同的功能，可以对视图进行增、改、查操作。视图通常是一个表或者多个表的行或列的子集。 视图创建脚本如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> vname <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> column_names</span><br><span class="line"><span class="keyword">from</span> table_name</span><br><span class="line"><span class="keyword">where</span> condition</span><br></pre></td></tr></table></figure><h3 id="视图有哪些优点？"><a href="#视图有哪些优点？" class="headerlink" title="视图有哪些优点？"></a>视图有哪些优点？</h3><ul><li>获取数据更容易，相对于多表查询来说；</li><li>视图能够对机密数据提供安全保护；</li><li>视图的修改不会影响基本表，提供了独立的操作单元，比较轻量。</li></ul><h3 id="MySQL-中“视图”的概念有几个？分别代表什么含义？"><a href="#MySQL-中“视图”的概念有几个？分别代表什么含义？" class="headerlink" title="MySQL 中“视图”的概念有几个？分别代表什么含义？"></a>MySQL 中“视图”的概念有几个？分别代表什么含义？</h3><p>MySQL 中的“视图”概念有两个，它们分别是：</p><ul><li>MySQL 中的普通视图也是我们最常用的 view，创建语法是 create view …,它的查询和普通表一样；</li><li>InnoDB 实现 MVCC（Multi-Version Concurrency Control）多版本并发控制时用到的一致性读视图，它没有物理结构，作用是事务执行期间定于可以看到的数据。</li></ul><h3 id="使用-delete-误删数据怎么找回？"><a href="#使用-delete-误删数据怎么找回？" class="headerlink" title="使用 delete 误删数据怎么找回？"></a>使用 delete 误删数据怎么找回？</h3><p>可以用 Flashback 工具通过闪回把数据恢复回来。</p><h3 id="Flashback-恢复数据的原理是什么？"><a href="#Flashback-恢复数据的原理是什么？" class="headerlink" title="Flashback 恢复数据的原理是什么？"></a>Flashback 恢复数据的原理是什么？</h3><p>Flashback 恢复数据的原理是是修改 binlog 的内容，拿回原库重放，从而实现数据找回。</p><h2 id="MySQL-索引的面试题总结"><a href="#MySQL-索引的面试题总结" class="headerlink" title="MySQL 索引的面试题总结"></a>MySQL 索引的面试题总结</h2><h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><p>索引是一种能帮助 MySQL 提高查询效率的数据结构。</p><h3 id="索引分别有哪些优点和缺点？"><a href="#索引分别有哪些优点和缺点？" class="headerlink" title="索引分别有哪些优点和缺点？"></a>索引分别有哪些优点和缺点？</h3><p>索引的优点如下：</p><ul><li>快速访问数据表中的特定信息，提高检索速度。</li><li>创建唯一性索引，保证数据表中每一行数据的唯一性。</li><li>加速表与表之间的连接。</li><li>使用分组和排序进行数据检索时，可以显著减少查询中分组和排序的时间。</li></ul><p>索引的缺点：</p><ul><li>虽然提高了的查询速度，但却降低了更新表的速度，比如 update、insert，因为更新数据时，MySQL 不仅要更新数据，还要更新索引文件；</li><li>建立索引会占用磁盘文件的索引文件。</li></ul><p>使用索引注意事项：</p><ul><li>使用短索引，短索引不仅可以提高查询速度，更能节省磁盘空间和 I/O 操作；</li><li>索引列排序，MySQL 查询只使用一个索引，因此如果 where 子句中已经使用了索引的话，那么 order by 中的列是不会使用索引的，因此数据库默认排序可以符合要求的情况下，不要进行排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引；</li><li>like 语句操作，一般情况下不鼓励使用 like 操作，如果非使用不可， 注意 like “%aaa%” 不会使用索引，而like “aaa%”可以使用索引；</li><li>不要在列上进行运算；</li><li>不适用 NOT IN 和 &lt;&gt; 操作。</li></ul><h3 id="以下-SQL-有什么问题？该如何优化？"><a href="#以下-SQL-有什么问题？该如何优化？" class="headerlink" title="以下 SQL 有什么问题？该如何优化？"></a>以下 SQL 有什么问题？该如何优化？</h3><blockquote><p>select * from t where f/2=100;</p></blockquote><p>该 SQL 会导致引擎放弃索引而全表扫描，尽量避免在索引列上计算。可改为：</p><blockquote><p>select * from t where f=100*2;</p></blockquote><h3 id="为什么-MySQL-官方建议使用自增主键作为表的主键？"><a href="#为什么-MySQL-官方建议使用自增主键作为表的主键？" class="headerlink" title="为什么 MySQL 官方建议使用自增主键作为表的主键？"></a>为什么 MySQL 官方建议使用自增主键作为表的主键？</h3><p>因为自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分；并且自增主键也能减少数据的移动，每次插入都是插入到最后，所以自增主键作为表的主键，对于表的操作来说性能是最高的。</p><h3 id="自增主键有哪些优缺点"><a href="#自增主键有哪些优缺点" class="headerlink" title="自增主键有哪些优缺点?"></a>自增主键有哪些优缺点?</h3><p>优点：</p><ul><li>数据存储空间很小；</li><li>性能最好；</li><li>减少页分裂。</li></ul><p>缺点：</p><ul><li>数据量过大，可能会超出自增长取值范围；</li><li>无法满足分布式存储，分库分表的情况下无法合并表；</li><li>主键有自增规律，容易被破解；</li></ul><p>综上所述：是否需要使用自增主键，需要根据自己的业务场景来设计。如果是单表单库，则优先考虑自增主键，如果是分布式存储，分库分表，则需要考虑数据合并的业务场景来做数据库设计方案。</p><h3 id="索引有几种类型？分别如何创建？"><a href="#索引有几种类型？分别如何创建？" class="headerlink" title="索引有几种类型？分别如何创建？"></a>索引有几种类型？分别如何创建？</h3><p>MySQL 的索引有两种分类方式：逻辑分类和物理分类。 按照逻辑分类，索引可分为：</p><ul><li>主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL；</li><li>唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，但是一个唯一索引只能包含一列，比如身份证号码、卡号等都可以作为唯一索引；</li><li>普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入；</li><li>全文索引：让搜索关键词更高效的一种索引。</li></ul><p>按照物理分类，索引可分为：</p><ul><li>聚集索引：一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为 NULL 的唯一索引，如果还是没有的话，就采用 Innodb 存储引擎为每行数据内置的 6 字节 ROWID 作为聚集索引。每张表只有一个聚集索引，因为聚集索引的键值的逻辑顺序决定了表中相应行的物理顺序。聚集索引在精确查找和范围查找方面有良好的性能表现（相比于普通索引和全表扫描），聚集索引就显得弥足珍贵，聚集索引选择还是要慎重的（一般不会让没有语义的自增 id 充当聚集索引）；</li><li>非聚集索引：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同（非主键的那一列），一个表中可以拥有多个非聚集索引。</li></ul><p>各种索引的创建脚本如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建主键索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> primary <span class="keyword">key</span> <span class="keyword">add</span> (<span class="string">`id`</span>);</span><br><span class="line"><span class="comment">-- 创建唯一索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">unique</span> (<span class="string">`username`</span>);</span><br><span class="line"><span class="comment">-- 创建普通索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> index_name (<span class="string">`username`</span>);</span><br><span class="line"><span class="comment">-- 创建全文索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> fulltext (<span class="string">`username`</span>);</span><br></pre></td></tr></table></figure><h3 id="主索引和唯一索引有什么区别？"><a href="#主索引和唯一索引有什么区别？" class="headerlink" title="主索引和唯一索引有什么区别？"></a>主索引和唯一索引有什么区别？</h3><ul><li>主索引不能重复且不能为空，唯一索引不能重复，但可以为空；</li><li>一张表只能有一个主索引，但可以有多个唯一索引；</li><li>主索引的查询性能要高于唯一索引。</li></ul><h3 id="在-InnDB-中主键索引为什么比普通索引的查询性能高？"><a href="#在-InnDB-中主键索引为什么比普通索引的查询性能高？" class="headerlink" title="在 InnDB 中主键索引为什么比普通索引的查询性能高？"></a>在 InnDB 中主键索引为什么比普通索引的查询性能高？</h3><p>因为普通索引的查询会多执行一次检索操作。比如主键查询 <code>select * from t where id=10</code> 只需要搜索 id 的这棵 B+ 树，而普通索引查询 <code>select * from t where f=3</code> 会先查询 f 索引树，得到 id 的值之后再去搜索 id 的 B+ 树，因为多执行了一次检索，所以执行效率就比主键索引要低。</p><h3 id="什么叫回表查询？"><a href="#什么叫回表查询？" class="headerlink" title="什么叫回表查询？"></a>什么叫回表查询？</h3><p>普通索引查询到主键索引后，回到主键索引树搜索的过程，我们称为回表查询。</p><p>参考SQL：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure><p>如果语句是 select * from T where ID=500，即主键查询方式，则只需要检索主键 ID 字段。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt;  select * from T <span class="built_in">where</span> ID=500;</span><br><span class="line">+-----+---+-------+</span><br><span class="line">| id  | k | name  |</span><br><span class="line">+-----+---+-------+</span><br><span class="line">| 500 | 5 | name5 |</span><br><span class="line">+-----+---+-------+</span><br></pre></td></tr></table></figure><p>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次，这个过程称为回表查询。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from T <span class="built_in">where</span> k=5;</span><br><span class="line">+-----+---+-------+</span><br><span class="line">| id  | k | name  |</span><br><span class="line">+-----+---+-------+</span><br><span class="line">| 500 | 5 | name5 |</span><br><span class="line">+-----+---+-------+</span><br></pre></td></tr></table></figure><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><h3 id="如何查询一张表的所有索引？"><a href="#如何查询一张表的所有索引？" class="headerlink" title="如何查询一张表的所有索引？"></a>如何查询一张表的所有索引？</h3><p><code>SHOW INDEX FROM T</code> 查询表 T 所有索引。</p><h3 id="MySQL-最多可以创建多少个索引列？"><a href="#MySQL-最多可以创建多少个索引列？" class="headerlink" title="MySQL 最多可以创建多少个索引列？"></a>MySQL 最多可以创建多少个索引列？</h3><p>MySQL 中最多可以创建 16 个索引列。</p><h3 id="以下-like-查询会使用索引的是哪一个选项？为什么？"><a href="#以下-like-查询会使用索引的是哪一个选项？为什么？" class="headerlink" title="以下 like 查询会使用索引的是哪一个选项？为什么？"></a>以下 like 查询会使用索引的是哪一个选项？为什么？</h3><p>A.like ‘%A%’ B.like ‘%A’ C.like ‘A%’ D.以上都不是 答：C 题目解析：like 查询要走索引，查询字符不能以通配符（%）开始。</p><h3 id="如何让-like-abc-走索引查询？"><a href="#如何让-like-abc-走索引查询？" class="headerlink" title="如何让 like %abc 走索引查询？"></a>如何让 like %abc 走索引查询？</h3><p>我们知道如果要让 like 查询要走索引，查询字符不能以通配符（%）开始，如果要让 like %abc 也走索引，可以使用 REVERSE() 函数来创建一个函数索引，查询脚本如下：</p><blockquote><p>select * from t where reverse(f) like reverse(‘%abc’);</p></blockquote><h3 id="MySQL-联合索引应该注意什么？"><a href="#MySQL-联合索引应该注意什么？" class="headerlink" title="MySQL 联合索引应该注意什么？"></a>MySQL 联合索引应该注意什么？</h3><p>联合索引又叫复合索引，MySQL 中的联合索引，遵循最左匹配原则，比如，联合索引为 key(a,b,c)，则能触发索引的搜索组合是 a|ab|abc 这三种查询。</p><h3 id="联合索引的作用是什么？"><a href="#联合索引的作用是什么？" class="headerlink" title="联合索引的作用是什么？"></a>联合索引的作用是什么？</h3><p>联合索引的作用如下：</p><ul><li>用于多字段查询，比如，建了一个 key(a,b,c) 的联合索引，那么实际等于建了 key(a)、key(a,b)、key(a,b,c) 等三个索引，我们知道，每多一个索引，就会多一些写操作和占用磁盘空间的开销，尤其是对大数据量的表来说，这可以减少一部分不必要的开销；</li><li>覆盖索引，比如，对于联合索引 key(a,b,c) 来说，如果使用 SQL：<code>select a,b,c from table where a=1 and b = 1</code> ，就可以直接通过遍历索引取得数据，而无需回表查询，这就减少了随机的 IO 操作，减少随机的 IO 操作，可以有效的提升数据库查询的性能，是非常重要的数据库优化手段之一；</li><li>索引列越多，通过索引筛选出的数据越少。</li></ul><h3 id="什么是最左匹配原则？它的生效原则有哪些？"><a href="#什么是最左匹配原则？它的生效原则有哪些？" class="headerlink" title="什么是最左匹配原则？它的生效原则有哪些？"></a>什么是最左匹配原则？它的生效原则有哪些？</h3><p>最左匹配原则也叫最左前缀原则，是 MySQL 中的一个重要原则，说的是索引以最左边的为起点任何连续的索引都能匹配上，当遇到范围查询（&gt;、&lt;、between、like）就会停止匹配。 生效原则来看以下示例，比如表中有一个联合索引字段 index(a,b,c)：</p><ul><li>where a=1 只使用了索引 a；</li><li>where a=1 and b=2 只使用了索引 a,b；</li><li>where a=1 and b=2 and c=3 使用a,b,c；</li><li>where b=1 or where c=1 不使用索引；</li><li>where a=1 and c=3 只使用了索引 a；</li><li>where a=3 and b like ‘xx%’ and c=3 只使用了索引 a,b。</li></ul><h3 id="列值为-NULL-时，查询会使用到索引吗？"><a href="#列值为-NULL-时，查询会使用到索引吗？" class="headerlink" title="列值为 NULL 时，查询会使用到索引吗？"></a>列值为 NULL 时，查询会使用到索引吗？</h3><p>在 MySQL 5.6 以上的 InnoDB 存储引擎会正常触发索引。但为了兼容低版本的 MySQL 和兼容其他数据库存储引擎，不建议使用 NULL 值来存储和查询数据，建议设置列为 NOT NULL，并设置一个默认值，比如 0 和空字符串等，如果是 datetime 类型，可以设置成 1970-01-01 00:00:00 这样的特殊值。</p><h3 id="以下语句会走索引么？"><a href="#以下语句会走索引么？" class="headerlink" title="以下语句会走索引么？"></a>以下语句会走索引么？</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">year</span>(<span class="built_in">date</span>)&gt;<span class="number">2018</span>;</span><br></pre></td></tr></table></figure><p>不会，因为在索引列上涉及到了运算。</p><h3 id="能否给手机号的前-6-位创建索引？如何创建？"><a href="#能否给手机号的前-6-位创建索引？如何创建？" class="headerlink" title="能否给手机号的前 6 位创建索引？如何创建？"></a>能否给手机号的前 6 位创建索引？如何创建？</h3><p>可以，创建方式有两种：</p><ul><li>alter table t add index index_phone(phone(6));</li><li>create index index_phone on t(phone(6));</li></ul><h3 id="什么是前缀索引？"><a href="#什么是前缀索引？" class="headerlink" title="什么是前缀索引？"></a>什么是前缀索引？</h3><p>前缀索引也叫局部索引，比如给身份证的前 10 位添加索引，类似这种给某列部分信息添加索引的方式叫做前缀索引。</p><h3 id="为什么要用前缀索引？"><a href="#为什么要用前缀索引？" class="headerlink" title="为什么要用前缀索引？"></a>为什么要用前缀索引？</h3><p>前缀索引能有效减小索引文件的大小，让每个索引页可以保存更多的索引值，从而提高了索引查询的速度。但前缀索引也有它的缺点，不能在 order by 或者 group by 中触发前缀索引，也不能把它们用于覆盖索引。</p><h3 id="什么情况下适合使用前缀索引？"><a href="#什么情况下适合使用前缀索引？" class="headerlink" title="什么情况下适合使用前缀索引？"></a>什么情况下适合使用前缀索引？</h3><p>当字符串本身可能比较长，而且前几个字符就开始不相同，适合使用前缀索引；相反情况下不适合使用前缀索引，比如，整个字段的长度为 20，索引选择性为 0.9，而我们对前 10 个字符建立前缀索引其选择性也只有 0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，就没有创建前缀索引的必要了。</p><h3 id="什么是页？"><a href="#什么是页？" class="headerlink" title="什么是页？"></a>什么是页？</h3><p>页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页。主存和磁盘以页为单位交换数据。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次磁盘 IO 就可以完全载入。</p><h3 id="索引的常见存储算法有哪些？"><a href="#索引的常见存储算法有哪些？" class="headerlink" title="索引的常见存储算法有哪些？"></a>索引的常见存储算法有哪些？</h3><ul><li>哈希存储法：以 key、value 方式存储，把值存入数组中使用哈希值确认数据的位置，如果发生哈希冲突，使用链表存储数据；</li><li>有序数组存储法：按顺序存储，优点是可以使用二分法快速找到数据，缺点是更新效率，适合静态数据存储；</li><li>搜索树：以树的方式进行存储，查询性能好，更新速度快。</li></ul><h3 id="InnoDB-为什么要使用-B-树，而不是-B-树、Hash、红黑树或二叉树？"><a href="#InnoDB-为什么要使用-B-树，而不是-B-树、Hash、红黑树或二叉树？" class="headerlink" title="InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？"></a>InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？</h3><p>因为 B 树、Hash、红黑树或二叉树存在以下问题：</p><ul><li>B 树：不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；</li><li>Hash：虽然可以快速定位，但是没有顺序，IO 复杂度高；</li><li>二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且 IO 代价高；</li><li>红黑树：树的高度随着数据量增加而增加，IO 代价高。</li></ul><h3 id="为什么-InnoDB-要使用-B-树来存储索引？"><a href="#为什么-InnoDB-要使用-B-树来存储索引？" class="headerlink" title="为什么 InnoDB 要使用 B+ 树来存储索引？"></a>为什么 InnoDB 要使用 B+ 树来存储索引？</h3><p>B+Tree 中的 B 是 Balance，是平衡的意思，它在经典 B Tree 的基础上进行了优化，增加了顺序访问指针，在B+Tree 的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的 B+Tree，这样就提高了区间访问性能：如果要查询 key 为从 18 到 49 的所有数据记录，当找到 18 后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率（无需返回上层父节点重复遍历查找减少 IO 操作）。</p><p>索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上，这样的话，索引查找过程中就要产生磁盘 IO 消耗，相对于内存存取，IO 存取的消耗要高几个数量级，所以索引的结构组织要尽量减少查找过程中磁盘 IO 的存取次数，从而提升索引效率。 综合所述，InnDB 只有采取 B+ 树的数据结构存储索引，才能提供数据库整体的操作性能。</p><h3 id="唯一索引和普通索引哪个性能更好？"><a href="#唯一索引和普通索引哪个性能更好？" class="headerlink" title="唯一索引和普通索引哪个性能更好？"></a>唯一索引和普通索引哪个性能更好？</h3><ul><li>对于查询操作来说：普通索引和唯一索引的性能相近，都是从索引树中进行查询；</li><li>对于更新操作来说：唯一索引要比普通索引执行的慢，因为唯一索引需要先将数据读取到内存中，再在内存中进行数据的唯一效验，所以执行起来要比普通索引更慢。</li></ul><h3 id="优化器选择查询索引的影响因素有哪些？"><a href="#优化器选择查询索引的影响因素有哪些？" class="headerlink" title="优化器选择查询索引的影响因素有哪些？"></a>优化器选择查询索引的影响因素有哪些？</h3><p>优化器的目的是使用最小的代价选择最优的执行方案，影响优化器选择索引的因素如下：</p><ul><li>扫描行数，扫描的行数越少，执行代价就越少，执行效率就会越高；</li><li>是否使用了临时表；</li><li>是否排序。</li></ul><h3 id="MySQL-是如何判断索引扫描行数的多少？"><a href="#MySQL-是如何判断索引扫描行数的多少？" class="headerlink" title="MySQL 是如何判断索引扫描行数的多少？"></a>MySQL 是如何判断索引扫描行数的多少？</h3><p>MySQL 的扫描行数是通过索引统计列（cardinality）大致得到并且判断的，而索引统计列（cardinality）可以通过查询命令 show index 得到，索引扫描行数的多少就是通过这个值进行判断的。</p><h3 id="MySQL-是如何得到索引基数的？它准确吗？"><a href="#MySQL-是如何得到索引基数的？它准确吗？" class="headerlink" title="MySQL 是如何得到索引基数的？它准确吗？"></a>MySQL 是如何得到索引基数的？它准确吗？</h3><p>MySQL 的索引基数并不准确，因为 MySQL 的索引基数是通过采样统计得到的，比如 InnoDb 默认会有 N 个数据页，采样统计会统计这些页面上的不同值得到一个平均值，然后除以这个索引的页面数就得到了这个索引基数。</p><h3 id="MySQL-如何指定查询的索引？"><a href="#MySQL-如何指定查询的索引？" class="headerlink" title="MySQL 如何指定查询的索引？"></a>MySQL 如何指定查询的索引？</h3><p>在 MySQL 中可以使用 force index 强行选择一个索引，具体查询语句如下：</p><blockquote><p>select * from t force index(index_t)</p></blockquote><h3 id="在-MySQL-中指定了查询索引，为什么没有生效？"><a href="#在-MySQL-中指定了查询索引，为什么没有生效？" class="headerlink" title="在 MySQL 中指定了查询索引，为什么没有生效？"></a>在 MySQL 中指定了查询索引，为什么没有生效？</h3><p>我们知道在 MySQL 中使用 force index 可以指定查询的索引，但并不是一定会生效，原因是 MySQL 会根据优化器自己选择索引，如果 force index 指定的索引出现在候选索引上，这个时候 MySQL 不会在判断扫描的行数的多少直接使用指定的索引，如果没在候选索引中，即使 force index 指定了索引也是不会生效的。</p><h3 id="以下-or-查询有什么问题吗？该如何优化？"><a href="#以下-or-查询有什么问题吗？该如何优化？" class="headerlink" title="以下 or 查询有什么问题吗？该如何优化？"></a>以下 or 查询有什么问题吗？该如何优化？</h3><blockquote><p>select * from t where num=10 or num=20;</p></blockquote><p>答：如果使用 or 查询会使 MySQL 放弃索引而全表扫描，可以改为：</p><blockquote><p>select * from t where num=10 union select * from t where num=20;</p></blockquote><h3 id="以下查询要如何优化？"><a href="#以下查询要如何优化？" class="headerlink" title="以下查询要如何优化？"></a>以下查询要如何优化？</h3><p>表中包含索引：</p><ul><li>KEY mid (mid)</li><li>KEY begintime (begintime)</li><li>KEY dg (day,group)</li></ul><p>使用以下 SQL 进行查询：</p><blockquote><p>select f from t where day=’2010-12-31’ and group=18 and begintime&lt;’2019-12-31 12:14:28’ order by begintime limit 1;</p></blockquote><p>答：此查询理论上是使用 dg 索引效率更高，通过 explain 可以对比查询扫描次数。由于使用了 order by begintime 则使查询放弃了 dg 索引，而使用 begintime 索引，从侧面印证 order by 关键字会影响查询使用索引，这时可以使查询强制使用索引，改为以下SQL：</p><blockquote><p>select f from t use index(dg) where day=’2010-12-31’ and group=18 and begintime&lt; ‘2019-12-31 12:14:28’ order by begintime limit 1;</p></blockquote><h3 id="MySQL-会错选索引吗？"><a href="#MySQL-会错选索引吗？" class="headerlink" title="MySQL 会错选索引吗？"></a>MySQL 会错选索引吗？</h3><p>MySQL 会错选索引，比如 k 索引的速度更快，但是 MySQL 并没有使用而是采用了 v 索引，这种就叫错选索引，因为索引选择是 MySQL 的服务层的优化器来自动选择的，但它在复杂情况下也和人写程序一样出现缺陷。</p><h3 id="如何解决-MySQL-错选索引的问题？"><a href="#如何解决-MySQL-错选索引的问题？" class="headerlink" title="如何解决 MySQL 错选索引的问题？"></a>如何解决 MySQL 错选索引的问题？</h3><ul><li>删除错选的索引，只留下对的索引；</li><li>使用 force index 指定索引；</li><li>修改 SQL 查询语句引导 MySQL 使用我们期望的索引，比如把 <code>order by b limit 1</code> 改为 <code>order by b,a limit 1</code> 语义是相同的，但 MySQL 查询的时候会考虑使用 a 键上的索引。</li></ul><h3 id="如何优化身份证的索引？"><a href="#如何优化身份证的索引？" class="headerlink" title="如何优化身份证的索引？"></a>如何优化身份证的索引？</h3><p>在中国因为前 6 位代表的是地区，所以很多人的前六位都是相同的，如果我们使用前缀索引为 6 位的话，性能提升也并不是很明显，但如果设置的位数过长，那么占用的磁盘空间也越大，数据页能放下的索引值就越少，搜索效率也越低。针对这种情况优化方案有以下两种：</p><ul><li>使用身份证倒序存储，这样设置前六位的意义就很大了；</li><li>使用 hash 值，新创建一个字段用于存储身份证的 hash 值。</li></ul><h2 id="MySQL-事务的面试题总结"><a href="#MySQL-事务的面试题总结" class="headerlink" title="MySQL 事务的面试题总结"></a>MySQL 事务的面试题总结</h2><h3 id="事务是什么？"><a href="#事务是什么？" class="headerlink" title="事务是什么？"></a>事务是什么？</h3><p>事务是一系列的数据库操作，是数据库应用的基本单位。MySQL 事务主要用于处理操作量大，复杂度高的数据。</p><h3 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h3><p>在 MySQL 中只有 InnDB 引擎支持事务，它的四个特性如下：</p><ul><li>原子性（Atomic）：要么全部执行，要么全部不执行；</li><li>一致性（Consistency）：事务的执行使得数据库从一种正确状态转化为另一种正确状态；</li><li>隔离性（Isolation）：在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务；</li><li>持久性（Durability）：事务提交后，其结果永久保存在数据库中。</li></ul><h3 id="MySQL-中有几种事务隔离级别？分别是什么？"><a href="#MySQL-中有几种事务隔离级别？分别是什么？" class="headerlink" title="MySQL 中有几种事务隔离级别？分别是什么？"></a>MySQL 中有几种事务隔离级别？分别是什么？</h3><p>MySQL 中有四种事务隔离级别，它们分别是：</p><ul><li>read uncommited：未提交读，读到未提交数据；</li><li>read committed：读已提交，也叫不可重复读，两次读取到的数据不一致；</li><li>repetable read：可重复读；</li><li>serializable：串行化，读写数据都会锁住整张表，数据操作不会出错，但并发性能极低，开发中很少用到。</li></ul><p>MySQL 默认使用 REPEATABLE-READ 的事务隔离级别。</p><h3 id="幻读和不可重复读的区别？"><a href="#幻读和不可重复读的区别？" class="headerlink" title="幻读和不可重复读的区别？"></a>幻读和不可重复读的区别？</h3><ul><li>不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）。</li><li>幻读的重点在于新增或者删除：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）。</li></ul><h3 id="并发事务一般有哪些问题？"><a href="#并发事务一般有哪些问题？" class="headerlink" title="并发事务一般有哪些问题？"></a>并发事务一般有哪些问题？</h3><ul><li>更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题，最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本，每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。 最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改，如果在前一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题。</li><li>脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务完成并提交前， 这条记录的数据就处于不一致状态； 这时， 另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些脏数据，并据此做进一步的处理，就会产生未提交的数据依赖关系，这种现象被形象地叫做脏读。</li><li>不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读” 。</li><li>幻读（Phantom Reads）： 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读” 。</li></ul><h3 id="并发事务有什么什么问题？应该如何解决？"><a href="#并发事务有什么什么问题？应该如何解决？" class="headerlink" title="并发事务有什么什么问题？应该如何解决？"></a>并发事务有什么什么问题？应该如何解决？</h3><p>并发事务可能造成：脏读、不可重复读和幻读等问题 ，这些问题其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决，解决方案如下：</p><ul><li>加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li><li>提供数据多版本并发控制（MultiVersion Concurrency Control，简称 MVCC 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取，从用户的角度来看，好象是数据库可以提供同一数据的多个版本。</li></ul><h3 id="什么是-MVCC？"><a href="#什么是-MVCC？" class="headerlink" title="什么是 MVCC？"></a>什么是 MVCC？</h3><p>MVCC 全称是多版本并发控制系统，InnoDB 和 Falcon 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决幻读问题。</p><h3 id="MVCC-是怎么工作的？"><a href="#MVCC-是怎么工作的？" class="headerlink" title="MVCC 是怎么工作的？"></a>MVCC 是怎么工作的？</h3><p>InnoDB 的 MVCC 是通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动新增，事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。</p><h3 id="REPEATABLE-READ（可重读）隔离级别下-MVCC-如何工作？"><a href="#REPEATABLE-READ（可重读）隔离级别下-MVCC-如何工作？" class="headerlink" title="REPEATABLE READ（可重读）隔离级别下 MVCC 如何工作？"></a>REPEATABLE READ（可重读）隔离级别下 MVCC 如何工作？</h3><ul><li>SELECT：InnoDB 会根据以下条件检查每一行记录：第一，InnoDB 只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行要么是在开始事务之前已经存在要么是事务自身插入或者修改过的。第二，行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除。</li><li>INSERT：InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。</li><li>DELETE：InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。</li><li>UPDATE：InnoDB 为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识保存这两个版本号，使大多数操作都不用加锁。它不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。</li></ul><h3 id="MySQL-事务实现原理是什么？"><a href="#MySQL-事务实现原理是什么？" class="headerlink" title="MySQL 事务实现原理是什么？"></a>MySQL 事务实现原理是什么？</h3><p>事务的实现是基于数据库的存储引擎，不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有InnoDB 和 NDB。 InnoDB 是高版本 MySQL 的默认的存储引擎，因此就以 InnoDB 的事务实现为例，InnoDB 是通过多版本并发控制（MVCC，Multiversion Concurrency Control ）解决不可重复读问题，加上间隙锁（也就是并发控制）解决幻读问题。因此 InnoDB 的 RR 隔离级别其实实现了串行化级别的效果，而且保留了比较好的并发性能。事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现。</p><h3 id="如何设置-MySQL-的事务隔离级别？"><a href="#如何设置-MySQL-的事务隔离级别？" class="headerlink" title="如何设置 MySQL 的事务隔离级别？"></a>如何设置 MySQL 的事务隔离级别？</h3><p>MySQL 事务隔离级别 MySQL.cnf 文件里设置的（默认目录 /etc/my.cnf），在文件的文末添加配置：</p><blockquote><p>transaction-isolation = REPEATABLE-READ</p></blockquote><p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p><h3 id="InnoDB-默认的事务隔离级别是什么？如何修改？"><a href="#InnoDB-默认的事务隔离级别是什么？如何修改？" class="headerlink" title="InnoDB 默认的事务隔离级别是什么？如何修改？"></a>InnoDB 默认的事务隔离级别是什么？如何修改？</h3><p>InnoDB 默认的事务隔离是 repetable read（可重复读）；可以通过 <code>set 作用域 transaction isolation level 事务隔离级别</code> 来修改事务的隔离级别，比如：</p><blockquote><p>MySQL&gt; set global transaction isolation level read committed; // 设置全局事务隔离级别为 read committed<br>MySQL&gt; set session transaction isolation level read committed; // 设置当前会话事务隔离级别为 read committed</p></blockquote><h3 id="InnoDB-如何开启手动提交事务？"><a href="#InnoDB-如何开启手动提交事务？" class="headerlink" title="InnoDB 如何开启手动提交事务？"></a>InnoDB 如何开启手动提交事务？</h3><p>InnoDB 默认是自动提交事务的，每一次 SQL 操作（非 select 操作）都会自动提交一个事务，如果要手动开启事务需要设置 <code>set autocommit=0</code> 禁止自动提交事务，相当于开启手动提交事务。</p><h3 id="在-InnoDB-中设置了-autocommit-0，添加一条信息之后没有手动执行提交操作，请问这条信息可以被查到吗？"><a href="#在-InnoDB-中设置了-autocommit-0，添加一条信息之后没有手动执行提交操作，请问这条信息可以被查到吗？" class="headerlink" title="在 InnoDB 中设置了 autocommit=0，添加一条信息之后没有手动执行提交操作，请问这条信息可以被查到吗？"></a>在 InnoDB 中设置了 autocommit=0，添加一条信息之后没有手动执行提交操作，请问这条信息可以被查到吗？</h3><p>autocommit=0 表示禁止自动事务提交，在添加操作之后没有进行手动提交，默认情况下其他连接客户端是查询不到此条新增数据的。</p><h3 id="如何手动操作事务？"><a href="#如何手动操作事务？" class="headerlink" title="如何手动操作事务？"></a>如何手动操作事务？</h3><p>使用 begin 开启事务；rollback 回滚事务；commit 提交事务。具体使用示例如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> person(uname,age) <span class="keyword">values</span>(<span class="string">&#x27;laowang&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><h2 id="MySQL-中锁的面试题总结"><a href="#MySQL-中锁的面试题总结" class="headerlink" title="MySQL 中锁的面试题总结"></a>MySQL 中锁的面试题总结</h2><h3 id="什么是锁？MySQL-中提供了几类锁？"><a href="#什么是锁？MySQL-中提供了几类锁？" class="headerlink" title="什么是锁？MySQL 中提供了几类锁？"></a>什么是锁？MySQL 中提供了几类锁？</h3><p>锁是实现数据库并发控制的重要手段，可以保证数据库在多人同时操作时能够正常运行。MySQL 提供了全局锁、行级锁、表级锁。其中 InnoDB 支持表级锁和行级锁，MyISAM 只支持表级锁。</p><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的过程称为死锁。</p><p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的过程称为死锁。</p><h3 id="常见的死锁案例有哪些？"><a href="#常见的死锁案例有哪些？" class="headerlink" title="常见的死锁案例有哪些？"></a>常见的死锁案例有哪些？</h3><ul><li>将投资的钱拆封几份借给借款人，这时处理业务逻辑就要把若干个借款人一起锁住 select * from xxx where id in (xx,xx,xx) for update。</li><li>批量入库，存在则更新，不存在则插入。解决方法 insert into tab(xx,xx) on duplicate key update <code>xx</code>=’xx’。</li></ul><h3 id="如何处理死锁？"><a href="#如何处理死锁？" class="headerlink" title="如何处理死锁？"></a>如何处理死锁？</h3><p>对待死锁常见的两种策略：</p><ul><li>通过 innodb<em>lock</em>wait_timeout 来设置超时时间，一直等待直到超时；</li><li>发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其它事务继续执行。</li></ul><h3 id="如何查看死锁？"><a href="#如何查看死锁？" class="headerlink" title="如何查看死锁？"></a>如何查看死锁？</h3><ul><li>使用命令 <code>show engine innodb status</code> 查看最近的一次死锁。</li><li>InnoDB Lock Monitor 打开锁监控，每 15s 输出一次日志。使用完毕后建议关闭，否则会影响数据库性能。</li></ul><h3 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h3><ul><li>为了在单个 InnoDB 表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用 SELECT … FOR UPDATE 语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</li><li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</li><li>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</li><li>通过 SELECT … LOCK IN SHARE MODE 获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</li><li>改变事务隔离级别。</li></ul><h3 id="InnoDB-默认是如何对待死锁的？"><a href="#InnoDB-默认是如何对待死锁的？" class="headerlink" title="InnoDB 默认是如何对待死锁的？"></a>InnoDB 默认是如何对待死锁的？</h3><p>InnoDB 默认是使用设置死锁时间来让死锁超时的策略，默认 innodb<em>lock</em>wait_timeout 设置的时长是 50s。</p><h3 id="如何开启死锁检测？"><a href="#如何开启死锁检测？" class="headerlink" title="如何开启死锁检测？"></a>如何开启死锁检测？</h3><p>设置 innodb<em>deadlock</em>detect 设置为 on 可以主动检测死锁，在 Innodb 中这个值默认就是 on 开启的状态。</p><h3 id="什么是全局锁？它的应用场景有哪些？"><a href="#什么是全局锁？它的应用场景有哪些？" class="headerlink" title="什么是全局锁？它的应用场景有哪些？"></a>什么是全局锁？它的应用场景有哪些？</h3><p>全局锁就是对整个数据库实例加锁，它的典型使用场景就是做全库逻辑备份。 这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句、更新类事务的提交语句等操作都会被阻塞。</p><h3 id="什么是共享锁？"><a href="#什么是共享锁？" class="headerlink" title="什么是共享锁？"></a>什么是共享锁？</h3><p>共享锁又称读锁 (read lock)，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。</p><h3 id="什么是排它锁？"><a href="#什么是排它锁？" class="headerlink" title="什么是排它锁？"></a>什么是排它锁？</h3><p>排他锁 exclusive lock（也叫 writer lock）又称写锁。</p><p>若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁，其他进程可以读取,不能进行写操作，需等待其释放。</p><p>排它锁是悲观锁的一种实现，在上面悲观锁也介绍过。</p><p>若事务 1 对数据对象 A 加上 X 锁，事务 1 可以读 A 也可以修改 A，其他事务不能再对 A 加任何锁，直到事物 1 释放 A 上的锁。这保证了其他事务在事物 1 释放 A 上的锁之前不能再读取和修改 A。排它锁会阻塞所有的排它锁和共享锁。</p><h3 id="使用全局锁会导致什么问题？"><a href="#使用全局锁会导致什么问题？" class="headerlink" title="使用全局锁会导致什么问题？"></a>使用全局锁会导致什么问题？</h3><p>如果在主库备份，在备份期间不能更新，业务停摆，所以更新业务会处于等待状态。</p><p>如果在从库备份，在备份期间不能执行主库同步的 binlog，导致主从延迟。</p><h3 id="如何处理逻辑备份时，整个数据库不能插入的情况？"><a href="#如何处理逻辑备份时，整个数据库不能插入的情况？" class="headerlink" title="如何处理逻辑备份时，整个数据库不能插入的情况？"></a>如何处理逻辑备份时，整个数据库不能插入的情况？</h3><p>如果使用全局锁进行逻辑备份就会让整个库成为只读状态，幸好官方推出了一个逻辑备份工具 MySQLdump 来解决了这个问题，只需要在使用 MySQLdump 时，使用参数 -single-transaction 就会在导入数据之前启动一个事务来保证数据的一致性，并且这个过程是支持数据更新操作的。</p><h3 id="如何设置数据库为全局只读锁？"><a href="#如何设置数据库为全局只读锁？" class="headerlink" title="如何设置数据库为全局只读锁？"></a>如何设置数据库为全局只读锁？</h3><p>使用命令 <code>flush tables with read lock</code>（简称 FTWRL）就可以实现设置数据库为全局只读锁。</p><h3 id="除了-FTWRL-可以设置数据库只读外，还有什么别的方法？"><a href="#除了-FTWRL-可以设置数据库只读外，还有什么别的方法？" class="headerlink" title="除了 FTWRL 可以设置数据库只读外，还有什么别的方法？"></a>除了 FTWRL 可以设置数据库只读外，还有什么别的方法？</h3><p>除了使用 FTWRL 外，还可以使用命令 set global readonly=true 设置数据库为只读。</p><h3 id="FTWRL-和-set-global-readonly-true-有什么区别？"><a href="#FTWRL-和-set-global-readonly-true-有什么区别？" class="headerlink" title="FTWRL 和 set global readonly=true 有什么区别？"></a>FTWRL 和 set global readonly=true 有什么区别？</h3><p>FTWRL 和 set global readonly=true 都是设置整个数据库为只读状态，但他们最大的区别就是，当执行 FTWRL 的客户端断开之后，整个数据库会取消只读，而 set global readonly=true 会一直让数据处于只读状态。</p><h3 id="如何实现表锁？"><a href="#如何实现表锁？" class="headerlink" title="如何实现表锁？"></a>如何实现表锁？</h3><p>MySQL 里标记锁有两种：表级锁、元数据锁（meta data lock）简称 MDL。表锁的语法是 lock tables t read/write。</p><p>可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p><p>对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。</p><p>MDL：不需要显式使用，在访问一个表的时候会被自动加上。</p><p>MDL 的作用：保证读写的正确性。</p><p>在对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p><p>读锁之间不互斥，读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性。</p><p>MDL 会直到事务提交才会释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。</p><h3 id="悲观锁和乐观锁有什么区别？"><a href="#悲观锁和乐观锁有什么区别？" class="headerlink" title="悲观锁和乐观锁有什么区别？"></a>悲观锁和乐观锁有什么区别？</h3><p>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。正因为如此，悲观锁需要耗费较多的时间，另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</p><p>说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。</p><p>乐观锁是用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 version 字段来实现。当读取数据时，将 version 字段的值一同读出，数据每更新一次，对此 version 值加 1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的 version 值相等，则予以更新，否则认为是过期数据。</p><p><strong>比如：</strong> 1、数据库表三个字段，分别是id、value、version <code>select id,value,version from t where id=#&#123;id&#125;</code> 2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> t</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">value</span>=<span class="number">2</span>,<span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span>=<span class="comment">#&#123;id&#125; and version=#&#123;version&#125;</span></span><br></pre></td></tr></table></figure><h3 id="乐观锁有什么优点和缺点？"><a href="#乐观锁有什么优点和缺点？" class="headerlink" title="乐观锁有什么优点和缺点？"></a>乐观锁有什么优点和缺点？</h3><p>因为没有加锁所以乐观锁的优点就是执行性能高。它的缺点就是有可能产生 ABA 的问题，ABA 问题指的是有一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，会误以为没有被修改会正常的执行修改操作，实际上这段时间它的值可能被改了其他值，之后又改回为 A 值，这个问题被称为 ABA 问题。</p><h3 id="InnoDB-存储引擎有几种锁算法？"><a href="#InnoDB-存储引擎有几种锁算法？" class="headerlink" title="InnoDB 存储引擎有几种锁算法？"></a>InnoDB 存储引擎有几种锁算法？</h3><ul><li>Record Lock — 单个行记录上的锁；</li><li>Gap Lock — 间隙锁，锁定一个范围，不包括记录本身；</li><li>Next-Key Lock — 锁定一个范围，包括记录本身。</li></ul><h3 id="InnoDB-如何实现行锁？"><a href="#InnoDB-如何实现行锁？" class="headerlink" title="InnoDB 如何实现行锁？"></a>InnoDB 如何实现行锁？</h3><p>行级锁是 MySQL 中粒度最小的一种锁，他能大大减少数据库操作的冲突。</p><p>INNODB 的行级锁有共享锁（S LOCK）和排他锁（X LOCK）两种。共享锁允许事物读一行记录，不允许任何线程对该行记录进行修改。排他锁允许当前事物删除或更新一行记录，其他线程不能操作该记录。</p><p>共享锁：SELECT … LOCK IN SHARE MODE，MySQL 会对查询结果集中每行都添加共享锁，前提是当前线程没有对该结果集中的任何行使用排他锁，否则申请会阻塞。</p><p>排他锁：select * from t where id=1 for update，其中 id 字段必须有索引，MySQL 会对查询结果集中每行都添加排他锁，在事物操作中，任何对记录的更新与删除操作会自动加上排他锁。前提是当前没有线程对该结果集中的任何行使用排他锁或共享锁，否则申请会阻塞。</p><h3 id="优化锁方面你有什么建议？"><a href="#优化锁方面你有什么建议？" class="headerlink" title="优化锁方面你有什么建议？"></a>优化锁方面你有什么建议？</h3><ul><li>尽量使用较低的隔离级别。</li><li>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会。</li><li>选择合理的事务大小，小事务发生锁冲突的几率也更小。</li><li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。</li><li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会。</li><li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。</li><li>不要申请超过实际需要的锁级别。</li><li>除非必须，查询时不要显示加锁。 MySQL 的 MVCC 可以实现事务中的查询不用加锁，优化事务性能；MVCC 只在 COMMITTED READ（读提交）和 REPEATABLE READ（可重复读）两种隔离级别下工作。</li><li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li></ul><h2 id="MySQL-中日志的面试题总结"><a href="#MySQL-中日志的面试题总结" class="headerlink" title="MySQL 中日志的面试题总结"></a>MySQL 中日志的面试题总结</h2><h3 id="MySQL-有哪些重要的日志文件？"><a href="#MySQL-有哪些重要的日志文件？" class="headerlink" title="MySQL 有哪些重要的日志文件？"></a>MySQL 有哪些重要的日志文件？</h3><p>MySQL 中的重要日志分为以下几个： <strong>① 错误日志</strong>：用来记录 MySQL 服务器运行过程中的错误信息，比如，无法加载 MySQL 数据库的数据文件，或权限不正确等都会被记录在此，还有复制环境下，从服务器进程的信息也会被记录进错误日志。默认情况下，错误日志是开启的，且无法被禁止。默认情况下，错误日志是存储在数据库的数据文件目录中，名称为 hostname.err，其中 hostname 为服务器主机名。在 MySQL 5.5.7 之前，数据库管理员可以删除很长时间之前的错误日志，以节省服务器上的硬盘空间， MySQL 5.5.7 之后，服务器将关闭此项功能，只能使用重命名原来的错误日志文件，手动冲洗日志创建一个新的，命令为：</p><blockquote><p>mv hostname.err hostname.err.old mysqladmin flush-logs</p></blockquote><p><strong>② 查询日志</strong>：查询日志在 MySQL 中被称为 general log(通用日志)，查询日志里的内容不要被“查询日志”误导，认为里面只存储 select 语句，其实不然，查询日志里面记录了数据库执行的所有命令，不管语句是否正确，都会被记录，具体原因如下:</p><ul><li>insert 查询为了避免数据冲突，如果此前插入过数据，当前插入的数据如果跟主键或唯一键的数据重复那肯定会报错；</li><li>update 时也会查询因为更新的时候很可能会更新某一块数据；</li><li>delete 查询，只删除符合条件的数据；</li></ul><p>因此都会产生日志，在并发操作非常多的场景下，查询信息会非常多，那么如果都记录下来会导致 IO 非常大，影响 MySQL 性能，因此如果不是在调试环境下，是不建议开启查询日志功能的。</p><p>查询日志的开启有助于帮助我们分析哪些语句执行密集，执行密集的 select 语句对应的数据是否能够被缓存，同时也可以帮助我们分析问题，所以，我们可以根据自己的实际情况来决定是否开启查询日志。</p><p>查询日志模式是关闭的，可以通过以下命令开启查询日志：</p><blockquote><p>set global general<em>log=1 set global log</em>output=’table’;</p></blockquote><p>general_log=1 为开启查询日志，0 为关闭查询日志，这个设置命令即时生效，不用重启 MySQL 服务器。</p><p><strong>③ 慢日志</strong>：慢查询会导致 CPU、IOPS、内存消耗过高，当数据库遇到性能瓶颈时，大部分时间都是由于慢查询导致的。开启慢查询日志，可以让 MySQL 记录下查询超过指定时间的语句，之后运维人员通过定位分析，能够很好的优化数据库性能。默认情况下，慢查询日志是不开启的，只有手动开启了，慢查询才会被记录到慢查询日志中。使用如下命令记录当前数据库的慢查询语句：</p><blockquote><p>set global slow<em>query</em>log=’ON’;</p></blockquote><p>使用 set global slow<em>query</em>log=’ON’ 开启慢查询日志，只是对当前数据库有效，如果 MySQL 数据库重启后就会失效。所以如果要永久生效，就要修改配置文件 my.cnf，设置 slow<em>query</em>log=1 并重启 MySQL 服务器。</p><p><strong>④ redo log（重做日志）</strong>：为了最大程度的避免数据写入时，因为 IO 瓶颈造成的性能问题，MySQL 采用了这样一种缓存机制，先将数据写入内存中，再批量把内存中的数据统一刷回磁盘。为了避免将数据刷回磁盘过程中，因为掉电或系统故障带来的数据丢失问题，InnoDB 采用 redo log 来解决此问题。</p><p><strong>⑤ undo log（回滚日志）</strong>：用于存储日志被修改前的值，从而保证如果修改出现异常，可以使用 undo log 日志来实现回滚操作。 undo log 和 redo log 记录物理日志不一样，它是逻辑日志，可以认为当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录，当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。undo log 默认存放在共享表空间中，在 ySQL 5.6 中，undo log 的存放位置还可以通过变量 innodb<em>undo</em>directory 来自定义存放目录，默认值为“.”表示 datadir 目录。</p><p><strong>⑥ bin log（二进制日志）</strong>：是一个二进制文件，主要记录所有数据库表结构变更，比如，CREATE、ALTER TABLE 等，以及表数据修改，比如，INSERT、UPDATE、DELETE 的所有操作，bin log 中记录了对 MySQL 数据库执行更改的所有操作，并且记录了语句发生时间、执行时长、操作数据等其它额外信息，但是它不记录 SELECT、SHOW 等那些不修改数据的 SQL 语句。</p><p>binlog 的作用如下：</p><ul><li>恢复（recovery）：某些数据的恢复需要二进制日志。比如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行 point-in-time 的恢复；</li><li>复制（replication）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的MySQL数据库（一般称为 slave 或者 standby）与一台 MySQL 数据库（一般称为 master 或者 primary）进行实时同步；</li><li>审计（audit）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。</li></ul><p>除了上面介绍的几个作用外，binlog 对于事务存储引擎的崩溃恢复也有非常重要的作用，在开启 binlog 的情况下，为了保证 binlog 与 redo 的一致性，MySQL 将采用事务的两阶段提交协议。当 MySQL 系统发生崩溃时，事务在存储引擎内部的状态可能为 prepared（准备状态）和 commit（提交状态）两种，对于 prepared 状态的事务，是进行提交操作还是进行回滚操作，这时需要参考 binlog，如果事务在 binlog 中存在，那么将其提交；如果不在 binlog 中存在，那么将其回滚，这样就保证了数据在主库和从库之间的一致性。</p><p>binlog 默认是关闭状态，可以在 MySQL 配置文件（my.cnf）中通过配置参数 log-bin = [base-name] 开启记录 binlog 日志，如果不指定 base-name，则默认二进制日志文件名为主机名，并以自增的数字作为后缀，比如：mysql-bin.000001，所在目录为数据库所在目录（datadir）。</p><p>通过以下命令来查询 binlog 是否开启：</p><blockquote><p>show variables like ‘log_%’;</p></blockquote><p><img src="/" alt="avatar" class="lazyload" data-src="https://images.gitbook.cn/FgEYSjP2dZUfV5KmKHmQUbUqpbqS"></p><p>binlog 格式分为: STATEMENT、ROW 和 MIXED 三种：</p><ul><li>STATEMENT 格式的 binlog 记录的是数据库上执行的原生 SQL 语句。这种格式的优点是简单，简单地记录和执行这些语句，能够让主备保持同步，在主服务器上执行的 SQL 语句，在从服务器上执行同样的语句。另一个好处是二进制日志里的时间更加紧凑，所以相对而言，基于语句的复制模式不会使用太多带宽，同时也节约磁盘空间。并且通过 mysqlbinlog 工具容易读懂其中的内容。缺点就是同一条 SQL 在主库和从库上执行的时间可能稍微或很大不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法被正确复制的 SQL。比如，使用 INSERT INTO TB1 VALUE(CUURENT_DATE()) 这一条使用函数的语句插入的数据复制到当前从服务器上来就会发生变化，存储过程和触发器在使用基于语句的复制模式时也可能存在问题；另外一个问题就是基于语句的复制必须是串行化的，比如：InnoDB 的 next-key 锁等，并不是所有的存储引擎都支持基于语句的复制；</li><li>ROW 格式是从 MySQL 5.1 开始支持基于行的复制，也就是基于数据的复制，基于行的更改。这种方式会将实际数据记录在二进制日志中，它有其自身的一些优点和缺点，最大的好处是可以正确地复制每一行数据，一些语句可以被更加有效地复制，另外就是几乎没有基于行的复制模式无法处理的场景，对于所有的 SQL 构造、触发器、存储过程等都能正确执行；它的缺点就是二进制日志可能会很大，而且不直观，所以，你不能使用 mysqlbinlog 来查看二进制日志，也无法通过看二进制日志判断当前执行到那一条 SQL 语句。现在对于 ROW 格式的二进制日志基本是标配了，主要是因为它的优势远远大于缺点，并且由于 ROW 格式记录行数据，所以可以基于这种模式做一些 DBA 工具，比如数据恢复，不同数据库之间数据同步等；</li><li>MIXED 也是 MySQL 默认使用的二进制日志记录方式，但 MIXED 格式默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。比如用到 UUID()、USER()、CURRENT<em>USER()、ROW</em>COUNT() 等无法确定的函数。</li></ul><h3 id="redo-log-和-binlog-有什么区别？"><a href="#redo-log-和-binlog-有什么区别？" class="headerlink" title="redo log 和 binlog 有什么区别？"></a>redo log 和 binlog 有什么区别？</h3><p>redo log（重做日志）和 binlog（归档日志）都是 MySQL 的重要的日志，它们的区别如下：</p><ul><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”。</li><li>binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ul><p>最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统，也就是 redo log 来实现 crash-safe 能力。</p><h3 id="什么是-crash-safe？"><a href="#什么是-crash-safe？" class="headerlink" title="什么是 crash-safe？"></a>什么是 crash-safe？</h3><p>crash-safe 是指发生宕机等意外情况下，服务器重启后数据依然不会丢失的情况。</p><h3 id="什么是脏页和干净页？"><a href="#什么是脏页和干净页？" class="headerlink" title="什么是脏页和干净页？"></a>什么是脏页和干净页？</h3><p>MySQL 为了操作的性能优化，会把数据更新先放入内存中，之后再统一更新到磁盘。当内存数据和磁盘数据内容不一致的时候，我们称这个内存页为脏页；内存数据写到磁盘后，内存的数据和磁盘上的内容就一致了，我们称为“干净页”。</p><h3 id="什么情况下会引发-MySQL-刷脏页（flush）的操作？"><a href="#什么情况下会引发-MySQL-刷脏页（flush）的操作？" class="headerlink" title="什么情况下会引发 MySQL 刷脏页（flush）的操作？"></a>什么情况下会引发 MySQL 刷脏页（flush）的操作？</h3><ul><li>内存写满了，这个时候就会引发 flush 操作，对应到 InnoDB 就是 redo log 写满了；</li><li>系统的内存不足了，当需要新的内存页的时候，就会淘汰一些内存页，如果淘汰的是脏页这个时候就会触发 flush 操作；</li><li>系统空闲的时候，MySQL 会同步内存中的数据到磁盘也会触发 flush 操作；</li><li>MySQL 服务关闭的时候也会刷脏页，触发 flush 操作。</li></ul><h3 id="MySQL-刷脏页的速度很慢可能是什么原因？"><a href="#MySQL-刷脏页的速度很慢可能是什么原因？" class="headerlink" title="MySQL 刷脏页的速度很慢可能是什么原因？"></a>MySQL 刷脏页的速度很慢可能是什么原因？</h3><p>在 MySQL 中单独刷一个脏页的速度是很快的，如果发现刷脏页的速度很慢，说明触发了 MySQL 刷脏页的“连坐”机制，MySQL 的“连坐”机制是指当 MySQL 刷脏页的时候如果发现相邻的数据页也是脏页也会一起刷掉，而这个动作可以一直蔓延下去，这就是导致 MySQL 刷脏页慢的原因了。</p><h3 id="如何控制-MySQL-只刷新当前脏页？"><a href="#如何控制-MySQL-只刷新当前脏页？" class="headerlink" title="如何控制 MySQL 只刷新当前脏页？"></a>如何控制 MySQL 只刷新当前脏页？</h3><p>在 InnoDB 中设置 innodb<em>flush</em>neighbors 这个参数的值为 0，来规定 MySQL 只刷当前脏页，MySQL 8 这个值默认是 0。</p><h3 id="MySQL-的-WAL-技术是解决什么问题的？"><a href="#MySQL-的-WAL-技术是解决什么问题的？" class="headerlink" title="MySQL 的 WAL 技术是解决什么问题的？"></a>MySQL 的 WAL 技术是解决什么问题的？</h3><p>A.防止误删除，找回数据用的 B.容灾恢复，为了还原异常数据用的 C.事务处理，为了数据库的稳定性 D.为了降低 IO 成本 答：D 题目解析：WAL 技术的全称是 Write Ahead Logging（中文：预写式日志），是先写日志，再写磁盘的方式，因为每次更新都写磁盘的话 IO 成本很高，所以才有了 WAL 技术。</p><h3 id="为什么有时候会感觉-MySQL-偶尔卡一下？"><a href="#为什么有时候会感觉-MySQL-偶尔卡一下？" class="headerlink" title="为什么有时候会感觉 MySQL 偶尔卡一下？"></a>为什么有时候会感觉 MySQL 偶尔卡一下？</h3><p>如果偶尔感觉 MySQL 卡一下，可能是 MySQL 正在刷脏页，正在把内存中的更新操作刷到磁盘中。</p><h3 id="redo-log-和-binlog-是怎么关联的"><a href="#redo-log-和-binlog-是怎么关联的" class="headerlink" title="redo log 和 binlog 是怎么关联的?"></a>redo log 和 binlog 是怎么关联的?</h3><p>它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：</p><ul><li>如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；</li><li>如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。</li></ul><h3 id="MySQL-怎么知道-binlog-是完整的"><a href="#MySQL-怎么知道-binlog-是完整的" class="headerlink" title="MySQL 怎么知道 binlog 是完整的?"></a>MySQL 怎么知道 binlog 是完整的?</h3><ul><li>statement 格式的 binlog，完整的标识是最后有 COMMIT 关键字。</li><li>row 格式的 binlog，完整的标识是最后会有一个 XID event 关键字。</li></ul><h3 id="MySQL-中可不可以只要-binlog，不要-redo-log？"><a href="#MySQL-中可不可以只要-binlog，不要-redo-log？" class="headerlink" title="MySQL 中可不可以只要 binlog，不要 redo log？"></a>MySQL 中可不可以只要 binlog，不要 redo log？</h3><p>不可以，binlog 没有崩溃恢复的能力。</p><h3 id="MySQL-中可不可以只要-redo-log，不要-binlog？"><a href="#MySQL-中可不可以只要-redo-log，不要-binlog？" class="headerlink" title="MySQL 中可不可以只要 redo log，不要 binlog？"></a>MySQL 中可不可以只要 redo log，不要 binlog？</h3><p>不可以，原因有以下两个：</p><ul><li>redo log 是循环写不能保证所有的历史数据，这些历史数据只能在 binlog 中找到；</li><li>binlog 是高可用的基础，高可用的实现原理就是 binlog 复制。</li></ul><h3 id="为什么-binlog-cache-是每个线程自己维护的，而-redo-log-buffer-是全局共用的？"><a href="#为什么-binlog-cache-是每个线程自己维护的，而-redo-log-buffer-是全局共用的？" class="headerlink" title="为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？"></a>为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？</h3><p>因为 binlog 是不能“被打断的”，一个事务的 binlog 必须连续写，因此要整个事务完成后，再一起写到文件里。而 redo log 并没有这个要求，中间有生成的日志可以写到 redo log buffer 中，redo log buffer 中的内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。</p><h3 id="事务执行期间，还未提交，如果发生-crash，redo-log-丢失，会导致主备不一致呢？"><a href="#事务执行期间，还未提交，如果发生-crash，redo-log-丢失，会导致主备不一致呢？" class="headerlink" title="事务执行期间，还未提交，如果发生 crash，redo log 丢失，会导致主备不一致呢？"></a>事务执行期间，还未提交，如果发生 crash，redo log 丢失，会导致主备不一致呢？</h3><p>不会，因为这时候 binlog 也还在 binlog cache 里，没发给备库，crash 以后 redo log 和 binlog 都没有了，从业务角度看这个事务也没有提交，所以数据是一致的。</p><h3 id="在-MySQL-中用什么机制来优化随机读-写磁盘对-IO-的消耗？"><a href="#在-MySQL-中用什么机制来优化随机读-写磁盘对-IO-的消耗？" class="headerlink" title="在 MySQL 中用什么机制来优化随机读/写磁盘对 IO 的消耗？"></a>在 MySQL 中用什么机制来优化随机读/写磁盘对 IO 的消耗？</h3><p>redo log 是用来节省随机写磁盘的 IO 消耗，而 change buffer 主要是节省随机读磁盘的 IO 消耗。redo log 会把 MySQL 的更新操作先记录到内存中，之后再统一更新到磁盘，而 change buffer 也是把关键查询数据先加载到内存中，以便优化 MySQL 的查询。</p><h3 id="以下说法错误的是？"><a href="#以下说法错误的是？" class="headerlink" title="以下说法错误的是？"></a>以下说法错误的是？</h3><p>A.redo log 是 InnoDB 引擎特有的，它的固定大小的 B.redo log 日志是不全的，只有最新的一些日志，这和它的内存大小有关 C.redo log 可以保证数据库异常重启之后，数据不丢失 D.binlog 是 MySQL 自带的日志，它能保证数据库异常重启之后，数据不丢失 答：D 题目解析：binlog 是 MySQL 自带的日志，但它并不能保证数据库异常重启之后数据不丢失。</p><h3 id="以下说法正确的是？"><a href="#以下说法正确的是？" class="headerlink" title="以下说法正确的是？"></a>以下说法正确的是？</h3><p>A.redo log 日志是追加写的，后面的日志并不会覆盖前面的日志 B.binlog 日志是追加写的，后面的日志并不会覆盖前面的日志 C.redo log 和 binlog 日志都是追加写的，后面的日志并不会覆盖前面的日志 D.以上说法都正确 答：B 题目解析：binlog 日志是追加写的，后面的日志并不会覆盖前面的日志，redo log 日志是固定大小的，后面的日志会覆盖前面的日志。</p><h3 id="有没有办法把-MySQL-的数据恢复到过去某个指定的时间节点？怎么恢复？"><a href="#有没有办法把-MySQL-的数据恢复到过去某个指定的时间节点？怎么恢复？" class="headerlink" title="有没有办法把 MySQL 的数据恢复到过去某个指定的时间节点？怎么恢复？"></a>有没有办法把 MySQL 的数据恢复到过去某个指定的时间节点？怎么恢复？</h3><p>可以恢复，只要你备份了这段时间的所有 binlog，同时做了全量数据库的定期备份，比如，一天一备，或者三天一备，这取决于你们的备份策略，这个时候你就可以把之前备份的数据库先还原到测试库，从备份的时间点开始，将备份的 binlog 依次取出来，重放到你要恢复数据的那个时刻，这个时候就完成了数据到指定节点的恢复。比如，今天早上 9 点的时候，你想把数据恢复成今天早上 6:00:00 的状态，这个时候你可以先取出今天凌晨（00:01:59）备份的数据库文件，还原到测试库，再从 binlog 文件中依次取出 00:01:59 之后的操作信息，重放到 6:00:00 这个时刻，这就完成了数据库的还原。</p><h2 id="MySQL-命令和内置函数"><a href="#MySQL-命令和内置函数" class="headerlink" title="MySQL 命令和内置函数"></a>MySQL 命令和内置函数</h2><h3 id="如何用命令行方式连接-MySQL-数据库？"><a href="#如何用命令行方式连接-MySQL-数据库？" class="headerlink" title="如何用命令行方式连接 MySQL 数据库？"></a>如何用命令行方式连接 MySQL 数据库？</h3><p>使用 <code>mysql -u用户名 -p密码;</code> 输入用户名和密码就可以正常进入数据库连接了，实例如下：</p><blockquote><p>mysql -uroot -p123456;</p></blockquote><p>其中，用户名为 root，密码为 123456。</p><h3 id="关于命令-mysql-h-127-0-0-1-uroot-P-3307-p3307-以下说法错误的是？"><a href="#关于命令-mysql-h-127-0-0-1-uroot-P-3307-p3307-以下说法错误的是？" class="headerlink" title="关于命令 mysql -h 127.0.0.1 -uroot -P 3307 -p3307 以下说法错误的是？"></a>关于命令 <code>mysql -h 127.0.0.1 -uroot -P 3307 -p3307</code> 以下说法错误的是？</h3><p>A.-h 和 -P 可以省略 B.-u 和用户名之间不能有空格 C.-p 和密码之间不能用空格 D.小写 -p 对应的是用户密码，大写 -P 对应的是 MySQL 服务器的端口</p><p>答：B 题目解析：-p 和密码之间不能用空格，否则空格会被识别为密码的一部分，提示密码错误。-u 和用户名之间可以有空格。</p><h3 id="如何创建用户？并给用户授权？"><a href="#如何创建用户？并给用户授权？" class="headerlink" title="如何创建用户？并给用户授权？"></a>如何创建用户？并给用户授权？</h3><p>创建用户使用关键字：<code>CREATE USER</code> ，授权使用关键字： <code>GRANT</code> ，具体实现脚本如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建用户 laowang</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;laowang&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="comment">-- 授权 test 数据库给 laowang</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> test.* <span class="keyword">to</span> <span class="string">&#x27;laowang&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="如何修改-MySQL-密码？"><a href="#如何修改-MySQL-密码？" class="headerlink" title="如何修改 MySQL 密码？"></a>如何修改 MySQL 密码？</h3><p>使用如下命令，修改密码：</p><blockquote><p>mysqladmin -u用户名 -p旧密码 password 新密码;</p></blockquote><p>注意：刚开始 root 没有密码，所以 -p 旧密码一项就可以省略了。</p><h3 id="如何使用-SQL-创建数据库，并设置数据库的编码格式？"><a href="#如何使用-SQL-创建数据库，并设置数据库的编码格式？" class="headerlink" title="如何使用 SQL 创建数据库，并设置数据库的编码格式？"></a>如何使用 SQL 创建数据库，并设置数据库的编码格式？</h3><p>创建数据库可使用关键字： <code>CREATE DATABASE</code> ，设置编码格式使用关键字： <code>CHARSET</code> ，具体 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> learndb <span class="keyword">default</span> <span class="keyword">charset</span> utf8 <span class="keyword">collate</span> utf8_general_ci;</span><br></pre></td></tr></table></figure><h3 id="如何修改数据库、表的编码格式？"><a href="#如何修改数据库、表的编码格式？" class="headerlink" title="如何修改数据库、表的编码格式？"></a>如何修改数据库、表的编码格式？</h3><p>使用 <code>alter</code> 关键字设置库或表的编码格式即可，具体代码如下：</p><blockquote><p>mysql&gt; alter database dbname default character set utf8; mysql&gt; alter table t default character set utf8;</p></blockquote><h3 id="如何使用-SQL-创建表？"><a href="#如何使用-SQL-创建表？" class="headerlink" title="如何使用 SQL 创建表？"></a>如何使用 SQL 创建表？</h3><p>创建表的 SQL 如下：</p><blockquote><p>create table t( t<em>id int not null auto</em>increment, t<em>name char(50) not null, t</em>age int null default 18, primary key(t_id) )engine=innodb;</p></blockquote><p>其中：</p><ul><li>auto_increment：表示自增；</li><li>primary key：用于指定主键；</li><li>engine：用于指定表的引擎。</li></ul><h3 id="在-MySQL-命令行中如何查看表结构信息？"><a href="#在-MySQL-命令行中如何查看表结构信息？" class="headerlink" title="在 MySQL 命令行中如何查看表结构信息？"></a>在 MySQL 命令行中如何查看表结构信息？</h3><p>使用 <code>desc 表名</code> 查看表结构信息，示例信息如下：</p><p><img src="/" alt="avatar" class="lazyload" data-src="https://images.gitbook.cn/FgMUr0ZJLJ62VlIcXh7e6UxLcLVy"></p><p>使用 <code>desc person;</code> 查看表 <code>person</code> 的结构信息。</p><h3 id="如何使用-SQL-查看已知表的建表脚本？"><a href="#如何使用-SQL-查看已知表的建表脚本？" class="headerlink" title="如何使用 SQL 查看已知表的建表脚本？"></a>如何使用 SQL 查看已知表的建表脚本？</h3><p>查看已知表的建表脚本，命令如下：</p><blockquote><p>mysql&gt; show create table 表名;</p></blockquote><p>效果如下图所示：</p><p><img src="/" alt="avatar" class="lazyload" data-src="https://images.gitbook.cn/FtOxBQQ6_3R0suC7NwfdyfhUXhjP"></p><h3 id="如何使用-SQL-语句更新表结构？"><a href="#如何使用-SQL-语句更新表结构？" class="headerlink" title="如何使用 SQL 语句更新表结构？"></a>如何使用 SQL 语句更新表结构？</h3><p>更新表结构信息可以使用 alter table 子句，如，为表增加一列的脚本如下：alter</p><blockquote><p>alter table t add name char(20)；</p></blockquote><p>如果要重命名表名，使用如下命令：</p><blockquote><p>rename table new_t to t;</p></blockquote><h3 id="MySQL-有哪些删除方式？有什么区别？"><a href="#MySQL-有哪些删除方式？有什么区别？" class="headerlink" title="MySQL 有哪些删除方式？有什么区别？"></a>MySQL 有哪些删除方式？有什么区别？</h3><p>MySQL 有三种删除方式： 1）删除表数据：</p><blockquote><p>delete from t;</p></blockquote><p>2）删除数据，保留表结构：</p><blockquote><p>truncate table t;</p></blockquote><p>3）删数据和表结构：</p><blockquote><p>drop table t;</p></blockquote><p>它们的区别如下：</p><ul><li>delete 可以有条件的删除，也可以回滚数据，删除数据时进行两个动作：删除与备份，所以速度很慢；</li><li>truncate 删除所有数据，无条件选择删除，不可回滚，保留表结构；</li><li>drop：删除数据和表结构 删除速度最快。</li></ul><h3 id="如何开启和关闭-MySQL-服务？"><a href="#如何开启和关闭-MySQL-服务？" class="headerlink" title="如何开启和关闭 MySQL 服务？"></a>如何开启和关闭 MySQL 服务？</h3><p>使用 <code>systemctl stop mysqld</code> 停止 MySQL 服务，使用 <code>systemctl start mysqld</code> 启动 MySQL 服务。</p><h3 id="如何查询当前-MySQL-安装的版本号？"><a href="#如何查询当前-MySQL-安装的版本号？" class="headerlink" title="如何查询当前 MySQL 安装的版本号？"></a>如何查询当前 MySQL 安装的版本号？</h3><p>使用 <code>SELECT VERSION();</code> 可以查询当前连接的 MySQL 的版本号。</p><h3 id="如何查看某张表的存储引擎？"><a href="#如何查看某张表的存储引擎？" class="headerlink" title="如何查看某张表的存储引擎？"></a>如何查看某张表的存储引擎？</h3><p>可使用 <code>show table status from db where name=&#39;t&#39;;</code> 查询数据库 db 中表 t 的所有信息，其中 <code>Engine</code> 列表示表 t 使用的存储引擎，如下图所示：</p><p><img src="/" alt="avatar" class="lazyload" data-src="https://images.gitbook.cn/Fr4KNWuG6HnTqDYsuWDZMtFLlS9s"></p><h3 id="如何查看当前数据库增删改查的执行次数统计？"><a href="#如何查看当前数据库增删改查的执行次数统计？" class="headerlink" title="如何查看当前数据库增删改查的执行次数统计？"></a>如何查看当前数据库增删改查的执行次数统计？</h3><p>使用以下命令行查看：</p><blockquote><p>mysql&gt; show global status where variable<em>name in(‘com</em>select’,’com<em>insert’,’com</em>delete’,’com<em>update’); +—————+——-+ | Variable</em>name | Value | +—————+——-+ | Com<em>delete | 0 | | Com</em>insert | 1 | | Com<em>select | 40 | | Com</em>update | 0 | +—————+——-+</p></blockquote><h3 id="如何查询线程连接数？"><a href="#如何查询线程连接数？" class="headerlink" title="如何查询线程连接数？"></a>如何查询线程连接数？</h3><p>使用如下命令：</p><blockquote><p>mysql&gt; show global status like ‘threads_%’;</p></blockquote><p>执行效果如下图所示：</p><p><img src="/" alt="avatar" class="lazyload" data-src="https://images.gitbook.cn/FiMigudwDmMeocTm_DaHyFkohKtW"></p><p>其中：</p><ul><li>Threads_cached：代表当前此时此刻线程缓存中有多少空闲线程；</li><li>Threads_connected：代表当前已建立连接的数量，因为一个连接就需要一个线程，所以也可以看成当前被使用的线程数；</li><li>Threads_created：代表从最近一次服务启动，已创建线程的数量；</li><li>Threads_running：代表当前激活的（非睡眠状态）线程数。</li></ul><h3 id="如何查看-MySQL-的最大连接数？能不能修改？怎么修改？"><a href="#如何查看-MySQL-的最大连接数？能不能修改？怎么修改？" class="headerlink" title="如何查看 MySQL 的最大连接数？能不能修改？怎么修改？"></a>如何查看 MySQL 的最大连接数？能不能修改？怎么修改？</h3><p>查询 MySQL 最大连接数，使用如下命令：</p><blockquote><p>mysql&gt; show variables like ‘max_connections%’;</p></blockquote><p>此命令输出的结果如下：</p><p><img src="/" alt="avatar" class="lazyload" data-src="https://images.gitbook.cn/FuGSsXFvu3O5d0CLZ0xD1c9JSbKM"></p><p>可以修改 MySQL 的最大连接数，可以在 MySQL 的配置文件 my.cnf 里修改最大连接数，通过修改 max<em>connections 的值，然后重启 MySQL 就会生效，如果 my.ini 文件中没有找到 max</em>connections，可自行添加 max_connections 的设置，内容如下：</p><blockquote><p>max_connections=200</p></blockquote><h3 id="CHAR-LENGTH-和-LENGTH-有什么区别？"><a href="#CHAR-LENGTH-和-LENGTH-有什么区别？" class="headerlink" title="CHAR_LENGTH 和 LENGTH 有什么区别？"></a>CHAR_LENGTH 和 LENGTH 有什么区别？</h3><p>CHAR<em>LENGTH 是字符数，而 LENGTH 是字节数。它们在不同编码下，值是不相同的，比如对于 UTF-8 编码来说，一个中文字的 LENGTH 为 1，而 CHAR</em>LENGTH 通常等于 3，如下图所示：</p><p><img src="/" alt="avatar" class="lazyload" data-src="https://images.gitbook.cn/FqB41GGLwDVq3BrNvVqgmnW0M6__"></p><h3 id="UNION-和-UNION-ALL-的用途是什么？有什么区别？"><a href="#UNION-和-UNION-ALL-的用途是什么？有什么区别？" class="headerlink" title="UNION 和 UNION ALL 的用途是什么？有什么区别？"></a>UNION 和 UNION ALL 的用途是什么？有什么区别？</h3><p>UNION 和 UNION ALL 都是用于合并数据集的，它们的区别如下：</p><ul><li>去重：UNION 会对结果进行去重，UNION ALL 则不会进行去重操作；</li><li>排序：UNION 会对结果根据字段进行排序，而 UNION ALL 则不会进行排序；</li><li>性能：UNION ALL 的性能要高于 UNION。</li></ul><h3 id="以下关于-WHERE-和-HAVING-说法正确的是？"><a href="#以下关于-WHERE-和-HAVING-说法正确的是？" class="headerlink" title="以下关于 WHERE 和 HAVING 说法正确的是？"></a>以下关于 WHERE 和 HAVING 说法正确的是？</h3><p>A.任何情况 WHERE 和 HAVING 都可以相互替代 B.GROUP BY 前后都可以使用 WHERE C.使用 SELECT X FROM T HAVING Y&gt;20 查询报错 D.使用 SELECT X FROM T WHERE Y&gt;20 查询报错 答：C，HAVING 非报错用法是 <code>SELECT X,Y FROM T HAVING Y&gt;20</code> 。</p><h3 id="空值和-NULL-的区别是什么？"><a href="#空值和-NULL-的区别是什么？" class="headerlink" title="空值和 NULL 的区别是什么？"></a>空值和 NULL 的区别是什么？</h3><p>空值表示字段的值为空，而 NULL 则表示字段没有值，它们的区别如下：</p><ul><li>空值不占用空间，NULL 值是未知的占用空间；</li><li>空值判断使用 <code>=&#39;&#39;</code> 或 <code>&lt;&gt;&#39;&#39;</code> 来判断，NULL 值使用 <code>IS NULL</code> 或 <code>IS NOT NULL</code> 来判断；</li><li>使用 COUNT 统计某字段时，如果是 NULL 则会忽略不统计，而空值则会算入统计之内。</li></ul><p>比如，其中字段 <code>name</code> 有两个 <code>NULL</code> 值和一个空值，查询结果如图：</p><p><img src="/" alt="avatar" class="lazyload" data-src="https://images.gitbook.cn/FvWDQnw2Y1nzz56iIlFlgFkk0h3x"></p><h3 id="MySQL-的常用函数有哪些？"><a href="#MySQL-的常用函数有哪些？" class="headerlink" title="MySQL 的常用函数有哪些？"></a>MySQL 的常用函数有哪些？</h3><ul><li>sum(field) – 求某个字段的和值；</li><li>count(*) – 查询总条数；</li><li>min(field) – 某列中最小的值；</li><li>max(field) – 某列中最大的值；</li><li>avg(field) – 求平均数；</li><li>current_date() – 获取当前日期；</li><li>now() – 获取当前日期和时间；</li><li>concat(a, b) – 连接两个字符串值以创建单个字符串输出；</li><li>datediff(a, b) – 确定两个日期之间的差异，通常用于计算年龄。</li></ul><h2 id="MySQL-性能优化-amp-分布式"><a href="#MySQL-性能优化-amp-分布式" class="headerlink" title="MySQL 性能优化 &amp; 分布式"></a>MySQL 性能优化 &amp; 分布式</h2><h3 id="MySQL-性能指标都有哪些？如何得到这些指标？"><a href="#MySQL-性能指标都有哪些？如何得到这些指标？" class="headerlink" title="MySQL 性能指标都有哪些？如何得到这些指标？"></a>MySQL 性能指标都有哪些？如何得到这些指标？</h3><p>MySQL 的性能指标如下：</p><p><strong>① TPS（Transaction Per Second）</strong> 每秒事务数，即数据库每秒执行的事务数。</p><p>MySQL 本身没有直接提供 TPS 参数值，如果我们想要获得 TPS 的值，只有我们自己计算了，可以根据 MySQL 数据库提供的状态变量，来计算 TPS。</p><p>需要使用的参数：</p><ul><li>Com_commit ：表示提交次数，通过命令 <code>show global status like &#39;Com_commit&#39;;</code> 获取；</li><li>Com_rollback：表示回滚次数，通过命令 <code>show global status like &#39;Com_rollback&#39;;</code> 获取。</li></ul><p>我们定义第一次获取的 Com<em>commit 的值与 Com</em>rollback 值的和为 c_r1，时间为 t1；</p><p>第二次获取的 Com<em>commit 的值与 Com</em>rollback 值的和为 c<em>r2，时间为 t2，t1 与 t2 单位为秒。 那么 TPS = ( c</em>r2 - c_r1 ) / ( t2 - t1 ) 算出来的就是该 MySQL 实例在 t1 与 t2 生命周期之间的平均 TPS。</p><p><strong>② QPS（Query Per Second）</strong> 每秒请求次数，也就是数据库每秒执行的 SQL 数量，包含 INSERT、SELECT、UPDATE、DELETE 等。 QPS = Queries / Seconds Queries 是系统状态值—总查询次数，可以通过 <code>show status like &#39;queries&#39;;</code> 查询得出，如下所示：</p><p><img src="/" alt="avatar" class="lazyload" data-src="https://images.gitbook.cn/FsC5z6nb5Vlxxvpio6oe_9kxGafj"></p><p>Seconds 是监控的时间区间，单位为秒。 比如，采样 10 秒内的查询次数，那么先查询一次 Queries 值（Q1），等待 10 秒，再查询一次 Queries 值（Q2），那么 QPS 就可以通过，如下公式获得：</p><blockquote><p>QPS = (Q2 - Q1) / 10</p></blockquote><p><strong>③ IOPS（Input/Output Operations per Second）</strong> 每秒处理的 I/O 请求次数。</p><p>IOPS 是判断磁盘 I/O 能力的指标之一，一般来讲 IOPS 指标越高，那么单位时间内能够响应的请求自然也就越多。理论上讲，只要系统实际的请求数低于 IOPS 的能力，就相当于每一个请求都能得到即时响应，那么 I/O 就不会是瓶颈了。</p><p>注意：IOPS 与磁盘吞吐量不一样，吞吐量是指单位时间内可以成功传输的数据数量。</p><p>可以使用 iostat 命令，查看磁盘的 IOPS，命令如下：</p><blockquote><p>yum install sysstat iostat -dx 1 10</p></blockquote><p>执行效果如下图所示：</p><p><img src="/" alt="avatar" class="lazyload" data-src="https://images.gitbook.cn/FmipXHNOPi7vLBpltURiYKd_zFvw"></p><p>IOPS = r/s + w/s 其中：</p><ul><li>r/s：代表每秒读了多少次；</li><li>w/s：代表每秒写了多少次。</li></ul><h3 id="什么是慢查询？"><a href="#什么是慢查询？" class="headerlink" title="什么是慢查询？"></a>什么是慢查询？</h3><p>慢查询是 MySQL 中提供的一种慢查询日志，它用来记录在 MySQL 中响应时间超过阀值的语句，具体指运行时间超过 long<em>query</em>time 值的 SQL，则会被记录到慢查询日志中。long<em>query</em>time 的默认值为 10，意思是运行 10S 以上的语句。默认情况下，MySQL 数据库并不启动慢查询日志，需要我们手动来设置这个参数，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会给 MySQL 服务器带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p><p>使用 <code>mysql&gt; show variables like &#39;%slow_query_log%&#39;;</code> 来查询慢查询日志是否开启，执行效果如下图所示：</p><p><img src="/" alt="avatar" class="lazyload" data-src="https://images.gitbook.cn/FiUIFozIotyBys7CXuciEFbyMT5-"></p><p>slow<em>query</em>log 的值为 OFF 时，表示未开启慢查询日志。</p><h3 id="如何开启慢查询日志？"><a href="#如何开启慢查询日志？" class="headerlink" title="如何开启慢查询日志？"></a>如何开启慢查询日志？</h3><p>开启慢查询日志，可以使用如下 MySQL 命令：</p><blockquote><p>mysql&gt; set global slow<em>query</em>log=1</p></blockquote><p>不过这种设置方式，只对当前数据库生效，如果 MySQL 重启也会失效，如果要永久生效，就必须修改 MySQL 的配置文件 my.cnf，配置如下：</p><blockquote><p>slow<em>query</em>log =1 slow<em>query</em>log<em>file=/tmp/mysql</em>slow.log</p></blockquote><h3 id="如何定位慢查询？"><a href="#如何定位慢查询？" class="headerlink" title="如何定位慢查询？"></a>如何定位慢查询？</h3><p>使用 MySQL 中的 explain 分析执行语句，比如：</p><blockquote><p>explain select * from t where id=5;</p></blockquote><p>如下图所示：</p><p><img src="/" alt="avatar" class="lazyload" data-src="https://images.gitbook.cn/FoypIBEEnO385Ajzf20thyc4r9sT"></p><p>其中：</p><ul><li>id — 选择标识符。id越大优先级越高，越先被执行。</li><li>select_type — 表示查询的类型。</li><li>table — 输出结果集的表</li><li>partitions — 匹配的分区</li><li>type — 表示表的连接类型</li><li>possible_keys — 表示查询时，可能使用的索引</li><li>key — 表示实际使用的索引</li><li>key_len — 索引字段的长度</li><li>ref— 列与索引的比较</li><li>rows — 大概估算的行数</li><li>filtered — 按表条件过滤的行百分比</li><li>Extra — 执行情况的描述和说明</li></ul><p>其中最重要的就是 type 字段，type 值类型如下：</p><ul><li>all — 扫描全表数据</li><li>index — 遍历索引</li><li>range — 索引范围查找</li><li>index_subquery — 在子查询中使用 ref</li><li>unique<em>subquery — 在子查询中使用 eq</em>ref</li><li>ref<em>or</em>null — 对 null 进行索引的优化的 ref</li><li>fulltext — 使用全文索引</li><li>ref — 使用非唯一索引查找数据</li><li>eq_ref — 在 join 查询中使用主键或唯一索引关联</li><li>const — 将一个主键放置到 where 后面作为条件查询， MySQL 优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器，这个比 eq_ref 效率高一点</li></ul><h3 id="MySQL-的优化手段都有哪些？"><a href="#MySQL-的优化手段都有哪些？" class="headerlink" title="MySQL 的优化手段都有哪些？"></a>MySQL 的优化手段都有哪些？</h3><p>MySQL 的常见的优化手段有以下五种：</p><h4 id="①-查询优化"><a href="#①-查询优化" class="headerlink" title="① 查询优化"></a>① 查询优化</h4><ul><li>避免 SELECT *，只查询需要的字段。</li><li>小表驱动大表，即小的数据集驱动大的数据集，比如，当 B 表的数据集小于 A 表时，用 in 优化 exist，两表执行顺序是先查 B 表，再查 A 表，查询语句：select * from A where id in (select id from B) 。</li><li>一些情况下，可以使用连接代替子查询，因为使用 join 时，MySQL 不会在内存中创建临时表。</li></ul><h4 id="②-优化索引的使用"><a href="#②-优化索引的使用" class="headerlink" title="② 优化索引的使用"></a>② 优化索引的使用</h4><ul><li>尽量使用主键查询，而非其他索引，因为主键查询不会触发回表查询。</li><li>不做列运算，把计算都放入各个业务系统实现</li><li>查询语句尽可能简单，大语句拆小语句，减少锁时间</li><li>不使用 select * 查询</li><li>or 查询改写成 in 查询</li><li>不用函数和触发器</li><li>避免 %xx 查询</li><li>少用 join 查询</li><li>使用同类型比较，比如 ‘123’ 和 ‘123’、123 和 123</li><li>尽量避免在 where 子句中使用 != 或者 &lt;&gt; 操作符，查询引用会放弃索引而进行全表扫描</li><li>列表数据使用分页查询，每页数据量不要太大</li><li>用 exists 替代 in 查询</li><li>避免在索引列上使用 is null 和 is not null</li><li>尽量使用主键查询</li><li>避免在 where 子句中对字段进行表达式操作</li><li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</li></ul><h4 id="③-表结构设计优化"><a href="#③-表结构设计优化" class="headerlink" title="③ 表结构设计优化"></a>③ 表结构设计优化</h4><ul><li>使用可以存下数据最小的数据类型。</li><li>使用简单的数据类型，int 要比 varchar 类型在 MySQL 处理简单。</li><li>尽量使用 tinyint、smallint、mediumint 作为整数类型而非 int。</li><li>尽可能使用 not null 定义字段，因为 null 占用 4 字节空间。</li><li>尽量少用 text 类型，非用不可时最好考虑分表。</li><li>尽量使用 timestamp，而非 datetime。</li><li>单表不要有太多字段，建议在 20 个字段以内。</li></ul><h4 id="④-表拆分"><a href="#④-表拆分" class="headerlink" title="④ 表拆分"></a>④ 表拆分</h4><p>当数据库中的数据非常大时，查询优化方案也不能解决查询速度慢的问题时，我们可以考虑拆分表，让每张表的数据量变小，从而提高查询效率。 <strong>a）垂直拆分</strong>：是指数据表列的拆分，把一张列比较多的表拆分为多张表，比如，用户表中一些字段经常被访问，将这些字段放在一张表中，另外一些不常用的字段放在另一张表中，插入数据时，使用事务确保两张表的数据一致性。 垂直拆分的原则：</p><ul><li>把不常用的字段单独放在一张表；</li><li>把 text，blob 等大字段拆分出来放在附表中；</li><li>经常组合查询的列放在一张表中。</li></ul><p><strong>b）水平拆分</strong>：指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。</p><p>通常情况下，我们使用取模的方式来进行表的拆分，比如，一张有 400W 的用户表 users，为提高其查询效率我们把其分成 4 张表 users1，users2，users3，users4，然后通过用户 ID 取模的方法，同时查询、更新、删除也是通过取模的方法来操作。</p><h4 id="⑤-读写分离"><a href="#⑤-读写分离" class="headerlink" title="⑤ 读写分离"></a>⑤ 读写分离</h4><p>一般情况下对数据库而言都是“读多写少”，换言之，数据库的压力多数是因为大量的读取数据的操作造成的，我们可以采用数据库集群的方案，使用一个库作为主库，负责写入数据；其他库为从库，负责读取数据。这样可以缓解对数据库的访问压力。</p><h3 id="MySQL-常见读写分离方案有哪些？"><a href="#MySQL-常见读写分离方案有哪些？" class="headerlink" title="MySQL 常见读写分离方案有哪些？"></a>MySQL 常见读写分离方案有哪些？</h3><p>MySQL 常见的读写分离方案，如下列表：</p><p><strong>1）应用层解决方案</strong> 可以通过应用层对数据源做路由来实现读写分离，比如，使用 SpringMVC + MyBatis，可以将 SQL 路由交给 Spring，通过 AOP 或者 Annotation 由代码显示的控制数据源。 优点：路由策略的扩展性和可控性较强。 缺点：需要在 Spring 中添加耦合控制代码。</p><p><strong>2）中间件解决方案</strong> 通过 MySQL 的中间件做主从集群，比如：Mysql Proxy、Amoeba、Atlas 等中间件都能符合需求。 优点：与应用层解耦。 缺点：增加一个服务维护的风险点，性能及稳定性待测试，需要支持代码强制主从和事务。</p><h3 id="介绍一下-Sharding-JDBC-的功能和执行流程？"><a href="#介绍一下-Sharding-JDBC-的功能和执行流程？" class="headerlink" title="介绍一下 Sharding-JDBC 的功能和执行流程？"></a>介绍一下 Sharding-JDBC 的功能和执行流程？</h3><p>Sharding-JDBC 在客户端对数据库进行水平分区的常用解决方案，也就是保持表结构不变，根据策略存储数据分片，这样每一片数据被分散到不同的表或者库中，Sharding-JDBC 提供以下功能：</p><ul><li>分库分表</li><li>读写分离</li><li>分布式主键生成</li></ul><p>Sharding-JDBC 的执行流程：当业务代码调用数据库执行的时候，先触发 Sharding-JDBC 的分配规则对 SQL 语句进行解析、改写之后，才会对改写的 SQL 进行执行和结果归并，然后返回给调用层。</p><h3 id="什么是-MySQL-多实例？如何配置-MySQL-多实例？"><a href="#什么是-MySQL-多实例？如何配置-MySQL-多实例？" class="headerlink" title="什么是 MySQL 多实例？如何配置 MySQL 多实例？"></a>什么是 MySQL 多实例？如何配置 MySQL 多实例？</h3><p>MySQL 多实例就是在同一台服务器上启用多个 MySQL 服务，它们监听不同的端口，运行多个服务进程，它们相互独立，互不影响的对外提供服务，便于节约服务器资源与后期架构扩展。 多实例的配置方法有两种：</p><ul><li>一个实例一个配置文件，不同端口；</li><li>同一配置文件(my.cnf)下配置不同实例，基于 MySQL 的 d_multi 工具。</li></ul><h3 id="怎样保证确保备库无延迟？"><a href="#怎样保证确保备库无延迟？" class="headerlink" title="怎样保证确保备库无延迟？"></a>怎样保证确保备库无延迟？</h3><p>通常保证主备无延迟有以下三种方法：</p><ul><li>每次从库执行查询请求前，先判断 seconds<em>behind</em>master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求，seconds<em>behind</em>master 参数是用来衡量主备延迟时间的长短；</li><li>对比位点确保主备无延迟。Master<em>Log</em>File 和 Read<em>Master</em>Log<em>Pos，表示的是读到的主库的最新位点，Relay</em>Master<em>Log</em>File 和 Exec<em>Master</em>Log_Pos，表示的是备库执行的最新位点；</li><li>对比 GTID 集合确保主备无延迟。Auto<em>Position=1 ，表示这对主备关系使用了 GTID 协议；Retrieved</em>Gtid<em>Set，是备库收到的所有日志的 GTID 集合；Executed</em>Gtid_Set，是备库所有已经执行完成的 GTID 集合。</li></ul><h2 id="MySQL-常见的开放性问题"><a href="#MySQL-常见的开放性问题" class="headerlink" title="MySQL 常见的开放性问题"></a>MySQL 常见的开放性问题</h2><h3 id="有一个超级大表，如何优化分页查询？"><a href="#有一个超级大表，如何优化分页查询？" class="headerlink" title="有一个超级大表，如何优化分页查询？"></a>有一个超级大表，如何优化分页查询？</h3><p>超级大表的分页优化分有以下两种方式：</p><ul><li>数据库层面优化：利用子查询优化超多分页场景，比如：<code>SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</code> ，先快速定位需要获取的 id 段，然后再关联查询。MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写，利用子查询先快速定位需要获取的 id 段，然后再关联查询，就是对分页进行 SQL 改写的具体实现；</li><li>程序层面优化：可以利用缓存把查询的结果缓存起来，这样再下一次查询的时候性能就非常高了。</li></ul><h3 id="线上修改表结构有哪些风险？"><a href="#线上修改表结构有哪些风险？" class="headerlink" title="线上修改表结构有哪些风险？"></a>线上修改表结构有哪些风险？</h3><p>线上修改表结构有可能 MySQL 服务器阻塞，因为在执行 DML（select、update、delete、insert）操作时，会给表增加一个元数据锁，这个元数据锁是为了保证在查询期间表结构不会被修改，而执行修改表结构时，必须要等待元数据锁完成之后才能执行，这就可能造成数据库服务器的阻塞。</p><p>在 MySQL 5.6 开始提供了 online ddl 功能，允许一些 DDL（create table/view/index/syn/cluster）语句和 DML 语句并发，在 5.7 版本对 online ddl 又有了增强，这使得大部分 DDL 操作可以在线进行，详见：<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-create-index-overview.html%EF%BC%8C%E8%BF%99%E4%BD%BF%E5%BE%97%E5%9C%A8%E7%BA%BF%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9A%84%E9%A3%8E%E9%99%A9%E5%8F%98%E7%9A%84%E6%9B%B4%E5%A4%A7%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%9C%A8%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%BF%85%E9%A1%BB%E5%9C%A8%E7%BA%BF%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E4%BB%A5%E4%B8%8B%E6%96%B9%E6%A1%88%EF%BC%9A">https://dev.mysql.com/doc/refman/5.7/en/innodb-create-index-overview.html，这使得在线上修改表结构的风险变的更大，如果在业务开发过程中必须在线修改表结构，可以参考以下方案：</a></p><ul><li>尽量在业务量小的时间段进行；</li><li>查看官方文档，确认要做的表修改可以和 DML 并发，不会阻塞线上业务；</li><li>推荐使用 percona 公司的 pt-online-schema-change 工具，该工具被官方的 online ddl 更为强大，它的基本原理是：通过 insert…select… 语句进行一次全量拷贝，通过触发器记录表结构变更过程中产生的增量，从而达到表结构变更的目的。比如，要对 A 表进行变更，它的主要流程为：</li></ul><p>1）创建目的表结构的空表 A_new；</p><p>2）在A表上创建触发器，包括增、删、改触发器；</p><p>3）通过 insert…select…limit N 语句分片拷贝数据到目的表；</p><p>4）Copy完成后，将 A_new 表 rename 到 A 表。</p><h3 id="查询长时间不返回可能是什么原因？应该如何处理？"><a href="#查询长时间不返回可能是什么原因？应该如何处理？" class="headerlink" title="查询长时间不返回可能是什么原因？应该如何处理？"></a>查询长时间不返回可能是什么原因？应该如何处理？</h3><p>查询速度慢的原因很多，常见如下几种： 1）查询字段没有索引或者没有触发索引查询，没有触发索引查询的情况如下： 不会使用索引的情况如下：</p><ul><li>以 % 开头的 like 查询不会使用 b-tree 索引；</li><li>数据类型出现隐式转换时不会使用索引，比如，某列是 varchar 类型，却使用了column<em>name=1 的查询语句，这是不会使用索引，正确触发索引的查询语句为：column</em>name=’1’ ；</li><li>不符合最左前缀原则；</li><li>如果查询条件有 or 分割，or 前面的使用索引，or 后面的未使用索引，则不会使用索引，因为即使 or 之前的使用了索引，但是 or 之后的也需要全表查询，索引就忽略索引，直接全表查询；</li><li>如果 MySQL 认为使用索引会比全表查询更慢，则不会使用索引。</li></ul><p>2）I/O 压力大，读取磁盘速度变慢。 3）内存不足 4）网络速度慢 5）查询出的数据量过大，可以采用多次查询或其他的方法降低数据量 6）死锁，一般碰到这种情况的话，大概率是表被锁住了，可以使用 <code>show processlist;</code> 命令，看看 SQL 语句的状态，再针对不同的状态做相应的处理。</p><p><img src="/" alt="avatar" class="lazyload" data-src="https://images.gitbook.cn/Fi_vowvU742l_3FU1gjmBCnhYLZD"></p><p>其中，当 State 列值为 Locked 时，表示被锁定。 其它关于查看死锁的命令： a）查看当前的事务：</p><blockquote><p>select * from information<em>schema.innodb</em>trx;</p></blockquote><p>b）查看当前锁定的事务：</p><blockquote><p>select * from information<em>schema.innodb</em>locks;</p></blockquote><p>c）查看当前等锁的事务</p><blockquote><p>select * from information<em>schema.innodb</em>lock_waits;</p></blockquote><p>以上问题的解决方案如下：</p><p>1）正确创建和使用索引。 2）把数据、日志、索引放到不同的 IO 设备上，减少主数据库的 IO 操作。更换 MySQL 的磁盘为固态硬盘，以提高磁盘的 IO 性能。 3）升级内存，更换更大的内存。 4）提升网速，升级带宽。 5）用 Profiler 来跟踪查询，得到查询所需的时间，找出有问题的 SQL 语句，优化 SQL。 6）查询时值返回需要的字段。 7）设置死锁的超时时间，限制和避免死锁消耗过多服务器的资源。 8）尽量少用视图，它的效率低，对视图操作比直接对表操作慢,可以用存储过程来代替视图。不要用视图嵌套，嵌套视图增加了寻找原始数据的难度。</p><h3 id="MySQL-主从延迟的原因有哪些？"><a href="#MySQL-主从延迟的原因有哪些？" class="headerlink" title="MySQL 主从延迟的原因有哪些？"></a>MySQL 主从延迟的原因有哪些？</h3><p>主从延迟可以根据 MySQL 提供的命令判断，比如，在从服务器使用命令： <code>show slave status;</code>，其中 Seconds<em>Behind</em>Master 如果为 0 表示主从复制状态正常。 导致主从延迟的原因有以下几个：</p><ul><li>主库有大事务处理；</li><li>主库做大量的增、删、改操作；</li><li>主库对大表进行字段新增、修改或添加索引等操作；</li><li>主库的从库太多，导致复制延迟。从库数量一般 3-5 个为宜，要复制的节点过多，导致复制延迟；</li><li>从库硬件配置比主库差，导致延迟。查看 Master 和 Slave 的配置，可能因为从库的配置过低，执行时间长，由此导致的复制延迟时间长；</li><li>主库读写压力大，导致复制延迟；</li><li>从库之间的网络延迟。主从库网卡、网线、连接的交换机等网络设备都可能成为复制的瓶颈，导致复制延迟，另外跨公网主从复制很容易导致主从复制延迟。</li></ul><h3 id="如何保证数据不被误删？"><a href="#如何保证数据不被误删？" class="headerlink" title="如何保证数据不被误删？"></a>如何保证数据不被误删？</h3><p>保证数据不被误删的方法如下列表：</p><ul><li>权限控制与分配（数据库和服务器权限）</li><li>避免数据库账号信息泄露，在生产环境中，业务代码不要使用明文保存数据库连接信息；</li><li>重要的数据库操作，通过平台型工具自动实施，减少人工操作；</li><li>部署延迟复制从库，万一误删除时用于数据回档，且从库设置为 read-only；</li><li>确认备份制度及时有效；</li><li>启用 SQL 审计功能，养成良好 SQL 习惯；</li><li>启用 sql<em>safe</em>updates 选项，不允许没 where 条件的更新/删除；</li><li>将系统层的 rm 改为 mv；</li><li>线上不进行物理删除，改为逻辑删除（将 row data 标记为不可用）；</li><li>启用堡垒机，屏蔽高危 SQL；</li><li>降低数据库中普通账号的权限级别；</li><li>开启 binlog，方便追溯数据。</li></ul><h3 id="MySQL-服务器-CPU-飙升应该如何处理？"><a href="#MySQL-服务器-CPU-飙升应该如何处理？" class="headerlink" title="MySQL 服务器 CPU 飙升应该如何处理？"></a>MySQL 服务器 CPU 飙升应该如何处理？</h3><p>使用 <code>show full processlist;</code> 查出慢查询，为了缓解数据库服务器压力，先使用 kill 命令杀掉慢查询的客户端，效果如下：</p><p><img src="/" alt="avatar" class="lazyload" data-src="https://images.gitbook.cn/Fv6SAcc3e6TTvbMaSfe7OgGc_0Md"></p><p>然后再去项目中找到执行慢的 SQL 语句进行修改和优化。</p><h3 id="MySQL-毫无规律的异常重启，可能产生的原因是什么？该如何解决？"><a href="#MySQL-毫无规律的异常重启，可能产生的原因是什么？该如何解决？" class="headerlink" title="MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？"></a>MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？</h3><p>可能是积累的长连接导致内存占用太多，被系统强行杀掉导致的异常重启，因为在 MySQL 中长连接在执行过程中使用的临时内存对象，只有在连接断开的时候才会释放，这就会导致内存不断飙升，解决方案如下：</p><ul><li>定期断开空闲的长连接；</li><li>如果是用的是 MySQL 5.7 以上的版本，可以定期执行 mysql<em>reset</em>connection 重新初始化连接资源，这个过程会释放之前使用的内存资源，恢复到连接刚初始化的状态。</li></ul><h3 id="如何实现一个高并发的系统？"><a href="#如何实现一个高并发的系统？" class="headerlink" title="如何实现一个高并发的系统？"></a>如何实现一个高并发的系统？</h3><p>这道面试题涉及的知识点比较多，主要考察的是面试者的综合技术能力。高并发系统的设计手段有很多，主要体现在以下五个方面。</p><h4 id="1）前端优化"><a href="#1）前端优化" class="headerlink" title="1）前端优化"></a>1）前端优化</h4><p>① 静态资源缓存：将活动页面上的所有可以静态的元素全部静态化，尽量减少动态元素；通过 CDN、浏览器缓存，来减少客户端向服务器端的数据请求。 ② 禁止重复提交：用户提交之后按钮置灰，禁止重复提交。 ③ 用户限流：在某一时间段内只允许用户提交一次请求，比如，采取 IP 限流。</p><h4 id="2）中间层负载分发"><a href="#2）中间层负载分发" class="headerlink" title="2）中间层负载分发"></a>2）中间层负载分发</h4><p>可利用负载均衡，比如 nginx 等工具，可以将并发请求分配到不同的服务器，从而提高了系统处理并发的能力。 nginx 负载分发的五种方式：</p><p>① 轮询（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器不能正常响应，nginx 能自动剔除故障服务器。 ② 按权重（weight） 使用 weight 参数，指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况，配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">upstream backend &#123; </span><br><span class="line">    server 192.168.0.14 weight=10; </span><br><span class="line">    server 192.168.0.15 weight=10; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ IP 哈希值（ip_hash） 每个请求按访问 IP 的哈希值分配，这样每个访客固定访问一个后端服务器，可以解决 session 共享的问题，配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">upstream backend &#123; </span><br><span class="line">    ip_hash; </span><br><span class="line">    server 192.168.0.14:88; </span><br><span class="line">    server 192.168.0.15:80; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④ 响应时间（fair） 按后端服务器的响应时间来分配请求，响应时间短的优先分配，配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">upstream backend &#123; </span><br><span class="line">    fair; </span><br><span class="line">    server server1.com; </span><br><span class="line">    server server2.com; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⑤ URL 哈希值（url_hash） 按访问 url 的 hash 结果来分配请求，和 IP 哈希值类似。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    hash $request_uri;</span><br><span class="line">    server server1.com; </span><br><span class="line">    server server2.com;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）控制层（网关层）"><a href="#3）控制层（网关层）" class="headerlink" title="3）控制层（网关层）"></a>3）控制层（网关层）</h4><p>限制同一个用户的访问频率，限制访问次数，防止多次恶意请求。</p><h4 id="4）服务层"><a href="#4）服务层" class="headerlink" title="4）服务层"></a>4）服务层</h4><p>① 业务服务器分离：比如，将秒杀业务系统和其他业务分离，单独放在高配服务器上，可以集中资源对访问请求抗压。 ② 采用 MQ（消息队列）缓存请求：MQ 具有削峰填谷的作用，可以把客户端的请求先导流到 MQ，程序在从 MQ 中进行消费（执行请求），这样可以避免短时间内大量请求，导致服务器程序无法响应的问题。 ③ 利用缓存应对读请求，比如，使用 Redis 等缓存，利用 Redis 可以分担数据库很大一部分压力。</p><h4 id="5）数据库层"><a href="#5）数据库层" class="headerlink" title="5）数据库层"></a>5）数据库层</h4><p>① 合理使用数据库引擎 ② 合理设置事务隔离级别，合理使用事务 ③ 正确使用 SQL 语句和查询索引 ④ 合理分库分表 ⑤ 使用数据库中间件实现数据库读写分离 ⑥ 设置数据库主从读写分离</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Mysql </tag>
            
            <tag> 知识点总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github搭建个人博客详细教程</title>
      <link href="/2020/03/26/Hexo%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90butterfly%E4%B8%BB%E9%A2%98/"/>
      <url>/2020/03/26/Hexo%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90butterfly%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">            <p>本文教程基于Windows系统搭建，采用Butterfly主题。hexo官方和主题作者提供了详细的安装教程，本文主要是对搭建过程进行梳理以及第三方插件集成。</p><p><a href="https://hexo.io/zh-cn/docs/">Hexo官方安装参考文档</a></p><p><a href="%5Bhttps://jerryc.me/posts/21cfbf15/#%E5%BF%AB%E9%80%9F%E9%96%8B%E5%A7%8B%5D(https://jerryc.me/posts/21cfbf15/#%E5%BF%AB%E9%80%9F%E9%96%8B%E5%A7%8B)">Butterfly主题官方参考文档</a></p>          </div><h1 id="基础环境搭建"><a href="#基础环境搭建" class="headerlink" title="基础环境搭建"></a>基础环境搭建</h1><h2 id="安装运行环境"><a href="#安装运行环境" class="headerlink" title="安装运行环境"></a>安装运行环境</h2><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p><a href="https://www.runoob.com/git/git-install-setup.html">Git安装教程</a></p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">Node.js安装教程</a></p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>在安装完Node.js和Git之后，使用以下命令全局安装Hexo</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli     </span><br></pre></td></tr></table></figure><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init Blog         #初始化创建一个新博客 Blog为博客名字（根据个人爱好自行决定）</span><br><span class="line">cd Blog               #进入博客所在文件夹</span><br><span class="line">npm install           #安装所需插件</span><br></pre></td></tr></table></figure><p>资源生成</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo generate       #生成博客页面 </span><br></pre></td></tr></table></figure><p>本地服务启动，展示页面效果</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo server        #本地服务启动，直接再浏览器输入localhost:4000即可看到如下效果</span><br></pre></td></tr></table></figure><h1 id="个性化主题和配置"><a href="#个性化主题和配置" class="headerlink" title="个性化主题和配置"></a>个性化主题和配置</h1><p>Hexo有丰富的主题进行选择，我选用的是<span style = 'color:#F76809'>Butterfly</span>，可根据个人爱好进行选择。</p><h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><h3 id="安装Butterfly主题文件"><a href="#安装Butterfly主题文件" class="headerlink" title="安装Butterfly主题文件"></a>安装Butterfly主题文件</h3><p>进入博客根目录，执行以下命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br></pre></td></tr></table></figure><h3 id="安装渲染器"><a href="#安装渲染器" class="headerlink" title="安装渲染器"></a>安装渲染器</h3><p><span style = 'color:#F76809'>Butterfly主题需要安装，其它主题则不需要</span></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><h3 id="平滑升级"><a href="#平滑升级" class="headerlink" title="平滑升级"></a>平滑升级</h3><p>为了主题的平滑升级，<span style = 'color:#F76809'>Butterfly</span>使用了<a href="https://hexo.io/docs/data-files.html">data files</a>特性。</p><p>推荐把主题默认的配置文件<span style = 'color:#F76809'>config.yml</span>复制到Hexo工作目录下的<span style = 'color:#F76809'>source/data/butterfly.yml</span>，如果<span style = 'color:#F76809'>source/_data</span>的目录不存在那就创建一个。</p><h3 id="使用Butterfly主题"><a href="#使用Butterfly主题" class="headerlink" title="使用Butterfly主题"></a>使用Butterfly主题</h3><p>修改站点配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p><span style = 'color:#F76809'>Butterfly</span>作者提供了详细的安装和配置文档，详见<a href="%5Bhttps://jerryc.me/posts/21cfbf15/#%E5%BF%AB%E9%80%9F%E9%96%8B%E5%A7%8B%5D(https://jerryc.me/posts/21cfbf15/#%E5%BF%AB%E9%80%9F%E9%96%8B%E5%A7%8B)">作者文档</a>。</p><h2 id="第三方插件"><a href="#第三方插件" class="headerlink" title="第三方插件"></a>第三方插件</h2><h3 id="本地搜索功能"><a href="#本地搜索功能" class="headerlink" title="本地搜索功能"></a>本地搜索功能</h3><p>请点击<a href="https://www.gz1903.club/2019/10/19/Hexo-Algoliasearch/">使用方法</a></p><h3 id="音乐播放器"><a href="#音乐播放器" class="headerlink" title="音乐播放器"></a>音乐播放器</h3><p>请点击<a href="https://www.gz1903.club/2019/10/19/Hexo-Aplayer%E6%92%AD%E6%94%BE%E5%99%A8/">使用方法</a></p><h3 id="豆瓣"><a href="#豆瓣" class="headerlink" title="豆瓣"></a>豆瓣</h3><p>请点击<a href="https://www.gz1903.club/2019/10/19/Hexo-Douban/">使用方法</a></p><h3 id="邮箱订阅"><a href="#邮箱订阅" class="headerlink" title="邮箱订阅"></a>邮箱订阅</h3><p>请点击<a href="https://www.gz1903.club/2019/10/19/Hexo%E6%B7%BB%E5%8A%A0RSS%E8%AE%A2%E9%98%85/">使用方法</a></p><h3 id="评论系统-Valine"><a href="#评论系统-Valine" class="headerlink" title="评论系统(Valine)"></a>评论系统(Valine)</h3><p>请点击<a href="https://www.gz1903.club/2019/10/18/Valine-Admin/">使用方法</a></p><h3 id="Live2d看板动画"><a href="#Live2d看板动画" class="headerlink" title="Live2d看板动画"></a>Live2d看板动画</h3><p>请点击<a href="https://www.gz1903.club/2019/10/15/Hexo%E6%B7%BB%E5%8A%A0Live2d%E7%9C%8B%E6%9D%BF%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/">使用方法</a></p><h1 id="集成Github"><a href="#集成Github" class="headerlink" title="集成Github"></a>集成Github</h1><h3 id="新建github仓库"><a href="#新建github仓库" class="headerlink" title="新建github仓库"></a>新建github仓库</h3><p>新建仓库，仓库名字必须是.github.io结尾，如test.github.io</p><h3 id="同步资源到Github"><a href="#同步资源到Github" class="headerlink" title="同步资源到Github"></a>同步资源到Github</h3><h4 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git"></a>安装 hexo-deployer-git</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h4 id="站点配置文件配置github仓库"><a href="#站点配置文件配置github仓库" class="headerlink" title="站点配置文件配置github仓库"></a>站点配置文件配置github仓库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: 博客github仓库地址  #将此地址改为自己的即可</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>repo</td><td>库（Repository）地址</td></tr><tr><td>branch</td><td>分支名称。如果不指定，则默认值为 master</td></tr><tr><td>message</td><td>自定义提交信息</td></tr></tbody></table><p>Hexo 提供了快速方便的一键部署功能，只需一条命令就能将网站部署到服务器上。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><h3 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h3><ul><li>在source文件夹下创建CNAME文件，将个人域名填入即可</li><li>在github仓库setting中下拉Github Page中进行配置</li><li>在于域名管理中添加两条记录，分别为类型为A和CNAME</li></ul><table><thead><tr><th>类型</th><th>对应值</th></tr></thead><tbody><tr><td>A</td><td>博客ip（打开windows系统cmd，ping博客域名即可得到）</td></tr><tr><td>CNAME</td><td>github二级域名</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常见知识点总结</title>
      <link href="/2020/03/25/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/25/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Java-程序是如何执行的"><a href="#Java-程序是如何执行的" class="headerlink" title="Java 程序是如何执行的"></a>Java 程序是如何执行的</h2><h3 id="Java-和-JDK-的关系"><a href="#Java-和-JDK-的关系" class="headerlink" title="Java 和 JDK 的关系"></a>Java 和 JDK 的关系</h3><p>JDK（Java Development Kit）Java 开发工具包，它包括：编译器、Java 运行环境（JRE，Java Runtime Environment）、JVM（Java 虚拟机）监控和诊断工具等，而 Java 则表示一种开发语言。</p><h3 id="Java-程序是怎么执行的？"><a href="#Java-程序是怎么执行的？" class="headerlink" title="Java 程序是怎么执行的？"></a>Java 程序是怎么执行的？</h3><p>我们日常的工作中都使用开发工具（IntelliJ IDEA 或 Eclipse 等）可以很方便的调试程序，或者是通过打包工具把项目打包成 jar 包或者 war 包，放入 Tomcat 等 Web 容器中就可以正常运行了，但你有没有想过 Java 程序内部是如何执行的？</p><p>其实不论是在开发工具中运行还是在 Tomcat 中运行，Java 程序的执行流程基本都是相同的，它的执行流程如下：</p><ol><li>先把 Java 代码编译成字节码，也就是把 .java 类型的文件编译成 .class 类型的文件。这个过程的大致执行流程：Java 源代码 -&gt; 词法分析器 -&gt; 语法分析器 -&gt; 语义分析器 -&gt; 字节码生成器 -&gt; 最终生成字节码，其中任何一个节点执行失败就会造成编译失败；</li><li>把 class 文件放置到 Java 虚拟机，这个虚拟机通常指的是 Oracle 官方自带的 Hotspot JVM；</li><li>Java 虚拟机使用类加载器（Class Loader）装载 class 文件；</li><li>类加载完成之后，会进行字节码校验，字节码校验通过之后 JVM 解释器会把字节码翻译成机器码交由操作系统执行。但不是所有代码都是解释执行的，JVM 对此做了优化，比如，以 Hotspot 虚拟机来说，它本身提供了 JIT（Just In Time）也就是我们通常所说的动态编译器，它能够在运行时将热点代码编译为机器码，这个时候字节码就变成了编译执行。</li></ol><p>Java 程序执行流程图如下：</p><p><img src="/" alt="avatar" class="lazyload" data-src="https://images.gitbook.cn/FvSP3G2xXR676FoIvsz-0naYLP2I"></p><h3 id="Java-虚拟机是如何判定热点代码的？"><a href="#Java-虚拟机是如何判定热点代码的？" class="headerlink" title="Java 虚拟机是如何判定热点代码的？"></a>Java 虚拟机是如何判定热点代码的？</h3><p>Java 虚拟机判定热点代码的方式有两种：</p><ul><li>基于采样的热点判定</li></ul><p>主要是虚拟机会周期性的检查各个线程的栈顶，若某个或某些方法经常出现在栈顶，那这个方法就是“热点方法”。这种判定方式的优点是实现简单；缺点是很难精确一个方法的热度，容易受到线程阻塞或外界因素的影响。</p><ul><li>基于计数器的热点判定</li></ul><p>主要就是虚拟机给每一个方法甚至代码块建立了一个计数器，统计方法的执行次数，超过一定的阀值则标记为此方法为热点方法。</p><p>Hotspot 虚拟机使用的基于计数器的热点探测方法。它使用了两类计数器：方法调用计数器和回边计数器，当到达一定的阀值是就会触发 JIT 编译。</p><p>方法调用计数器：在 client 模式下的阀值是 1500 次，Server 是 10000 次，可以通过虚拟机参数： <code>-XX:CompileThreshold=N</code> 对其进行设置。但是JVM还存在热度衰减，时间段内调用方法的次数较少，计数器就减小。</p><p>回边计数器：主要统计的是方法中循环体代码执行的次数。</p><p>由上面的知识我们可以看出，<strong>要想做到对 Java 了如指掌，必须要好好学习 Java 虚拟机</strong>，那除了 Java 虚拟机外，还有哪些知识是面试必考，也是 Java 工程师必须掌握的知识呢？</p><h3 id="Java-基础中的核心内容"><a href="#Java-基础中的核心内容" class="headerlink" title="Java 基础中的核心内容"></a>Java 基础中的核心内容</h3><p>字符串和字符串常量池的深入理解、Array 的操作和排序算法、深克隆和浅克隆、各种 IO 操作、反射和动态代理（JDK 自身动态代理和 CGLIB）等。</p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合和 String 是编程中最常用的数据类型，关于集合的知识也是面试备考的内容，它包含：链表（LinkedList）、TreeSet、栈（Stack）、队列（双端、阻塞、非阻塞队列、延迟队列）、HashMap、TreeMap 等，它们的使用和底层存储数据结构都是热门的面试内容。</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>多线程使用和线程安全的知识也是必考的面试题目，它包括：死锁、6 种线程池的使用与差异、ThreadLocal、synchronized、Lock、JUC（java.util.concurrent包）、CAS（Compare and Swap）、ABA 问题等。</p><h4 id="热门框架"><a href="#热门框架" class="headerlink" title="热门框架"></a>热门框架</h4><p>Spring、Spring MVC、MyBatis、SpringBoot</p><h4 id="分布式编程"><a href="#分布式编程" class="headerlink" title="分布式编程"></a>分布式编程</h4><p>消息队列（RabbitMQ、Kafka）、Dubbo、Zookeeper、SpringCloud 等。</p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>MySQL 常用引擎的掌握、MySQL 前缀索引、回表查询、数据存储结构、最左匹配原则、MySQL 的问题分析和排除方案、MySQL 读写分离的实现原理以及 MySQL 的常见优化方案等。 Redis 的使用场景、缓存雪崩和缓存穿透的解决方案、Redis 过期淘汰策略和主从复制的实现方案等。</p><h4 id="Java-虚拟机"><a href="#Java-虚拟机" class="headerlink" title="Java 虚拟机"></a>Java 虚拟机</h4><p>虚拟机的组成、垃圾回收算法、各种垃圾回收器的区别、Java 虚拟机分析工具的掌握、垃圾回收器的常用调优参数等。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>常用算法的掌握、设计模式的理解、网络知识和常见 Linux 命令的掌握等。</p><p>值得庆幸的是以上所有内容都包含在本专栏中，接下来就让我们一起学习，一起构建 Java 的认知体系吧!</p><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="Java-语言都有哪些特点？"><a href="#Java-语言都有哪些特点？" class="headerlink" title="Java 语言都有哪些特点？"></a>Java 语言都有哪些特点？</h4><p>答：Java 语言包含以下特点。</p><ul><li>面向对象，程序容易理解、开发简单、方便；</li><li>跨平台，可运行在不同服务器类型上，比如：Linux、Windows、Mac 等；</li><li>执行性能好，运行效率高；</li><li>提供大量的 API 扩展，语言强大；</li><li>有多线程支持，增加了响应和实时交互的能力；</li><li>安全性好，自带验证机制，确保程序的可靠性和安全性。</li></ul><h4 id="Java-跨平台实现的原理是什么？"><a href="#Java-跨平台实现的原理是什么？" class="headerlink" title="Java 跨平台实现的原理是什么？"></a>Java 跨平台实现的原理是什么？</h4><p>答：要了解 Java 跨平台实现原理之前，必须先要了解 Java 的执行过程，Java 的执行过程如下：</p><p><img src="/" alt="执行过程" class="lazyload" data-src="https://images.gitbook.cn/bb3215b0-baa6-11e9-8bd3-43e1fddff917"></p><p>Java 执行流程：Java 源代码（.java）-&gt; 编译 -&gt; Java 字节码（.class） -&gt;通过 JVM（Java 虚拟机）运行 Java 程序。每种类型的服务器都会运行一个 JVM，Java 程序只需要生成 JVM 可以执行的代码即可，JVM 底层屏蔽了不同服务器类型之间的差异，从而可以在不同类型的服务器上运行一套 Java 程序。</p><h4 id="JDK、JRE、JVM-有哪些区别？"><a href="#JDK、JRE、JVM-有哪些区别？" class="headerlink" title="JDK、JRE、JVM 有哪些区别？"></a>JDK、JRE、JVM 有哪些区别？</h4><p>答：了解了 JDK、JRE、JVM 的定义也就明白了它们之间的区别，如下所述。</p><ul><li>JDK：Java Development Kit（Java 开发工具包）的简称，提供了 Java 的开发环境和运行环境；</li><li>JRE：Java Runtime Environment（Java 运行环境）的简称，为 Java 的运行提供了所需环境；</li><li>JVM：Java Virtual Machine（Java虚拟机）的简称，是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的，简单来说就是所有的 Java 程序都是运行在 JVM（Java 虚拟机）上的。</li></ul><p>总体来说，JDK 提供了一整套的 Java 运行和开发环境，通常使用对象为 Java 的开发者，当然 JDK 也包含了 JRE；而 JRE 为 Java 运行的最小运行单元，一般安装在 Java 服务器上，所以 JDK 和 JRE 可以从用途上进行理解和区分。JVM 不同于 JDK 和 JRE，JVM 是 Java 程序运行的载体，Java 程序只有通过 JVM 才能正常的运行。</p><h4 id="Java-中如何获取明天此刻的时间？"><a href="#Java-中如何获取明天此刻的时间？" class="headerlink" title="Java 中如何获取明天此刻的时间？"></a>Java 中如何获取明天此刻的时间？</h4><p>答：JDK 8 之前使用 <code>Calendar.add()</code> 方法获取，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">calendar.add(Calendar.DATE, <span class="number">1</span>);</span><br><span class="line">System.out.println(calendar.getTime());</span><br></pre></td></tr></table></figure><p>JDK 8 有两种获取明天时间的方法。</p><p>方法一，使用 <code>LocalDateTime.plusDays()</code> 方法获取，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime today = LocalDateTime.now();</span><br><span class="line">LocalDateTime tomorrow = today.plusDays(<span class="number">1</span>);</span><br><span class="line">System.out.println(tomorrow);</span><br></pre></td></tr></table></figure><p>方法二，使用 <code>LocalDateTime.minusDays()</code> 方法获取，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime today = LocalDateTime.now();</span><br><span class="line">LocalDateTime tomorrow = today.minusDays(-<span class="number">1</span>);</span><br><span class="line">System.out.println(tomorrow);</span><br></pre></td></tr></table></figure><p><code>minusDays()</code> 方法为当前时间减去 n 天，传负值就相当于当前时间加 n 天。</p><h4 id="Java-中如何跳出多重嵌套循环？"><a href="#Java-中如何跳出多重嵌套循环？" class="headerlink" title="Java 中如何跳出多重嵌套循环？"></a>Java 中如何跳出多重嵌套循环？</h4><p>答：Java 中跳出多重嵌套循环的两种方式。</p><ul><li>方法一：定义一个标号，使用 break 加标号的方式</li><li>方法二：使用全局变量终止循环</li></ul><p>方法一，示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myfor:<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;J:&quot;</span> + j);</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 跳出多重循环</span></span><br><span class="line">            <span class="keyword">break</span> myfor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二，示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span> &amp;&amp; flag; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;J:&quot;</span> + j);</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 跳出多重循环</span></span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="char-变量能不能存贮一个中文汉字？为什么？"><a href="#char-变量能不能存贮一个中文汉字？为什么？" class="headerlink" title="char 变量能不能存贮一个中文汉字？为什么？"></a>char 变量能不能存贮一个中文汉字？为什么？</h4><p>答：char 变量可以存贮一个汉字，因为 Java 中使用的默认编码是 Unicode ，一个 char 类型占 2 个字节（16 bit），所以放一个中文是没问题的。</p><h4 id="Java-中会存在内存泄漏吗？请简单描述一下。"><a href="#Java-中会存在内存泄漏吗？请简单描述一下。" class="headerlink" title="Java 中会存在内存泄漏吗？请简单描述一下。"></a>Java 中会存在内存泄漏吗？请简单描述一下。</h4><p>答：一个不再被程序使用的对象或变量一直被占据在内存中就造成了内存泄漏。</p><p>Java 中的内存泄漏的常见情景如下：</p><ul><li>长生命周期对象持有短生命的引用，比如，缓存系统，我们加载了一个对象放在缓存中，然后一直不使用这个缓存，由于缓存的对象一直被缓存引用得不到释放，就造成了内存泄漏；</li><li>各种连接未调用关闭方法，比如，数据库 Connection 连接，未显性地关闭，就会造成内存泄漏；</li><li>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露；</li><li>改变哈希值，当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄露。</li></ul><h2 id="你不知道的基本数据类型和包装类-面试题"><a href="#你不知道的基本数据类型和包装类-面试题" class="headerlink" title="你不知道的基本数据类型和包装类 + 面试题"></a>你不知道的基本数据类型和包装类 + 面试题</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Java 基本数据按类型可以分为四大类：布尔型、整数型、浮点型、字符型，这四大类包含 8 种基本数据类型。</p><ul><li>布尔型：boolean</li><li>整数型：byte、short、int、long</li><li>浮点型：float、double</li><li>字符型：char</li></ul><p>8 种基本类型取值如下：</p><table><thead><tr><th align="left">数据类型</th><th align="left">代表含义</th><th align="left">默认值</th><th align="left">取值</th><th align="left">包装类</th></tr></thead><tbody><tr><td align="left">boolean</td><td align="left">布尔型</td><td align="left">false</td><td align="left">0(false) 到 1(true)</td><td align="left">Boolean</td></tr><tr><td align="left">byte</td><td align="left">字节型</td><td align="left">(byte)0</td><td align="left">﹣128 到 127</td><td align="left">Byte</td></tr><tr><td align="left">char</td><td align="left">字符型</td><td align="left">‘\u0000’(空)</td><td align="left">‘\u0000’ 到 ‘\uFFFF’</td><td align="left">Character</td></tr><tr><td align="left">short</td><td align="left">短整数型</td><td align="left">(short)0</td><td align="left">-<em>[Math Processing Error]215</em> 到 <em>[Math Processing Error]215</em>-1</td><td align="left">Short</td></tr><tr><td align="left">int</td><td align="left">整数型</td><td align="left">0</td><td align="left">﹣*[Math Processing Error]231* 到 <em>[Math Processing Error]231</em>-1</td><td align="left">Integer</td></tr><tr><td align="left">long</td><td align="left">长整数型</td><td align="left">0L</td><td align="left">﹣*[Math Processing Error]263* 到 <em>[Math Processing Error]263</em>-1</td><td align="left">Long</td></tr><tr><td align="left">float</td><td align="left">单浮点型</td><td align="left">0.0f</td><td align="left">1.4e-45 到 3.4e+38</td><td align="left">Float</td></tr><tr><td align="left">double</td><td align="left">双浮点型</td><td align="left">0.0d</td><td align="left">4.9e-324 到 1.798e+308</td><td align="left">Double</td></tr></tbody></table><p>除 char 的包装类 Character 和 int 的包装类 Integer 之外，其他基本数据类型的包装类只需要首字母大写即可。包装类的作用和特点，本文下半部分详细讲解。</p><p>我们可以在代码中，查看某种类型的取值范围，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Byte 取值：-128 ~ 127</span></span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;Byte 取值：%d ~ %d&quot;</span>, Byte.MIN_VALUE, Byte.MAX_VALUE));</span><br><span class="line">    <span class="comment">// Int 取值：-2147483648 ~ 2147483647</span></span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;Int 取值：%d ~ %d&quot;</span>, Integer.MIN_VALUE, Integer.MAX_VALUE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>我们知道 8 种基本数据类型都有其对应的包装类，因为 Java 的设计思想是万物既对象，有很多时候我们需要以对象的形式操作某项功能，比如说获取哈希值（hashCode）或获取类（getClass）等。</p><p>那包装类特性有哪些？</p><p><strong>1. 功能丰富</strong></p><p>包装类本质上是一个对象，对象就包含有属性和方法，比如 hashCode、getClass 、max、min 等。</p><p><strong>2. 可定义泛型类型参数</strong></p><p>包装类可以定义泛型，而基本类型不行。</p><p>比如使用 Integer 定义泛型，代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>如果使用 int 定义就会报错，代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">// 编译器代码报错</span></span><br></pre></td></tr></table></figure><p><strong>3. 序列化</strong></p><p>因为包装类都实现了 Serializable 接口，所以包装类天然支持序列化和反序列化。比如 Integer 的类图如下：</p><p><img src="/" alt="Integer 类图" class="lazyload" data-src="https://images.gitbook.cn/cb8c6a80-baa8-11e9-8bd3-43e1fddff917"></p><p><strong>4. 类型转换</strong></p><p>包装类提供了类型转换的方法，可以很方便的实现类型之间的转换，比如 Integer 类型转换代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String age = <span class="string">&quot;18&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> ageInt = Integer.parseInt(age) + <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 输出结果：20</span></span><br><span class="line">System.out.println(ageInt);</span><br></pre></td></tr></table></figure><p><strong>5. 高频区间的数据缓存</strong></p><p>此特性为包装类很重要的用途之一，用于高频区间的数据缓存，以 Integer 为例来说，在数值区间为 -128~127 时，会直接复用已有对象，在这区间之外的数字才会在堆上产生。</p><p>我们使用 == 对 Integer 进行验证，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Integer 高频区缓存范围 -128~127</span></span><br><span class="line">        Integer num1 = <span class="number">127</span>;</span><br><span class="line">        Integer num2 = <span class="number">127</span>;</span><br><span class="line">        <span class="comment">// Integer 取值 127 == 结果为 true（值127 num1==num2 =&gt; true）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;值127 num1==num2 =&gt; &quot;</span> + (num1 == num2));</span><br><span class="line">        Integer num3 = <span class="number">128</span>;</span><br><span class="line">        Integer num4 = <span class="number">128</span>;</span><br><span class="line">        <span class="comment">// Integer 取值 128 == 结果为 false（值128 num3==num4 =&gt; false）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;值128 num3==num4 =&gt; &quot;</span> + (num3 == num4));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面的代码很明显可以看出，Integer 为 127 时复用了已有对象，当值为 128 时，重新在堆上生成了新对象。</p><p>为什么会产生高频区域数据缓存？我们查看源码就能发现“线索”，源码版本 JDK8，源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">    <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见，高频区域的数值会直接使用已有对象，非高频区域的数值会重新 new 一个新的对象。</p><p>各包装类高频区域的取值范围：</p><ul><li>Boolean：使用静态 final 定义，就会返回静态值</li><li>Byte：缓存区 -128~127</li><li>Short：缓存区 -128~127</li><li>Character：缓存区 0~127</li><li>Long：缓存区 -128~127</li><li>Integer：缓存区 -128~127</li></ul><h3 id="包装类的注意事项"><a href="#包装类的注意事项" class="headerlink" title="包装类的注意事项"></a>包装类的注意事项</h3><ul><li>int 的默认值是 0，而 Integer 的默认值是 null。</li><li>推荐所有包装类对象之间的值比较使用 <code>equals()</code> 方法，因为包装类的非高频区数据会在堆上产生，而高频区又会复用已有对象，这样会导致同样的代码，因为取值的不同，而产生两种截然不同的结果。代码示例：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Integer 高频区缓存范围 -128~127</span></span><br><span class="line">    Integer num1 = <span class="number">127</span>;</span><br><span class="line">    Integer num2 = <span class="number">127</span>;</span><br><span class="line">    <span class="comment">// Integer 取值 127 == 结果为 true（值127 num1==num2 =&gt; true）</span></span><br><span class="line">    System.out.println(<span class="string">&quot;值127 num1==num2 =&gt; &quot;</span> + (num1 == num2));</span><br><span class="line">    Integer num3 = <span class="number">128</span>;</span><br><span class="line">    Integer num4 = <span class="number">128</span>;</span><br><span class="line">    <span class="comment">// Integer 取值 128 == 结果为 false（值128 num3==num4 =&gt; false）</span></span><br><span class="line">    System.out.println(<span class="string">&quot;值128 num3==num4 =&gt; &quot;</span> + (num3 == num4));</span><br><span class="line">    <span class="comment">// Integer 取值 128 equals 结果为 true（值128 num3.equals(num4) =&gt; true）</span></span><br><span class="line">    System.out.println(<span class="string">&quot;值128 num3.equals(num4) =&gt; &quot;</span> + num3.equals(num4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Float 和 Double 不会有缓存，其他包装类都有缓存。</li><li>Integer 是唯一一个可以修改缓存范围的包装类，在 VM optons 加入参数：</li></ul><blockquote><p>-XX:AutoBoxCacheMax=666 即修改缓存最大值为 <code>666</code> 。</p></blockquote><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer num1 = -<span class="number">128</span>;</span><br><span class="line">    Integer num2 = -<span class="number">128</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;值为-128 =&gt; &quot;</span> + (num1 == num2));</span><br><span class="line">    Integer num3 = <span class="number">666</span>;</span><br><span class="line">    Integer num4 = <span class="number">666</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;值为666 =&gt; &quot;</span> + (num3 == num4));</span><br><span class="line">    Integer num5 = <span class="number">667</span>;</span><br><span class="line">    Integer num6 = <span class="number">667</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;值为667 =&gt; &quot;</span> + (num5 == num6));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">值为-<span class="number">128</span> =&gt; <span class="keyword">true</span></span><br><span class="line">值为<span class="number">666</span> =&gt; <span class="keyword">true</span></span><br><span class="line">值为<span class="number">667</span> =&gt; <span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>由此可见将 Integer 最大缓存修改为 666 之后，667 不会被缓存，而 -128~666 之间的数都被缓存了。</p><h3 id="相关面试题-1"><a href="#相关面试题-1" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="以下-Integer-代码输出的结果是？"><a href="#以下-Integer-代码输出的结果是？" class="headerlink" title="以下 Integer 代码输出的结果是？"></a>以下 Integer 代码输出的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer age = <span class="number">10</span>;</span><br><span class="line">Integer age2 = <span class="number">10</span>;</span><br><span class="line">Integer age3 = <span class="number">133</span>;</span><br><span class="line">Integer age4 = <span class="number">133</span>;</span><br><span class="line">System.out.println((age == age2) + <span class="string">&quot;,&quot;</span> + (age3 == age4));</span><br></pre></td></tr></table></figure><p>答：<code>true,false</code></p><h4 id="以下-Double-代码输出的结果是？"><a href="#以下-Double-代码输出的结果是？" class="headerlink" title="以下 Double 代码输出的结果是？"></a>以下 Double 代码输出的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Double num = <span class="number">10d</span>;</span><br><span class="line">Double num2 = <span class="number">10d</span>;</span><br><span class="line">Double num3 = <span class="number">133d</span>;</span><br><span class="line">Double num4 = <span class="number">133d</span>;</span><br><span class="line">System.out.println((num == num2) + <span class="string">&quot;,&quot;</span> + (num3 == num4));</span><br></pre></td></tr></table></figure><p>答：<code>false,false</code></p><h4 id="以下程序输出结果是？"><a href="#以下程序输出结果是？" class="headerlink" title="以下程序输出结果是？"></a>以下程序输出结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">System.out.println(i == j);</span><br><span class="line">System.out.println(j.equals(i));</span><br></pre></td></tr></table></figure><p>A：true,true<br>B：true,false<br>C：false,true<br>D：false,false</p><p>答：A</p><p>题目分析：有人认为这和 Integer 高速缓存有关系，但你发现把值改为 10000 结果也是 <code>true,true</code>，这是因为 Integer 和 int 比较时，会自动拆箱为 int 相当于两个 int 比较，值一定是 <code>true,true</code>。</p><h4 id="以下程序执行的结果是？"><a href="#以下程序执行的结果是？" class="headerlink" title="以下程序执行的结果是？"></a>以下程序执行的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> iMax = Integer.MAX_VALUE;</span><br><span class="line">System.out.println(iMax + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>A：2147483648<br>B：-2147483648<br>C：程序报错<br>D：以上都不是</p><p>答：B</p><p>题目解析：这是因为整数在内存中使用的是补码的形式表示，最高位是符号位 0 表示正数，1 表示负数，当执行 +1 时，最高位就变成了 1，结果就成了 -2147483648。</p><h4 id="以下程序执行的结果是？-1"><a href="#以下程序执行的结果是？-1" class="headerlink" title="以下程序执行的结果是？"></a>以下程序执行的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Short&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">short</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    set.add(i);</span><br><span class="line">    set.remove(i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(set.size());</span><br></pre></td></tr></table></figure><p>A：1<br>B：0<br>C：5<br>D：以上都不是</p><p>答：5</p><p>题目解析：Short 类型 -1 之后转换成了 Int 类型，remove() 的时候在集合中找不到 Int 类型的数据，所以就没有删除任何元素，执行的结果就是 5。</p><h4 id="short-s-2-s-s-1-会报错吗？short-s-2-s-1-会报错吗？"><a href="#short-s-2-s-s-1-会报错吗？short-s-2-s-1-会报错吗？" class="headerlink" title="short s=2;s=s+1; 会报错吗？short s=2;s+=1; 会报错吗？"></a><code>short s=2;s=s+1;</code> 会报错吗？<code>short s=2;s+=1;</code> 会报错吗？</h4><p>答：s=s+1 会报错，s+=1 不会报错，因为 s=s+1 会导致 short 类型升级为 int 类型，所以会报错，而 s+=1 还是原来的 short 类型，所以不会报错。</p><h4 id="float-f-3-4-会报错吗？为什么？"><a href="#float-f-3-4-会报错吗？为什么？" class="headerlink" title="float f=3.4; 会报错吗？为什么？"></a><code>float f=3.4;</code> 会报错吗？为什么？</h4><p>答：会报错，因为值 3.4 是 double 类型，float 类型级别小于 double 类型，所以会报错。如下图所示：</p><p><img src="/" alt="报错示例图" class="lazyload" data-src="https://images.gitbook.cn/1cab8440-baaa-11e9-8bd3-43e1fddff917"></p><h4 id="为什么需要包装类？"><a href="#为什么需要包装类？" class="headerlink" title="为什么需要包装类？"></a>为什么需要包装类？</h4><p>答：需要包装类的原因有两个。</p><p>① Java 的设计思想是万物既对象，包装类体现了面向对象的设计理念；<br>② 包装类包含了很多属性和方法，比基本数据类型功能多，比如提供的获取哈希值（hashCode）或获取类（getClass）的方法等。</p><h4 id="基本类-int-和包装类-Integer，在-128-127-之间都会复用已有的缓存对象，这种说法正确吗？"><a href="#基本类-int-和包装类-Integer，在-128-127-之间都会复用已有的缓存对象，这种说法正确吗？" class="headerlink" title="基本类 int 和包装类 Integer，在 -128~127 之间都会复用已有的缓存对象，这种说法正确吗？"></a>基本类 int 和包装类 Integer，在 -128~127 之间都会复用已有的缓存对象，这种说法正确吗？</h4><p>答：不正确，只有包装类高频区域数据才有缓存。</p><h4 id="包装类-Double-和-Integer-一样都有高频区域数据缓存，这种说法正确吗？"><a href="#包装类-Double-和-Integer-一样都有高频区域数据缓存，这种说法正确吗？" class="headerlink" title="包装类 Double 和 Integer 一样都有高频区域数据缓存，这种说法正确吗？"></a>包装类 Double 和 Integer 一样都有高频区域数据缓存，这种说法正确吗？</h4><p>答：不正确，基本数据类型的包装类只有 Double 和 Float 没有高频区域的缓存。</p><h4 id="包装类的值比较要使用什么方法？"><a href="#包装类的值比较要使用什么方法？" class="headerlink" title="包装类的值比较要使用什么方法？"></a>包装类的值比较要使用什么方法？</h4><p>答：包装类因为有高频区域数据缓存，所以推荐使用 equals() 方法进行值比较。</p><h4 id="包装类有哪些功能？"><a href="#包装类有哪些功能？" class="headerlink" title="包装类有哪些功能？"></a>包装类有哪些功能？</h4><p>答：包装类提供的功能有以下几个。</p><ul><li>功能丰富：包装类包含了有 hashCode、getClass 、max、min 等方法；</li><li>可定义泛型类型参数：例如 <code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code> ;</li><li>序列化：包装类实现了 Serializable 接口，所以包装类天然支持序列化和反序列化；</li><li>类型转换：包装类提供了方便的类型转换方法，比如 Integer 的 parseInt() 方法；</li><li>高频区域数据缓存：高频区域可使用已有的缓存对象。</li></ul><p>详见正文“包装类型”部分内容。</p><h4 id="泛型可以为基本类型吗？为什么？"><a href="#泛型可以为基本类型吗？为什么？" class="headerlink" title="泛型可以为基本类型吗？为什么？"></a>泛型可以为基本类型吗？为什么？</h4><p>答：泛型不能使用基本数据类型。泛型在 JVM（Java虚拟机）编译的时候会类型檫除，比如代码 <code>List&lt;Integer&gt; list</code> 在 JVM 编译的时候会转换为 <code>List list</code> ，因为泛型是在 JDK 5 时提供的，而 JVM 的类型檫除是为了兼容以前代码的一个折中方案，类型檫除之后就变成了 Object，而 Object 不能存储基本数据类型，但可以使用基本数据类型对应的包装类，所以像 <code>List&lt;int&gt; list</code> 这样的代码是不被允许的，编译器阶段会检查报错，而 <code>List&lt;Integer&gt; list</code> 是被允许的。</p><h4 id="选择包装类还是基本类的原则有哪些？"><a href="#选择包装类还是基本类的原则有哪些？" class="headerlink" title="选择包装类还是基本类的原则有哪些？"></a>选择包装类还是基本类的原则有哪些？</h4><p>答：我们知道正确的使用包装类，可以提供程序的执行效率，可以使用已有的缓存，一般情况下选择基本数据类型还是包装类原则有以下几个。</p><p>① 所有 POJO 类属性必须使用包装类；<br>② RPC 方法返回值和参数必须使用包装类；<br>③ 所有局部变量推荐使用基本数据类型。</p><h4 id="基本数据类型在-JVM-中一定存储在栈中吗？为什么？"><a href="#基本数据类型在-JVM-中一定存储在栈中吗？为什么？" class="headerlink" title="基本数据类型在 JVM 中一定存储在栈中吗？为什么？"></a>基本数据类型在 JVM 中一定存储在栈中吗？为什么？</h4><p>答：基本数据类型不一定存储在栈中，因为基本类型的存储位置取决于声明的作用域，来看具体的解释。</p><ul><li>当基本数据类型为局部变量的时候，比如在方法中声明的变量，则存放在方法栈中的，当方法结束系统会释放方法栈，在该方法中的变量也会随着栈的销毁而结束，这也是局部变量只能在方法中使用的原因；</li><li>当基本数据类型为全局变量的时候，比如类中的声明的变量，则存储在堆上，因为全局变量不会随着某个方法的执行结束而销毁。</li></ul><h4 id="以下程序执行的结果是？-2"><a href="#以下程序执行的结果是？-2" class="headerlink" title="以下程序执行的结果是？"></a>以下程序执行的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">Integer i3 = Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">Integer i4 = Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">System.out.println(i1 == i2);</span><br><span class="line">System.out.println(i2 == i3);</span><br><span class="line">System.out.println(i3 == i4);</span><br></pre></td></tr></table></figure><p>A：false,false,false<br>B：false,false,true<br>C：false,true,true<br>D：true,false,false</p><p>答：B</p><p>题目解析：new Integer(10) 每次都会创建一个新对象，Integer.valueOf(10) 则会使用缓存池中的对象。</p><h4 id="3-0-1-0-3-返回值是多少？"><a href="#3-0-1-0-3-返回值是多少？" class="headerlink" title="3*0.1==0.3 返回值是多少？"></a>3*0.1==0.3 返回值是多少？</h4><p>答：返回值为：false。</p><p>题目解析：因为有些浮点数不能完全精确的表示出来，如下代码：</p><blockquote><p>System.out.println(3 * 0.1);</p></blockquote><p>返回的结果是：0.30000000000000004。</p><h2 id="深入理解字符串-面试题"><a href="#深入理解字符串-面试题" class="headerlink" title="深入理解字符串 + 面试题"></a>深入理解字符串 + 面试题</h2><h3 id="字符串介绍"><a href="#字符串介绍" class="headerlink" title="字符串介绍"></a>字符串介绍</h3><p>字符串是程序开发当中，使用最频繁的类型之一，有着与基础类型相同的地位，甚至在 JVM（Java 虚拟机）编译的时候会对字符串做特殊的处理，比如拼加操作可能会被 JVM 直接合成为一个最终的字符串，从而到达高效运行的目的。</p><h4 id="String-特性"><a href="#String-特性" class="headerlink" title="String 特性"></a>String 特性</h4><ul><li>String 是标准的不可变类（immutable），对它的任何改动，其实就是创建了一个新对象，再把引用指向该对象；</li><li>String 对象赋值之后就会在常量池中缓存，如果下次创建会判定常量池是否已经有缓存对象，如果有的话直接返回该引用给创建者。</li></ul><h4 id="字符串创建"><a href="#字符串创建" class="headerlink" title="字符串创建"></a>字符串创建</h4><p>字符串创建的两种方式：</p><ul><li>String str = “laowang”;</li><li>String str = new String(“laowang”);</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>查看下面代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;laowang&quot;</span>;</span><br><span class="line">String s2 = s1;</span><br><span class="line">String s3 = <span class="keyword">new</span> String(s1);</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line">System.out.println(s1 == s3);</span><br></pre></td></tr></table></figure><p>输出结果：<code>true、false</code>。</p><p>为什么会这样？原因是 s3 使用 new String 时一定会在堆中重新创建一个内存区域，而 s2 则会直接使用了 s1 的引用，所以得到的结果也完全不同。</p><h3 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h3><h4 id="字符串拼加"><a href="#字符串拼加" class="headerlink" title="字符串拼加"></a>字符串拼加</h4><p>字符串拼加的几种方式：</p><ul><li>String str = “lao” + “wang”;</li><li>String str = “lao”; str += “wang”;</li><li>String str = “lao”; String str2 = str + “wang”;</li></ul><h4 id="JVM-对字符串的优化"><a href="#JVM-对字符串的优化" class="headerlink" title="JVM 对字符串的优化"></a>JVM 对字符串的优化</h4><p>根据前面的知识我们知道，对于 String 的任何操作其实是创建了一个新对象，然后再把引用地址返回该对象，但 JVM 也会对 String 进行特殊处理，以此来提供程序的运行效率，比如以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;hi,&quot;</span> + <span class="string">&quot;lao&quot;</span> + <span class="string">&quot;wang&quot;</span>;</span><br></pre></td></tr></table></figure><p>经过 JVM 优化后的代码是这样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;hi,laowang&quot;</span>;</span><br></pre></td></tr></table></figure><p>验证代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;hi,&quot;</span> + <span class="string">&quot;lao&quot;</span> + <span class="string">&quot;wang&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;hi,laowang&quot;</span>;</span><br><span class="line">System.out.println(str == str2);</span><br></pre></td></tr></table></figure><p>执行的结果：<code>true</code>。</p><p>这就说明 JVM 在某些情况下会特殊处理 String 类型。</p><h4 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h4><p>字符串的截取使用 <code>substring()</code> 方法，使用如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="comment">// 结果：cdef（从下标为2的开始截取到最后，包含开始下标）</span></span><br><span class="line">System.out.println(str.substring(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 结果：cd（从下标为2的开始截取到下标为4的，包含开始下标不包含结束下标）</span></span><br><span class="line">System.out.println(str.substring(<span class="number">2</span>,<span class="number">4</span>));</span><br></pre></td></tr></table></figure><h4 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h4><p>字符串格式化可以让代码更简洁更直观，比如，“我叫老王，今年 30 岁，喜欢读书”在这条信息中：姓名、年龄、兴趣都是要动态改变的，如果使用“+”号拼接的话很容易出错，这个时候字符串格式化方法 String.format() 就派上用场了，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = String.format(<span class="string">&quot;我叫%s，今年%d岁，喜欢%s&quot;</span>, <span class="string">&quot;老王&quot;</span>, <span class="number">30</span>, <span class="string">&quot;读书&quot;</span>);</span><br></pre></td></tr></table></figure><p>转换符说明列表：</p><table><thead><tr><th align="left"><strong>转换符</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">%s</td><td align="left">字符串类型</td></tr><tr><td align="left">%d</td><td align="left">整数类型（十进制）</td></tr><tr><td align="left">%c</td><td align="left">字符类型</td></tr><tr><td align="left">%b</td><td align="left">布尔类型</td></tr><tr><td align="left">%x</td><td align="left">整数类型（十六进制）</td></tr><tr><td align="left">%o</td><td align="left">整数类型（八进制）</td></tr><tr><td align="left">%f</td><td align="left">浮点类型</td></tr><tr><td align="left">%a</td><td align="left">浮点类型（十六进制）</td></tr><tr><td align="left">%e</td><td align="left">指数类型</td></tr><tr><td align="left">%%</td><td align="left">百分比类型</td></tr><tr><td align="left">%n</td><td align="left">换行符</td></tr></tbody></table><h4 id="字符对比"><a href="#字符对比" class="headerlink" title="字符对比"></a>字符对比</h4><p>根据前面的知识我们知道，使用 String 和 new String 声明的对象是不同的，那有没有简单的方法，可以忽略它们的创建方式（有没有 new）而只对比它们的值是否相同呢？答案是肯定的，使用 <code>equals()</code> 方法可以实现，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;hi,&quot;</span> + <span class="string">&quot;lao&quot;</span> + <span class="string">&quot;wang&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;hi,&quot;</span>;</span><br><span class="line">s2 += <span class="string">&quot;lao&quot;</span>;</span><br><span class="line">s2 += <span class="string">&quot;wang&quot;</span>;</span><br><span class="line">String s3 = <span class="string">&quot;hi,laowang&quot;</span>;</span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line">System.out.println(s1.equals(s3)); <span class="comment">// true</span></span><br><span class="line">System.out.println(s2.equals(s3)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>以上使用 equals 对比的结果都为 <code>true</code>。</p><p>如果要忽略字符串的大小写对比值可以使用 <code>equalsIgnoreCase()</code>，代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;Hi,laowang&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;hi,laowang&quot;</span>;</span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// false</span></span><br><span class="line">System.out.println(s1.equalsIgnoreCase(s2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>s1.equals(s2) 执行的结果为：<code>false</code>，s1.equalsIgnoreCase(s2) 执行的结果为：<code>true</code>。</p><h4 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h4><p>字符串相关类型主要有这三种：String、StringBuffer、StringBuilder，其中 StringBuffer、StringBuilder 都是可以变的字符串类型，StringBuffer 在字符串拼接时使用 synchronized 来保障线程安全，因此在多线程字符串拼接中推荐使用 StringBuffer。</p><p><strong>StringBuffer 使用：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sf = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;lao&quot;</span>);</span><br><span class="line"><span class="comment">// 添加字符串到尾部</span></span><br><span class="line">sf.append(<span class="string">&quot;wang&quot;</span>); <span class="comment">// 执行结果：laowang</span></span><br><span class="line"><span class="comment">// 插入字符串到到当前字符串下标的位置</span></span><br><span class="line">sf.insert(<span class="number">0</span>,<span class="string">&quot;hi,&quot;</span>); <span class="comment">// 执行结果：hi,laowang</span></span><br><span class="line"><span class="comment">// 修改字符中某个下标的值</span></span><br><span class="line">sf.setCharAt(<span class="number">0</span>,<span class="string">&#x27;H&#x27;</span>); <span class="comment">// 执行结果：Hi,laowang</span></span><br></pre></td></tr></table></figure><p>StringBuilder 的使用方法和 StringBuffer 一样，它们都继承于 AbstractStringBuilder。</p><h3 id="相关面试题-2"><a href="#相关面试题-2" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="String-属于基础数据类型吗？"><a href="#String-属于基础数据类型吗？" class="headerlink" title="String 属于基础数据类型吗？"></a>String 属于基础数据类型吗？</h4><p>答：String 不是基础数据类型，它是从堆上分配来的。基础数据类型有 8 个，分别为：boolean、byte、short、int、long、float、double、char。</p><h4 id="以下可以正确获取字符串长度的是？"><a href="#以下可以正确获取字符串长度的是？" class="headerlink" title="以下可以正确获取字符串长度的是？"></a>以下可以正确获取字符串长度的是？</h4><p>A：str.length<br>B：str.size<br>C：str.length()<br>D：str.size()</p><p>答：C</p><p>题目解析：字符串没有 length 属性，只有 <code>length()</code> 方法。</p><h4 id="“-”-和-equals-的区别是什么？"><a href="#“-”-和-equals-的区别是什么？" class="headerlink" title="“==” 和 equals 的区别是什么？"></a>“==” 和 equals 的区别是什么？</h4><p>答：”==” 对基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p><p><strong>① “==” 解读</strong></p><p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p><ul><li>基本类型：比较的是值是否相同；</li><li>引用类型：比较的是引用是否相同。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String x = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">String y = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">String z = <span class="keyword">new</span> String(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">System.out.println(x==y); <span class="comment">// true</span></span><br><span class="line">System.out.println(x==z); <span class="comment">// false</span></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x.equals(z)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>代码说明：因为 x 和 y 指向的是同一个引用，所以 <code>==</code> 也是 true，而 <code>new String()</code> 方法则重写开辟了内存空间，所以 <code>==</code> 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p><p><strong>② equals 解读</strong></p><p>equals 本质上就是 <code>==</code>，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p><p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Cat c1 = <span class="keyword">new</span> Cat(<span class="string">&quot;王磊&quot;</span>);</span><br><span class="line">Cat c2 = <span class="keyword">new</span> Cat(<span class="string">&quot;王磊&quot;</span>);</span><br><span class="line">System.out.println(c1.equals(c2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>输出结果出乎我们的意料，竟然是 false？！</p><p>这是怎么回事，看了 equals 源码就知道了，源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来 equals 本质上就是 <code>==</code>。</p><p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p><p>总结来说，”==” 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p><h4 id="以下代码输出的结果是？"><a href="#以下代码输出的结果是？" class="headerlink" title="以下代码输出的结果是？"></a>以下代码输出的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;laowang&quot;</span>;</span><br><span class="line">str.substring(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><p>A：l<br>B：a<br>C：la<br>D：laowang</p><p>答：D</p><p>题目解析：因为 String 的 substring() 方法不会修改原字符串内容，所以结果还是 laowang。</p><h4 id="以下字符串对比的结果是什么？"><a href="#以下字符串对比的结果是什么？" class="headerlink" title="以下字符串对比的结果是什么？"></a>以下字符串对比的结果是什么？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;hi,&quot;</span> + <span class="string">&quot;lao&quot;</span> + <span class="string">&quot;wang&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;hi,&quot;</span>;</span><br><span class="line">s2 += <span class="string">&quot;lao&quot;</span>;</span><br><span class="line">s2 += <span class="string">&quot;wang&quot;</span>;</span><br><span class="line">String s3 = <span class="string">&quot;hi,laowang&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line">System.out.println(s1 == s3);</span><br><span class="line">System.out.println(s2 == s3);</span><br></pre></td></tr></table></figure><p>答：false true false</p><p>题目解析：String s1 = “hi,” + “lao” + “wang” 代码会被 JVM 优化为：String s1 = “hi,laowang”，这样就和 s3 完全相同，s1 创建的时候会把字符”hi,laowang”放入常量池，s3 创建的时候，常量池中已经存在对应的缓存，会直接把引用返回给 s3，所以 <code>s1==s3</code> 就为 true，而 s2 使用了 <code>+=</code> 其引用地址就和其他两个不同。</p><h4 id="以下-String-传值修改后执行的结果是什么？"><a href="#以下-String-传值修改后执行的结果是什么？" class="headerlink" title="以下 String 传值修改后执行的结果是什么？"></a>以下 String 传值修改后执行的结果是什么？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  String str = <span class="keyword">new</span> String(<span class="string">&quot;laowang&quot;</span>);</span><br><span class="line">  change(str);</span><br><span class="line">  System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    str = <span class="string">&quot;xiaowang&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：laowang</p><h4 id="以下-StringBuffer-传值修改后的执行结果是什么？"><a href="#以下-StringBuffer-传值修改后的执行结果是什么？" class="headerlink" title="以下 StringBuffer 传值修改后的执行结果是什么？"></a>以下 StringBuffer 传值修改后的执行结果是什么？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  StringBuffer sf = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;hi,&quot;</span>);</span><br><span class="line">  changeSf(sf);</span><br><span class="line">  System.out.println(sf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeSf</span><span class="params">(StringBuffer sf)</span></span>&#123;</span><br><span class="line">    sf.append(<span class="string">&quot;laowang&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：hi,laowang</p><p>题目解析：String 为不可变类型，在方法内对 String 修改的时候，相当修改传递过来的是一个 String 副本，所以 String 本身的值是不会被修改的，而 StringBuffer 为可变类型，参数传递过来的是对象的引用，对其修改它本身就会发生改变。</p><h4 id="以下使用-substring-执行的结果什么？"><a href="#以下使用-substring-执行的结果什么？" class="headerlink" title="以下使用 substring 执行的结果什么？"></a>以下使用 substring 执行的结果什么？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">System.out.println(str.substring(<span class="number">3</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure><p>答：””(空)。</p><h4 id="判定字符串是否为空，有几种方式？"><a href="#判定字符串是否为空，有几种方式？" class="headerlink" title="判定字符串是否为空，有几种方式？"></a>判定字符串是否为空，有几种方式？</h4><p>答：常用的方式有以下两种。</p><ul><li>str.equals(“”)</li><li>str.length()==0</li></ul><h4 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h4><p>答：以下是 String、StringBuffer、StringBuilder 的区别：</p><ul><li>可变性：String 为字符串常量是不可变对象，StringBuffer 与 StringBuilder 为字符串变量是可变对象；</li><li>性能：String 每次修改相当于生成一个新对象，因此性能最低；StringBuffer 使用 synchronized 来保证线程安全，性能优于 String，但不如 StringBuilder；</li><li>线程安全：StringBuilder 为非线程安全类，StringBuffer 为线程安全类。</li></ul><h4 id="String-对象的-intern-有什么作用？"><a href="#String-对象的-intern-有什么作用？" class="headerlink" title="String 对象的 intern() 有什么作用？"></a>String 对象的 intern() 有什么作用？</h4><p>答：intern() 方法用于查找常量池中是否存在该字符值，如果常量池中不存在则先在常量池中创建，如果已经存在则直接返回。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;laowang&quot;</span>;</span><br><span class="line">String s2 = s.intern();</span><br><span class="line">System.out.println(s == s2); <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure><h4 id="String-s-new-String-“laowang”-创建了几个对象？"><a href="#String-s-new-String-“laowang”-创建了几个对象？" class="headerlink" title="String s=new String(“laowang”) 创建了几个对象？"></a>String s=new String(“laowang”) 创建了几个对象？</h4><p>答：总共创建了两个对象，一个是字符串 “laowang”，另一个是指向字符串的变量 s。new String() 不管常量池有没有相同的字符串，都会在内存（非字符串常量池）中创建一个新的对象。</p><h4 id="什么是字符串常量池？"><a href="#什么是字符串常量池？" class="headerlink" title="什么是字符串常量池？"></a>什么是字符串常量池？</h4><p>字符串常量池是存储在 Java 堆内存中的字符串池，是为防止每次新建字符串带的时间和空间消耗的一种解决方案。在创建字符串时 JVM 会首先检查字符串常量池，如果字符串已经存在池中，就返回池中的实例引用，如果字符串不在池中，就会实例化一个字符串放到池中并把当前引用指向该字符串。</p><h4 id="String-不可变性都有哪些好处？"><a href="#String-不可变性都有哪些好处？" class="headerlink" title="String 不可变性都有哪些好处？"></a>String 不可变性都有哪些好处？</h4><p>答：不可变的好处如下。</p><ul><li>只有当字符串是不可变的，字符串常量池才能实现，字符串池的实现可以在运行时节约很多堆空间，因为不同的字符串变量都指向池中的同一个字符串；</li><li>可以避免一些安全漏洞，比如在 Socket 编程中，主机名和端口都是以字符串的形式传入，因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞；</li><li>多线程安全，因为字符串是不可变的，所以同一个字符串实例可以被多个线程共享，保证了多线程的安全性；</li><li>适合做缓存的 key，因为字符串是不可变的，所以在它创建的时候哈希值就被缓存了，不需要重新计算速度更快，所以字符串很适合作缓存的中的 key。</li></ul><h4 id="String-是否可以被继承？为什么？"><a href="#String-是否可以被继承？为什么？" class="headerlink" title="String 是否可以被继承？为什么？"></a>String 是否可以被继承？为什么？</h4><p>答：String 不能被继承。因为 String 被声明为 final（最终类），所以不能被继承，源码如下（JDK 8）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-中的运算符和流程控制-面试题"><a href="#Java-中的运算符和流程控制-面试题" class="headerlink" title="Java 中的运算符和流程控制 + 面试题"></a>Java 中的运算符和流程控制 + 面试题</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>Java 中的算法运算符，包括以下几种：</p><table><thead><tr><th align="left"><strong>算术运算符</strong></th><th align="left"><strong>名称</strong></th><th align="left"><strong>举例</strong></th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加法</td><td align="left">1+2=3</td></tr><tr><td align="left">-</td><td align="left">减法</td><td align="left">2-1=1</td></tr><tr><td align="left">*</td><td align="left">乘法</td><td align="left">2*3=6</td></tr><tr><td align="left">/</td><td align="left">除法</td><td align="left">24/8=3</td></tr><tr><td align="left">%</td><td align="left">求余</td><td align="left">24%7=3</td></tr><tr><td align="left">++</td><td align="left">自增1</td><td align="left">int i=1;i++</td></tr><tr><td align="left">–</td><td align="left">自减1</td><td align="left">int i=1;i–</td></tr></tbody></table><p>我们本讲要重点讲的是 “++” 和 “–”，其他的算术运算符相对比较简单直观，本讲就不花精力去讲解了，之所以要把 “++” 和 “–” 单独拿出来讲，是因为在使用他们的时候有很多坑需要开发者注意，最重要的是 “++” 和 “–” 也是面试中高频出现的面试题。</p><p>先来看 “++” 的基本使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i2 = ++i; <span class="comment">// ++i 相当于 i = 1+i;</span></span><br><span class="line">System.out.println(i);  <span class="comment">// 2</span></span><br><span class="line">System.out.println(i2); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><strong>++i 和 i++ 的区别</strong></p><ul><li><code>++i</code> 先自加再赋值</li><li><code>i++</code> 先赋值再自加</li></ul><p>比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i2 = i++;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j2 = ++j;</span><br><span class="line">System.out.println(<span class="string">&quot;i2=&quot;</span> + i2);</span><br><span class="line">System.out.println(<span class="string">&quot;j2=&quot;</span> + j2);</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i2=<span class="number">0</span></span><br><span class="line">j2=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>代码解析：<code>i++</code> 是先给 i2 赋值再自身 +1 ，所以 i2 等于0，而 <code>++j</code> 是先自加等于 1 之后，再赋值给 j2，所以 j2 等于 1。</p><p><strong>注意事项</strong></p><p>++/– 是非线程安全的，也就是说 ++/– 操作在多线程下可能会引发混乱，例如下面代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread:&quot;</span> + <span class="keyword">this</span>.getName() + <span class="string">&quot;,count=&quot;</span> + (++count));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread:&quot;</span> + <span class="keyword">this</span>.getName() + <span class="string">&quot;,count=&quot;</span> + (++count));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure><p>执行的结果，如下图：</p><p><img src="/" alt="执行结果" class="lazyload" data-src="https://images.gitbook.cn/3e80ae80-baad-11e9-8bd3-43e1fddff917"></p><p>如上图所示，每台机器的执行可能略有差距，但大多数情况下并不能给我们想要的真实值 200000。</p><p><strong>原理分析</strong></p><p>“++” 操作在多线程下引发混乱的原因：因为 ++ 操作对于底层操作系统来说，并不是一条 CPU 操作指令，而是三条 CPU 操作指令——取值、累加、存储，因此无法保证原子性，就会出现上面代码执行后的误差。</p><p><strong>如何避免 ++/– 操作在多线程下的“误差”？</strong></p><ul><li>方法一：++/– 操作放在同步块 synchronized 中。</li><li>方法二：自己申明锁，把 ++/– 操作放入其中。</li><li>方法三：使用 AtomicInteger 类型替代 int 类型。</li></ul><p>最后，因为 – 的语法和 ++ 完全一致，所以 – 的操作，请参照上面的 ++ 语法。</p><h3 id="条件运算符（三元运算符）"><a href="#条件运算符（三元运算符）" class="headerlink" title="条件运算符（三元运算符）"></a>条件运算符（三元运算符）</h3><p>条件运算符（?:）也叫“三元运算符”。</p><p>语法：</p><blockquote><p>布尔表达式 ? 表达式1 ：表达式2</p></blockquote><p>运算过程：如果布尔表达式的值为 true，则返回 <strong>表达式 1 的值</strong>，否则返回 <strong>表达式 2 的值</strong>。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="number">3</span> &gt; <span class="number">1</span> ? <span class="string">&quot;三大于一&quot;</span> : <span class="string">&quot;三小于一&quot;</span>;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><p>执行结果：<code>三大于一</code>。</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>在 Java 语言中使用条件语句和循环结构来实现流程控制。</p><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>条件语句的语法格式：</p><blockquote><p>if(……) ……</p></blockquote><p>其中的条件判断必须使用括号括起来不能省略。</p><p>基础用法使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i大于一&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i等于一&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;其他&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>while 当条件成立的时候执行下一条语句。</p><p>while 语法格式：</p><blockquote><p>while(……) ……</p></blockquote><p>基本语法使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">  System.out.println(++i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while 是先判断再决定是否执行，有可能一次也不执行，如果希望至少执行一次，可以使用 do/while。</p><p>do/while 语法格式：</p><blockquote><p>do{……}while(……);</p></blockquote><p>基本语法使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  System.out.println(++i);</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="确定循环"><a href="#确定循环" class="headerlink" title="确定循环"></a>确定循环</h4><p>for 循环是程序中最长使用的循环之一，它是利用每次迭代之后更新计数器来控制循环的次数。</p><p>for 语法格式：</p><blockquote><p>for(int i=0;i&lt;n;i++){ …… }</p></blockquote><p>基础语法使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 循环中可使用关键字 continue，跳过后续操作，继续下一次迭代。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span></span><br><span class="line">i=<span class="number">3</span></span><br></pre></td></tr></table></figure><p>如结果所示，第二次循环就会跳过，执行下一次循环。</p><p><strong>for 注意事项</strong></p><p>在循环中检查两个浮点数是否相等要格外小心，例如下面代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">float</span> i = <span class="number">0</span>; i != <span class="number">1</span>; i += <span class="number">0.1</span>) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环永远不会停下来，由于舍入误差，因为 0.1 无法精确的用二级制表示，所以上面代码到 0.9000001 之后，会直接跳到 1.0000001，不会等于 1，所以循环就永远不会停下来。</p><h4 id="多重选择"><a href="#多重选择" class="headerlink" title="多重选择"></a>多重选择</h4><p>switch 的特点是可以判断多个条件，if 的特点是执行少量判断，它们两个刚好形成互补的关系。</p><p>switch 语法格式：</p><blockquote><p>switch(……){ case 1: …… break; …… default: …… break; }</p></blockquote><p>switch 基础使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;等于1&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;等于2&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;等于3&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;等于其他&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可用于 case 的类型有：</p><ul><li>byte、char、short、int</li><li>枚举</li><li>字符串（Java SE 7 新加入）</li></ul><p><strong>switch 注意事项</strong></p><p>switch 使用时，每个选项最末尾一定不要忘记加 break 关键字，否则会执行多个条件。</p><p>案例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;等于1&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;等于2&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;等于3&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;等于其他&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">等于<span class="number">1</span></span><br><span class="line">等于<span class="number">2</span></span><br><span class="line">等于<span class="number">3</span></span><br><span class="line">等于其他</span><br></pre></td></tr></table></figure><p>所以使用 switch 时，每个选项的末尾一定得加 break 关键字。</p><h3 id="相关面试题-3"><a href="#相关面试题-3" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="Java-中-i-和-i-有什么区别？"><a href="#Java-中-i-和-i-有什么区别？" class="headerlink" title="Java 中 i++ 和 ++i 有什么区别？"></a>Java 中 i++ 和 ++i 有什么区别？</h4><p>答：i 先赋值再运算；i 先运算再赋值。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i2 = i++;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j2 = ++j;</span><br><span class="line">System.out.println(<span class="string">&quot;i2=&quot;</span> + i2);</span><br><span class="line">System.out.println(<span class="string">&quot;j2=&quot;</span> + j2);</span><br></pre></td></tr></table></figure><p>输出结果：i2=0，j2=1</p><h4 id="以下代码-i-的值是多少？"><a href="#以下代码-i-的值是多少？" class="headerlink" title="以下代码 i 的值是多少？"></a>以下代码 i 的值是多少？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = i++;</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><p>答：i=0</p><p>题目解析：因为 Java 虚拟机在执行 i++ 时，把这个值有赋值给了 i，而 i++ 是先赋值再相加，所以这个时候 i 接收到的结果自然是 0 了。</p><h4 id="以下代码-i2-和-i3-的值分别为多少？"><a href="#以下代码-i2-和-i3-的值分别为多少？" class="headerlink" title="以下代码 i2 和 i3 的值分别为多少？"></a>以下代码 i2 和 i3 的值分别为多少？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i2 = i++;</span><br><span class="line"><span class="keyword">int</span> i3 = ++i;</span><br></pre></td></tr></table></figure><p>答：i2=0，i3=2</p><h4 id="以下代码能不能正常执行？"><a href="#以下代码能不能正常执行？" class="headerlink" title="以下代码能不能正常执行？"></a>以下代码能不能正常执行？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">true</span>) System.out.println(<span class="string">&quot;laowang&quot;</span>);</span><br></pre></td></tr></table></figure><p>答：可以正常执行，其中判断条件的括号不能省略，大括号是可以省略的（作者并不建议为了省代码的而牺牲代码的可读性）。</p><h4 id="以下-switch-执行的结果是什么？"><a href="#以下-switch-执行的结果是什么？" class="headerlink" title="以下 switch 执行的结果是什么？"></a>以下 switch 执行的结果是什么？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span> (num) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        System.out.print(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.print(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.print(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        System.out.print(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.print(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：123default</p><h4 id="switch-能否用于-byte-类型的判断上？能否用于-long-类型的判断上？"><a href="#switch-能否用于-byte-类型的判断上？能否用于-long-类型的判断上？" class="headerlink" title="switch 能否用于 byte 类型的判断上？能否用于 long 类型的判断上？"></a>switch 能否用于 byte 类型的判断上？能否用于 long 类型的判断上？</h4><p>答：switch 支持 byte 类型的判断，不支持 long 类型的判断。</p><p>题目解析：switch 支持的全部类型（JDK 8）：char、byte、short、int、Charachter、Byte、Short、Integer、String、enum。</p><h4 id="while-必须配合-break-一起使用的说法正确吗？"><a href="#while-必须配合-break-一起使用的说法正确吗？" class="headerlink" title="while 必须配合 break 一起使用的说法正确吗？"></a>while 必须配合 break 一起使用的说法正确吗？</h4><p>答：错误，while 可以单独使用。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    System.out.println(++i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="以下代码可以正常运行吗？为什么？"><a href="#以下代码可以正常运行吗？为什么？" class="headerlink" title="以下代码可以正常运行吗？为什么？"></a>以下代码可以正常运行吗？为什么？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(++i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：可以正常运行，这里的 return 和 break 的效果是一致的，while 可以配合 return 或 break 一起使用。</p><h4 id="以下的程序执行结果什么？"><a href="#以下的程序执行结果什么？" class="headerlink" title="以下的程序执行结果什么？"></a>以下的程序执行结果什么？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  System.out.println(++i);</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>答：编译器报错，do/while 之后必须使用分号 <code>;</code> 结尾。</p><h4 id="以下程序输出的结果是？"><a href="#以下程序输出的结果是？" class="headerlink" title="以下程序输出的结果是？"></a>以下程序输出的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;laowang&quot;</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;laowang&quot;</span>);</span><br><span class="line">System.out.println(s == s2);</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;laowang&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;laowang&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：true,default<br>B：false,default<br>C：false,laowang<br>D：true,laowang</p><p>答：C</p><h4 id="以下代码循环执行了几次？"><a href="#以下代码循环执行了几次？" class="headerlink" title="以下代码循环执行了几次？"></a>以下代码循环执行了几次？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">float</span> i = <span class="number">0</span>; i != <span class="number">10</span>; i += <span class="number">0.1</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：无数次，循环永远不会停下来。由于舍入误差，因为 0.1 无法精确的用二级制表示，所以上面代码到 0.9000001 之后，会直接跳到 1.0000001，不会等于 1，所以循环就永远不会停下来。</p><h4 id="以下代码输出的结果是？-1"><a href="#以下代码输出的结果是？-1" class="headerlink" title="以下代码输出的结果是？"></a>以下代码输出的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = -<span class="number">4</span>;</span><br><span class="line">System.out.println(num % <span class="number">2</span> == <span class="number">1</span> || num % <span class="number">2</span> == -<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>A：1<br>B：-1<br>C：true<br>D：false</p><p>答：D</p><p>题目解析：-4 % 2 = 0 既不等于 1 也不等于 -1，所以结果为 false。</p><h4 id="以下代码输出的结果是？-2"><a href="#以下代码输出的结果是？-2" class="headerlink" title="以下代码输出的结果是？"></a>以下代码输出的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line">num = ((num &amp; <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure><p>A：4<br>B：1<br>C：以上都不是</p><p>答：C</p><p>题目解析：== 运算返回的是 boolean 类型，不能使用 int 接收，所以程序会报错。</p><h2 id="深入了解-Java-中的异常处理-面试题"><a href="#深入了解-Java-中的异常处理-面试题" class="headerlink" title="深入了解 Java 中的异常处理 + 面试题"></a>深入了解 Java 中的异常处理 + 面试题</h2><p>在程序开发中，异常处理也是我们经常使用到的模块，只是平常很少去深究异常模块的一些知识点。比如，try-catch 处理要遵循的原则是什么，finally 为什么总是能执行，try-catch 为什么比较消耗程序的执行性能等问题，我们本讲内容都会给出相应的答案，当然还有面试中经常被问到的异常模块的一些面试题，也是我们本篇要讲解的重点内容。</p><h3 id="异常处理基础介绍"><a href="#异常处理基础介绍" class="headerlink" title="异常处理基础介绍"></a>异常处理基础介绍</h3><p>先来看看<strong>异常处理的语法格式</strong>：</p><blockquote><p>try{ … } catch(Exception e){ … } finally{ … }</p></blockquote><p>其中，</p><ul><li><strong>try</strong>：是用来监测可能会出现异常的代码段。</li><li><strong>catch</strong>：是用来捕获 try 代码块中某些代码引发的异常，如果 try 里面没有异常发生，那么 catch 也一定不会执行。在 Java 语言中，try 后面可以有多个 catch 代码块，用来捕获不同类型的异常，需要注意的是前面的 catch 捕获异常类型一定不能包含后面的异常类型，这样的话，编译器会报错。</li><li><strong>finally</strong>：不论 try-catch 如何执行，finally 一定是最后执行的代码块，所有通常用来处理一些资源的释放，比如关闭数据库连接、关闭打开的系统资源等。</li></ul><p><strong>异常处理的基本使用</strong>，具体可以参考下面的代码段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多 catch 的使用</strong>，具体可以参考下面的代码段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i = Integer.parseInt(<span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException ae) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ArithmeticException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException ne) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;NullPointerException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是 Java 虚拟机会从上往下匹配错误类型，因此前面的 catch 异常类型不能包含后面的异常类型。比如上面的代码如果把 Exception 放在最前面编译器就会报错，具体可以参考下面的图片。</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/5f929c30-be47-11e9-b285-b7b5dec36e68"></p><h3 id="异常处理的发展"><a href="#异常处理的发展" class="headerlink" title="异常处理的发展"></a>异常处理的发展</h3><p>随着 Java 语言的发展，JDK 7 的时候引入了一些更加便利的特性，用来更方便的处理异常信息，如 try-with-resources 和 multiple catch，具体可以参考下面的代码段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;&quot;</span>);</span><br><span class="line">     FileWriter fileWriter = <span class="keyword">new</span> FileWriter(<span class="string">&quot;&quot;</span>)) &#123; <span class="comment">// try-with-resources</span></span><br><span class="line">    System.out.println(<span class="string">&quot;try&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | NullPointerException e) &#123; <span class="comment">// multiple catch</span></span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常处理的基本原则"><a href="#异常处理的基本原则" class="headerlink" title="异常处理的基本原则"></a>异常处理的基本原则</h3><p>先来看下面这段代码，有没有发现一些问题？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">int</span> i = Integer.parseInt(<span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的这段代码，看似“正常”，却违背了异常处理的两个基本原则：</p><ul><li>第一，尽量不要捕获通用异常，也就是像 Exception 这样的异常，而是应该捕获特定异常，这样更有助于你发现问题；</li><li>第二，不要忽略异常，像上面的这段代码只是加了 catch，但没有进行如何的错误处理，信息就已经输出了，这样在程序出现问题的时候，根本找不到问题出现的原因，因此要切记不要直接忽略异常。</li></ul><h3 id="异常处理对程序性能的影响"><a href="#异常处理对程序性能的影响" class="headerlink" title="异常处理对程序性能的影响"></a>异常处理对程序性能的影响</h3><p>异常处理固然好用，但一定不要滥用，比如下面的代码片段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 com.alibaba.fastjson</span></span><br><span class="line">JSONArray array = <span class="keyword">new</span> JSONArray();</span><br><span class="line">String jsonStr = <span class="string">&quot;&#123;&#x27;name&#x27;:&#x27;laowang&#x27;&#125;&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    array = JSONArray.parseArray(jsonStr);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    array.add(JSONObject.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(array.size());</span><br></pre></td></tr></table></figure><p>这段代码是借助了 try-catch 去处理程序的业务逻辑，通常是不可取的，原因包括下列两个方面。</p><ul><li>try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行优化，因此建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码；与此同时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if/else、switch）要低效。</li><li>Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。</li></ul><p>以上使用 try-catch 处理业务的代码，可以修改为下列代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 com.alibaba.fastjson</span></span><br><span class="line">JSONArray array = <span class="keyword">new</span> JSONArray();</span><br><span class="line">String jsonStr = <span class="string">&quot;&#123;&#x27;name&#x27;:&#x27;laowang&#x27;&#125;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != jsonStr &amp;&amp; !jsonStr.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">    String firstChar = jsonStr.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (firstChar.equals(<span class="string">&quot;&#123;&quot;</span>)) &#123;</span><br><span class="line">        array.add(JSONObject.parse(jsonStr));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstChar.equals(<span class="string">&quot;[&quot;</span>)) &#123;</span><br><span class="line">        array = JSONArray.parseArray(jsonStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(array.size());</span><br></pre></td></tr></table></figure><h3 id="相关面试题-4"><a href="#相关面试题-4" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="try-可以单独使用吗？"><a href="#try-可以单独使用吗？" class="headerlink" title="try 可以单独使用吗？"></a>try 可以单独使用吗？</h4><p>答：try 不能单独使用，否则就失去了 try 的意义和价值。</p><h4 id="以下-try-catch-可以正常运行吗？"><a href="#以下-try-catch-可以正常运行吗？" class="headerlink" title="以下 try-catch 可以正常运行吗？"></a>以下 try-catch 可以正常运行吗？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;last&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：不能正常运行，catch 后必须包含异常信息，如 catch (Exception e)。</p><h4 id="以下-try-finally-可以正常运行吗？"><a href="#以下-try-finally-可以正常运行吗？" class="headerlink" title="以下 try-finally 可以正常运行吗？"></a>以下 try-finally 可以正常运行吗？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;last&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：可以正常运行。</p><h4 id="以下代码-catch-里也发生了异常，程序会怎么执行？"><a href="#以下代码-catch-里也发生了异常，程序会怎么执行？" class="headerlink" title="以下代码 catch 里也发生了异常，程序会怎么执行？"></a>以下代码 catch 里也发生了异常，程序会怎么执行？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;try&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">2</span> / <span class="number">0</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;catch&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;main&quot;</span>);</span><br></pre></td></tr></table></figure><p>答：程序会打印出 finally 之后抛出异常并终止运行。</p><h4 id="以下代码-finally-里也发生了异常，程序会怎么运行？"><a href="#以下代码-finally-里也发生了异常，程序会怎么运行？" class="headerlink" title="以下代码 finally 里也发生了异常，程序会怎么运行？"></a>以下代码 finally 里也发生了异常，程序会怎么运行？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;try&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;catch&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span> / <span class="number">0</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;main&quot;</span>);</span><br></pre></td></tr></table></figure><p>答：程序在输出 try 之后抛出异常并终止运行，不会再执行 finally 异常之后的代码。</p><h4 id="常见的运行时异常都有哪些？"><a href="#常见的运行时异常都有哪些？" class="headerlink" title="常见的运行时异常都有哪些？"></a>常见的运行时异常都有哪些？</h4><p>答：常见的运行时异常如下：</p><ul><li>java.lang.NullPointerException 空指针异常；出现原因：调用了未经初始化的对象或者是不存在的对象；</li><li>java.lang.ClassNotFoundException 指定的类找不到；出现原因：类的名称和路径加载错误，通常是程序</li></ul><p>试图通过字符串来加载某个类时引发的异常；</p><ul><li>java.lang.NumberFormatException 字符串转换为数字异常；出现原因：字符型数据中包含非数字型字符；</li><li>java.lang.IndexOutOfBoundsException 数组角标越界异常，常见于操作数组对象时发生；</li><li>java.lang.ClassCastException 数据类型转换异常；</li><li>java.lang.NoClassDefFoundException 未找到类定义错误；</li><li>java.lang.NoSuchMethodException 方法不存在异常；</li><li>java.lang.IllegalArgumentException 方法传递参数错误。</li></ul><h4 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a>Exception 和 Error 有什么区别？</h4><p>答：Exception 和 Error 都属于 Throwable 的子类，在 Java 中只有 Throwable 及其之类才能被捕获或抛出，它们的区别如下：</p><ul><li>Exception（异常）是程序正常运行中，可以预期的意外情况，并且可以使用 try/catch 进行捕获处理的。Exception 又分为运行时异常（Runtime Exception）和受检查的异常（Checked Exception），运行时异常编译能通过，但如果运行过程中出现这类未处理的异常，程序会终止运行；而受检查的异常，要么用 try/catch 捕获，要么用 throws 字句声明抛出，否则编译不会通过。</li><li>Error（错误）是指突发的非正常情况，通常是不可以恢复的，比如 Java 虚拟机内存溢出，诸如此类的问题叫做 Error。</li></ul><h4 id="throw-和-throws-的区别是什么？"><a href="#throw-和-throws-的区别是什么？" class="headerlink" title="throw 和 throws 的区别是什么？"></a>throw 和 throws 的区别是什么？</h4><p>答：它们的区别如下：</p><ul><li>throw 语句用在方法体内，表示抛出异常由方法体内的语句处理，执行 throw 一定是抛出了某种异常；</li><li>throws 语句用在方法声明的后面，该方法的调用者要对异常进行处理，throws 代表可能会出现某种异常，并不一定会发生这种异常。</li></ul><h4 id="Integer-parseInt-null-和-Double-parseDouble-null-抛出的异常一样吗？为什么？"><a href="#Integer-parseInt-null-和-Double-parseDouble-null-抛出的异常一样吗？为什么？" class="headerlink" title="Integer.parseInt(null) 和 Double.parseDouble(null) 抛出的异常一样吗？为什么？"></a>Integer.parseInt(null) 和 Double.parseDouble(null) 抛出的异常一样吗？为什么？</h4><p>答：Integer.parseInt(null) 和 Double.parseDouble(null) 抛出的异常类型不一样，如下所示：</p><ul><li>Integer.parseInt(null) 抛出的异常是 NumberFormatException；</li><li>Double.parseDouble(null) 抛出的异常是 NullPointerException。</li></ul><p>至于为什么会产生不同的异常，其实没有特殊的原因，主要是由于这两个功能是不同人开发的，因而就产生了两种不同的异常信息。</p><h4 id="NoClassDefFoundError-和-ClassNoFoundException-有什么区别？"><a href="#NoClassDefFoundError-和-ClassNoFoundException-有什么区别？" class="headerlink" title="NoClassDefFoundError 和 ClassNoFoundException 有什么区别？"></a>NoClassDefFoundError 和 ClassNoFoundException 有什么区别？</h4><ul><li>NoClassDefFoundError 是 Error（错误）类型，而 ClassNoFoundExcept 是 Exception（异常）类型；</li><li>ClassNoFoundExcept 是 Java 使用 Class.forName 方法动态加载类，没有加载到，就会抛出 ClassNoFoundExcept 异常；</li><li>NoClassDefFoundError 是 Java 虚拟机或者 ClassLoader 尝试加载类的时候却找不到类订阅导致的，也就是说要查找的类在编译的时候是存在的，运行的时候却找不到，这个时候就会出现 NoClassDefFoundError 的错误。</li></ul><h4 id="使用-try-catch-为什么比较耗费性能？"><a href="#使用-try-catch-为什么比较耗费性能？" class="headerlink" title="使用 try-catch 为什么比较耗费性能？"></a>使用 try-catch 为什么比较耗费性能？</h4><p>答：这个问题要从 JVM（Java 虚拟机）层面找答案了。首先 Java 虚拟机在构造异常实例的时候需要生成该异常的栈轨迹，这个操作会逐一访问当前线程的栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常等信息，这就是使用异常捕获耗时的主要原因了。</p><h4 id="常见的-OOM-原因有哪些？"><a href="#常见的-OOM-原因有哪些？" class="headerlink" title="常见的 OOM 原因有哪些？"></a>常见的 OOM 原因有哪些？</h4><p>答：常见的 OOM 原因有以下几个：</p><ul><li>数据库资源没有关闭；</li><li>加载特别大的图片；</li><li>递归次数过多，并一直操作未释放的变量。</li></ul><h4 id="以下程序的返回结果是？"><a href="#以下程序的返回结果是？" class="headerlink" title="以下程序的返回结果是？"></a>以下程序的返回结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span> / <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：0</p><p>B：2</p><p>C：3</p><p>D：1</p><p>答：3</p><p>题目解析：程序最后一定会执行 finally 里的代码，会把之前的结果覆盖为 3。</p><h4 id="finally、finalize-的区别是什么？"><a href="#finally、finalize-的区别是什么？" class="headerlink" title="finally、finalize 的区别是什么？"></a>finally、finalize 的区别是什么？</h4><p>答：finally、finalize 的区别如下：</p><ul><li>finally 是异常处理语句的一部分，表示总是执行；</li><li>finalize 是 Object 类的一个方法，子类可以覆盖该方法以实现资源清理工作，垃圾回收之前会调用此方法。</li></ul><h4 id="为什么-finally-总能被执行？"><a href="#为什么-finally-总能被执行？" class="headerlink" title="为什么 finally 总能被执行？"></a>为什么 finally 总能被执行？</h4><p>答：finally 总会被执行，都是编译器的作用，因为编译器在编译 Java 代码时，会复制 finally 代码块的内容，然后分别放在 try-catch 代码块所有的正常执行路径及异常执行路径的出口中，这样 finally 才会不管发生什么情况都会执行。</p><h2 id="玩转时间操作-面试题"><a href="#玩转时间操作-面试题" class="headerlink" title="玩转时间操作 + 面试题"></a>玩转时间操作 + 面试题</h2><p>在 JDK 8 之前，Java 语言为我们提供了两个类用于操作时间，它们分别是：java.util.Date 和 java.util.Calendar，但在 JDK 8 的时候为了解决旧时间操作类的一些缺陷，提供了几个新的类，用于操作时间和日期，它们分别是：LocalTime、LocalDateTime、Instant，都位于 java.time 包下。</p><p>时间的操作在我们日常的开发中经常见到，比如，业务数据都要记录创建时间和修改时间，并要把这些时间格式化之后显示到前端页面，再比如我们需要计算业务数据的时间间隔等，都离不开对时间的操作，那如何正确而优雅地使用时间？这就是我们接下来要讨论的话题。</p><h3 id="时间基础知识科普"><a href="#时间基础知识科普" class="headerlink" title="时间基础知识科普"></a>时间基础知识科普</h3><h4 id="格林威治时间"><a href="#格林威治时间" class="headerlink" title="格林威治时间"></a>格林威治时间</h4><p>格林威治（又译格林尼治）是英国伦敦南郊原格林威治天文台的所在地，它是世界计算时间和地球经度的起点，国际经度会议 1884 年在美国华盛顿召开，会上通过协议，以经过格林威治天文台的经线为零度经线（即本初子午线），作为地球经度的起点，并以格林威治为“世界时区”的起点。</p><h4 id="格林威治时间和北京时间的关系"><a href="#格林威治时间和北京时间的关系" class="headerlink" title="格林威治时间和北京时间的关系"></a>格林威治时间和北京时间的关系</h4><p>格林威治时间被定义为世界时间，就是 0 时区，北京是东八区。也就是说格林威治时间的 1 日 0 点，对应到北京的时间就是 1 日 8 点。</p><h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><p>时间戳是指格林威治时间 1970-01-01 00:00:00（北京时间 1970-01-01 08:00:00）起至现在的总秒数。</p><h3 id="JDK-8-之前的时间操作"><a href="#JDK-8-之前的时间操作" class="headerlink" title="JDK 8 之前的时间操作"></a>JDK 8 之前的时间操作</h3><h4 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(date);</span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">Date time = calendar.getTime();</span><br><span class="line">System.out.println(time);</span><br></pre></td></tr></table></figure><h4 id="获取时间戳"><a href="#获取时间戳" class="headerlink" title="获取时间戳"></a>获取时间戳</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> ts = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">System.out.println(ts);</span><br><span class="line"><span class="keyword">long</span> ts2 = System.currentTimeMillis();</span><br><span class="line">System.out.println(ts2);</span><br><span class="line"><span class="keyword">long</span> ts3 = Calendar.getInstance().getTimeInMillis();</span><br><span class="line">System.out.println(ts3);</span><br></pre></td></tr></table></figure><h4 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(sf.format(<span class="keyword">new</span> Date()));  <span class="comment">// output:2019-08-16 21:46:22</span></span><br></pre></td></tr></table></figure><p>SimpleDateFormat 构造参数的含义，请参考以下表格信息：</p><table><thead><tr><th align="left"><strong>字符</strong></th><th align="left"><strong>含义</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">y</td><td align="left">年</td><td align="left">yyyy-1996</td></tr><tr><td align="left">M</td><td align="left">月</td><td align="left">MM-07</td></tr><tr><td align="left">d</td><td align="left">月中的天数</td><td align="left">dd-02</td></tr><tr><td align="left">D</td><td align="left">年中的天数</td><td align="left">121</td></tr><tr><td align="left">E</td><td align="left">星期几</td><td align="left">星期四</td></tr><tr><td align="left">H</td><td align="left">小时数（0-23）</td><td align="left">HH-23</td></tr><tr><td align="left">h</td><td align="left">小时数（1-12）</td><td align="left">hh-11</td></tr><tr><td align="left">m</td><td align="left">分钟数</td><td align="left">mm-02</td></tr><tr><td align="left">s</td><td align="left">秒数</td><td align="left">ss-03</td></tr><tr><td align="left">Z</td><td align="left">时区</td><td align="left">+0800</td></tr></tbody></table><p>使用示例：</p><ul><li>获取星期几：new SimpleDateFormat(“E”).format(new Date())</li><li>获取当前时区：new SimpleDateFormat(“Z”).format(new Date*())</li></ul><p><strong>注意事项</strong>：在多线程下 SimpleDateFormat 是非线程安全的，因此在使用 SimpleDateFormat 时要注意这个问题。在多线程下，如果使用不当，可能会造成结果不对或内存泄漏等问题。</p><h4 id="时间转换"><a href="#时间转换" class="headerlink" title="时间转换"></a>时间转换</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">// String 转 Date</span></span><br><span class="line">String str = <span class="string">&quot;2019-10-10 10:10:10&quot;</span>;</span><br><span class="line">System.out.println(sf.parse(str));</span><br><span class="line"><span class="comment">//时间戳的字符串 转 Date</span></span><br><span class="line">String tsString = <span class="string">&quot;1556788591462&quot;</span>;</span><br><span class="line"><span class="comment">// import java.sql</span></span><br><span class="line">Timestamp ts = <span class="keyword">new</span> Timestamp(Long.parseLong(tsString)); <span class="comment">// 时间戳的字符串转 Date</span></span><br><span class="line">System.out.println(sf.format(ts));</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：当使用 SimpleDateFormat.parse() 方法进行时间转换的时候，SimpleDateFormat 的构造函数必须和待转换字符串格式一致。</p><h4 id="获得昨天此刻时间"><a href="#获得昨天此刻时间" class="headerlink" title="获得昨天此刻时间"></a>获得昨天此刻时间</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">calendar.add(Calendar.DATE, -<span class="number">1</span>);</span><br><span class="line">System.out.println(calendar.getTime());</span><br></pre></td></tr></table></figure><h3 id="JDK-8-时间操作"><a href="#JDK-8-时间操作" class="headerlink" title="JDK 8 时间操作"></a>JDK 8 时间操作</h3><p>JDK 8 对时间操作新增了三个类：LocalDateTime、LocalDate、LocalTime。</p><ul><li>LocalDate 只包含日期，不包含时间，不可变类，且线程安全。</li><li>LocalTime 只包含时间，不包含日期，不可变类，且线程安全。</li><li>LocalDateTime 既包含了时间又包含了日期，不可变类，且线程安全。</li></ul><p><strong>线程安全性</strong></p><p>值得一提的是 JDK 8 中新增的这三个时间相关的类，都是线程安全的，这极大地降低了多线程下代码开发的风险。</p><h4 id="获取时间-1"><a href="#获取时间-1" class="headerlink" title="获取时间"></a>获取时间</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取日期</span></span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">System.out.println(localDate);    <span class="comment">// output:2019-08-16</span></span><br><span class="line"><span class="comment">// 获取时间</span></span><br><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line">System.out.println(localTime);    <span class="comment">// output:21:09:13.708</span></span><br><span class="line"><span class="comment">// 获取日期和时间</span></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(localDateTime);    <span class="comment">// output:2019-08-16T21:09:13.708</span></span><br></pre></td></tr></table></figure><h4 id="获取时间戳-1"><a href="#获取时间戳-1" class="headerlink" title="获取时间戳"></a>获取时间戳</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> milli = Instant.now().toEpochMilli(); <span class="comment">// 获取当前时间戳（精确到毫秒）</span></span><br><span class="line"><span class="keyword">long</span> second = Instant.now().getEpochSecond(); <span class="comment">// 获取当前时间戳（精确到秒）</span></span><br><span class="line">System.out.println(milli);  <span class="comment">// output:1565932435792</span></span><br><span class="line">System.out.println(second); <span class="comment">// output:1565932435</span></span><br></pre></td></tr></table></figure><h4 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间格式化①</span></span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">String timeFormat = dateTimeFormatter.format(LocalDateTime.now());</span><br><span class="line">System.out.println(timeFormat);  <span class="comment">// output:2019-08-16 21:15:43</span></span><br><span class="line"><span class="comment">// 时间格式化②</span></span><br><span class="line">String timeFormat2 = LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">System.out.println(timeFormat2);    <span class="comment">// output:2019-08-16 21:17:48</span></span><br></pre></td></tr></table></figure><h4 id="时间转换-1"><a href="#时间转换-1" class="headerlink" title="时间转换"></a>时间转换</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String timeStr = <span class="string">&quot;2019-10-10 06:06:06&quot;</span>;</span><br><span class="line">LocalDateTime dateTime = LocalDateTime.parse(timeStr,DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">System.out.println(dateTime);</span><br></pre></td></tr></table></figure><h4 id="获得昨天此刻时间-1"><a href="#获得昨天此刻时间-1" class="headerlink" title="获得昨天此刻时间"></a>获得昨天此刻时间</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime today = LocalDateTime.now();</span><br><span class="line">LocalDateTime yesterday = today.plusDays(-<span class="number">1</span>);</span><br><span class="line">System.out.println(yesterday);</span><br></pre></td></tr></table></figure><h3 id="相关面试题-5"><a href="#相关面试题-5" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="获取当前时间有几种方式？"><a href="#获取当前时间有几种方式？" class="headerlink" title="获取当前时间有几种方式？"></a>获取当前时间有几种方式？</h4><p>答：获取当前时间常见的方式有以下三种：</p><ul><li>new Date()</li><li>Calendar.getInstance().getTime()</li><li>LocalDateTime.now()</li></ul><h4 id="如何获取昨天此刻的时间？"><a href="#如何获取昨天此刻的时间？" class="headerlink" title="如何获取昨天此刻的时间？"></a>如何获取昨天此刻的时间？</h4><p>答：以下为获取昨天此刻时间的两种方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取昨天此刻的时间（JDK 8 以前）</span></span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">c.add(Calendar.DATE,-<span class="number">1</span>);</span><br><span class="line">System.out.println(c.getTime());</span><br><span class="line"><span class="comment">// 获取昨天此刻的时间（JDK 8）</span></span><br><span class="line">LocalDateTime todayTime = LocalDateTime.now();</span><br><span class="line">System.out.println(todayTime.plusDays(-<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h4 id="如何获取本月的最后一天？"><a href="#如何获取本月的最后一天？" class="headerlink" title="如何获取本月的最后一天？"></a>如何获取本月的最后一天？</h4><p>答：以下为获取本月最后一天的两种方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取本月的最后一天（JDK 8 以前）</span></span><br><span class="line">Calendar ca = Calendar.getInstance();</span><br><span class="line">ca.set(Calendar.DAY_OF_MONTH, ca.getActualMaximum(Calendar.DAY_OF_MONTH));</span><br><span class="line">System.out.println(ca.getTime());</span><br><span class="line"><span class="comment">// 获取本月的最后一天（JDK 8）</span></span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">System.out.println(today.with(TemporalAdjusters.lastDayOfMonth()));</span><br></pre></td></tr></table></figure><h4 id="获取当前时间的时间戳有几种方式？"><a href="#获取当前时间的时间戳有几种方式？" class="headerlink" title="获取当前时间的时间戳有几种方式？"></a>获取当前时间的时间戳有几种方式？</h4><p>答：以下为获取当前时间戳的几种方式：</p><ul><li>System.currentTimeMillis()</li><li>new Date().getTime()</li><li>Calendar.getInstance().getTime().getTime()</li><li>Instant.now().toEpochMilli()</li><li>LocalDateTime.now().toInstant(ZoneOffset.of(“+8”)).toEpochMilli()</li></ul><p>其中，第四种和第五种方式是 JDK 8 才新加的。</p><h4 id="如何优雅地计算两个时间的相隔时间？"><a href="#如何优雅地计算两个时间的相隔时间？" class="headerlink" title="如何优雅地计算两个时间的相隔时间？"></a>如何优雅地计算两个时间的相隔时间？</h4><p>答：JDK 8 中可以使用 Duration 类来优雅地计算两个时间的相隔时间，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime dt1 = LocalDateTime.now();</span><br><span class="line">LocalDateTime dt2 = dt1.plusSeconds(<span class="number">60</span>);</span><br><span class="line">Duration duration = Duration.between(dt1, dt2);</span><br><span class="line">System.out.println(duration.getSeconds());  <span class="comment">// output:60</span></span><br></pre></td></tr></table></figure><h4 id="如何优雅地计算两个日期的相隔日期？"><a href="#如何优雅地计算两个日期的相隔日期？" class="headerlink" title="如何优雅地计算两个日期的相隔日期？"></a>如何优雅地计算两个日期的相隔日期？</h4><p>答：JDK 8 中可以使用 Period 类来优雅地计算两个日期的相隔日期，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate d1 = LocalDate.now();</span><br><span class="line">LocalDate d2 = d1.plusDays(<span class="number">2</span>);</span><br><span class="line">Period period = Period.between(d1, d2);</span><br><span class="line">System.out.println(period.getDays());   <span class="comment">//output:2</span></span><br></pre></td></tr></table></figure><h4 id="SimpleDateFormat-是线程安全的吗？为什么？"><a href="#SimpleDateFormat-是线程安全的吗？为什么？" class="headerlink" title="SimpleDateFormat 是线程安全的吗？为什么？"></a>SimpleDateFormat 是线程安全的吗？为什么？</h4><p>答：SimpleDateFormat 是非线程安全的。因为查看 SimpleDateFormat 的源码可以得知，所有的格式化和解析，都需要通过一个中间对象进行转换，这个中间对象就是 Calendar，这样的话就造成非线程安全。试想一下当我们有多个线程操作同一个 Calendar 的时候后来的线程会覆盖先来线程的数据，那最后其实返回的是后来线程的数据，因此 SimpleDateFormat 就成为了非线程的了。</p><h4 id="怎么保证-SimpleDateFormat-的线程安全？"><a href="#怎么保证-SimpleDateFormat-的线程安全？" class="headerlink" title="怎么保证 SimpleDateFormat 的线程安全？"></a>怎么保证 SimpleDateFormat 的线程安全？</h4><p>答：保证 SimpleDateFormat 线程安全的方式如下：</p><ul><li>使用 Synchronized，在需要时间格式化的操作使用 Synchronized 关键字进行包装，保证线程堵塞格式化；</li><li>手动加锁，把需要格式化时间的代码，写到加锁部分，相对 Synchronized 来说，编码效率更低，性能略好，代码风险较大（风险在于不要忘记在操作的最后，手动释放锁）；</li><li>使用 JDK 8 的 DateTimeFormatter 替代 SimpleDateFormat。</li></ul><h4 id="JDK-8-中新增的时间类都有哪些优点？"><a href="#JDK-8-中新增的时间类都有哪些优点？" class="headerlink" title="JDK 8 中新增的时间类都有哪些优点？"></a>JDK 8 中新增的时间类都有哪些优点？</h4><p>答：JDK 8 中的优点具体有以下几个优点，如下：</p><ul><li>线程安全性</li><li>使用的便利性（如获取当前时间戳的便利性、增减日期的便利性等）</li><li>编写代码更简单优雅，如当前时间的格式化：LocalDateTime.now().format(DateTimeFormatter.ofPattern(“yyyy-MM-dd HH:mm:ss”));</li></ul><h4 id="如何比较两个时间（Date）的大小？"><a href="#如何比较两个时间（Date）的大小？" class="headerlink" title="如何比较两个时间（Date）的大小？"></a>如何比较两个时间（Date）的大小？</h4><p>答：时间比较有以下三种方式：</p><ul><li>获取两个时间的时间戳，得到两个 long 类型的变量，两个变量相减，通过结果的正负值来判断大小；</li><li>通过 Date 自带的 before()、after()、equals() 等方法比较，代码示例 date1.before(date2)；</li><li>通过 compareTo() 方法比较，代码示例：date1.compareTo(date2)，返回值 -1 表示前一个时间比后一个时间小，0 表示两个时间相等，1 表示前一个时间大于后一个时间。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JDK 8 之前使用 java.util.Date 和 java.util.Calendar 来操作时间，它们有两个很明显的缺点，第一，非线程安全；第二，API 调用不方便。JDK 8 新增了几个时间操作类 java.time 包下的 LocalDateTime、LocalDate、LocalTime、Duration（计算相隔时间）、Period（计算相隔日期）和 DateTimeFormatter，提供了多线程下的线程安全和易用性，让我们可以更好的操作时间。</p><h2 id="数组和排序算法的应用-面试题"><a href="#数组和排序算法的应用-面试题" class="headerlink" title="数组和排序算法的应用 + 面试题"></a>数组和排序算法的应用 + 面试题</h2><h3 id="数组的定义与使用"><a href="#数组的定义与使用" class="headerlink" title="数组的定义与使用"></a>数组的定义与使用</h3><p>数组是 Java 编程中最重要的数据结构之一，也是最基本的数据结构，Java 中的常用集合 ArrayList、HashMap 等内部的实现都使用到了数组结构。数组是只能用来存储一种类型的集合，可以通过下标访问数值中的所有元素。</p><p>数组的声明方式有以下两种，如整数型数组，请参考下面代码：</p><ul><li>方式一：<code>int[] arr;</code></li><li>方式二：<code>int arr[];</code></li></ul><p>大部分情况下，我们会使用第一种方式 int[] arr; 来声明数组。</p><p><strong>数组初始化</strong></p><p>数组可使用 new int[n] 进行初始化，每个元素初始化为 0，声明了 n 个元素。也可以直接赋值，例如 new int[]{ 1,2,3…… }，具体用法可参照下面代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化方式一</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 初始化方式二</span></span><br><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 初始化方式二的延伸版，可省略 new int[] 直接赋值</span></span><br><span class="line"><span class="keyword">int</span>[] arr3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：在 Java 中，数组初始化如果声明了数组长度，则不能直接赋值。例如，int[] arr = new int[5]{1, 2, 3, 4, 5}; 给这段初始化数组长度并赋值时，编译器会报错，编译不通过。</p></blockquote><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p>数组遍历的常见方式有三种：传统的 for 循环、for each 遍历、还有 JDK 8 中新增的 Lambda 表达式。具体的实现请参考以下实例。</p><p>方式一：传统 for 循环</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">// 方式一：传统 for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：for each</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">// 方式二：for each</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式三：JDK 8 中的 Lambda 表达式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">// 方式三：jdk 8 Lambda</span></span><br><span class="line">Arrays.asList(arr).forEach(x -&gt; System.out.println(x));</span><br></pre></td></tr></table></figure><p>其中 for each 的方式，写法更简洁，也更不容易出错，不必为数组的越界而担心（大于元素的最大下标值）。</p><blockquote><p><strong>注意</strong>：数组的访问是从 0 开始，而不是 1 开始，也就是第一个元素的获取是 arr[0]，而非 arr[1]。</p></blockquote><h3 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h3><p>数组拷贝使用的是 Arrays.copyof() 方法，具体实现请参考下面代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr2 = Arrays.copyOf(arr, arr.length);</span><br><span class="line">System.out.println(Arrays.toString(arr2));</span><br></pre></td></tr></table></figure><p>程序执行结果：[3, 4, 9]</p><blockquote><p><strong>注意</strong>：Arrays.copyOf(array,newLength) 第二个参数 newLength 表示声明此数组的长度，可以比拷贝的数组的长度长，多出来的元素会初始化为 0 值。</p></blockquote><h3 id="数组填充与合并"><a href="#数组填充与合并" class="headerlink" title="数组填充与合并"></a>数组填充与合并</h3><h5 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a><strong>数组填充</strong></h5><p>即为每个元素统一赋值，使用 Arrays.fill() 进行数组填充，具体实现请参考下面代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">Arrays.fill(arr, <span class="number">6</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure><p>程序执行结果：[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]</p><blockquote><p><strong>注意</strong>：使用 Arrays.fill() 会覆盖原有的值，即使数组之前有赋值操作，也会被覆盖。</p></blockquote><h5 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a><strong>数组合并</strong></h5><p>使用 org.apache.commons.lang3.ArrayUtils.addAll() 方法，具体实现请参考下面代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr2 = &#123;<span class="number">66</span>, <span class="number">88</span>&#125;;</span><br><span class="line"><span class="comment">// 合并数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr3 = org.apache.commons.lang3.ArrayUtils.addAll(arr, arr2);</span><br><span class="line">System.out.println(Arrays.toString(arr3));</span><br></pre></td></tr></table></figure><p>程序执行结果：[2, 8, 13, 11, 6, 7, 66, 88]</p><h3 id="排序与算法"><a href="#排序与算法" class="headerlink" title="排序与算法"></a>排序与算法</h3><h5 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a><strong>数组排序</strong></h5><p>使用 Arrays.sort() 方法，具体实现请参考下面代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure><p>程序执行结果：[2, 6, 7, 8, 11, 13]</p><h5 id="数组逆序"><a href="#数组逆序" class="headerlink" title="数组逆序"></a><strong>数组逆序</strong></h5><p>使用 org.apache.commons.lang3.ArrayUtils.reverse(arr) 方法，具体实现请参考下面代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="comment">// 数组正序（排序）</span></span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="comment">// 数组逆序</span></span><br><span class="line">org.apache.commons.lang3.ArrayUtils.reverse(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure><p>程序执行结果：[13, 11, 8, 7, 6, 2]</p><blockquote><p><strong>注意</strong>：org.apache.commons.lang3.ArrayUtils.reverse() 是数组逆序，并不是数组倒序，也就是说 ArrayUtils.reverse() 只会把数组原顺序颠倒输出，并不会自然排序后再倒序输出。</p></blockquote><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h5><p>依次比较相邻的两个数，把较大的值放后面，执行整个循环之后，数组就从小到大进行排列了。具体实现请参考下面代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;排序前：&quot;</span> + Arrays.toString(arr));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 因为冒泡是把每轮循环中较大的数飘到后面，所以是 arr.length-i-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">// 元素交换</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[j + <span class="number">1</span>];</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;排序后：&quot;</span> + Arrays.toString(arr));</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">排序前：[<span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">排序后：[<span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br></pre></td></tr></table></figure><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h5><p>每次从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。具体实现请参考下面代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;排序前：&quot;</span> + Arrays.toString(arr));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">int</span> lowerIndex = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">    <span class="comment">// 找出最小的一个索引</span></span><br><span class="line">    <span class="keyword">if</span> (arr[j] &lt; arr[lowerIndex]) &#123;</span><br><span class="line">      lowerIndex = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 交换</span></span><br><span class="line">  <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">  arr[i] = arr[lowerIndex];</span><br><span class="line">  arr[lowerIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;排序后：&quot;</span> + Arrays.toString(arr));</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">排序前：[<span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">排序后：[<span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br></pre></td></tr></table></figure><p>关于更多的排序算法，后面会有专门的章节进行介绍。</p><h3 id="元素查找"><a href="#元素查找" class="headerlink" title="元素查找"></a>元素查找</h3><p>查找数组是否包含某个值，使用 Arrays.binarySearch() 方法查询。 Arrays.binarySearch() 是利用二分法查询某个值，如果查到包含某值会返回该值的下标，如果没有查到则返回负值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// Arrays.binarySearch() 使用二分法查询某值</span></span><br><span class="line"><span class="keyword">int</span> index = Arrays.binarySearch(arr, <span class="number">5</span>);</span><br><span class="line">System.out.println(index);</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：使用 Arrays.binarySearch 之前一定要先调用 Arrays.sort() 对数组进行排序，否则返回的结果有误。</p></blockquote><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>我们之前使用的数组可以称之为一维数组，而多维数组可以理解为数组的数组，可以用二维数组来举例，二维数组也是一种特殊的多维数组。</p><p>比如我们声明一个二维数组：int[][] arr = new int[2][4];</p><p>这就相当于我们创建了一个两行四列的表，它的使用、赋值与取值，请查看下面代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明二维数组</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">//循环二维数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">        <span class="comment">// 二维数组赋值</span></span><br><span class="line">        arr[i][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二维数组取值</span></span><br><span class="line">System.out.println(arr[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// 打印二维数组</span></span><br><span class="line">System.out.println(Arrays.toString(arr[<span class="number">0</span>]));</span><br><span class="line">System.out.println(Arrays.toString(arr[<span class="number">1</span>]));</span><br></pre></td></tr></table></figure><p>以上程序执行的结果是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="数组类型转换"><a href="#数组类型转换" class="headerlink" title="数组类型转换"></a>数组类型转换</h3><h5 id="字符串转数组"><a href="#字符串转数组" class="headerlink" title="字符串转数组"></a><strong>字符串转数组</strong></h5><p>使用 split 分隔字符串就形成了数组，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;laowang,stone,wanglei&quot;</span>;</span><br><span class="line">String[] arr = str.split(<span class="string">&quot;,&quot;</span>); <span class="comment">// 字符串转数组</span></span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h5 id="数组转字符串"><a href="#数组转字符串" class="headerlink" title="数组转字符串"></a><strong>数组转字符串</strong></h5><p>使用 Arrays.toString() 方法，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;laowang&quot;</span>, <span class="string">&quot;stone&quot;</span>, <span class="string">&quot;wanglei&quot;</span>&#125;;</span><br><span class="line">String str = Arrays.toString(arr);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><p>若要查看更多数组转字符串的方式，请查看本文面试部分的介绍。</p><h5 id="数组转集合"><a href="#数组转集合" class="headerlink" title="数组转集合"></a><strong>数组转集合</strong></h5><p>使用 Arrays.asList() 方法，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strArr = &#123;<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>&#125;;</span><br><span class="line">List list = Arrays.asList(strArr);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h5 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a><strong>集合转数组</strong></h5><p>使用 List.toArrray() 方法，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line"><span class="comment">// 集合转换为数组</span></span><br><span class="line">String[] arr = list.toArray(<span class="keyword">new</span> String[list.size()]);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure><h3 id="相关面试题-6"><a href="#相关面试题-6" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="数组和集合有什么区别？"><a href="#数组和集合有什么区别？" class="headerlink" title="数组和集合有什么区别？"></a>数组和集合有什么区别？</h4><p>答：数组和集合的区别如下：</p><ul><li>集合可以存储任意类型的对象数据，数组只能存储同一种数据类型的数据；</li><li>集合的长度是会发生变化的，数组的长度是固定的；</li><li>集合相比数组功能更强大，数组相比集合效率更高。</li></ul><h4 id="以下代码访问数组元素打印的结果是多少？"><a href="#以下代码访问数组元素打印的结果是多少？" class="headerlink" title="以下代码访问数组元素打印的结果是多少？"></a>以下代码访问数组元素打印的结果是多少？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">System.out.println(arr[<span class="number">4</span>]);</span><br></pre></td></tr></table></figure><p>答：程序编译报错，在 Java 中初始化数组时，如果直接给数组赋值，不能声明数组长度；如果声明了数组长度，则不能赋值给数组，否则编译器报错。</p><p>正确的写法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">System.out.println(arr[<span class="number">4</span>]);</span><br></pre></td></tr></table></figure><p>输出的结果为：5，访问元素从 0 开始。</p><h4 id="执行以下代码会输出什么结果？"><a href="#执行以下代码会输出什么结果？" class="headerlink" title="执行以下代码会输出什么结果？"></a>执行以下代码会输出什么结果？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    change(arr);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            arr[i] *= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：输出的结果是 8。</p><p>题目解析：在 Java 中数组本质是引用类型，因此在调用方法中修改数组，就是对原数组本身的修改。</p><h4 id="以下程序打印的结果是多少？"><a href="#以下程序打印的结果是多少？" class="headerlink" title="以下程序打印的结果是多少？"></a>以下程序打印的结果是多少？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">String[] StrArr = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">System.out.println(intArr[<span class="number">1</span>]);</span><br><span class="line">System.out.println(StrArr[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>答：以上程序打印的结果是：0 和 null。</p><p>题目解析：new int[3] 相当于声明了数组的长度为 3，每个元素初始化为 0，而 new String[3] 相当于声明了数组的长度为 3，每个元素初始化为 null。</p><h4 id="数组转换字符串有哪些方式？"><a href="#数组转换字符串有哪些方式？" class="headerlink" title="数组转换字符串有哪些方式？"></a>数组转换字符串有哪些方式？</h4><p>答：数组转换字符串，有以下几种方式。</p><p>方式一：遍历拼接，完整代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;laowang&quot;</span>, <span class="string">&quot;stone&quot;</span>, <span class="string">&quot;wanglei&quot;</span>&#125;;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    sb.append(arr[i]);</span><br><span class="line">    <span class="keyword">if</span> (i != arr.length - <span class="number">1</span>)</span><br><span class="line">        sb.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure><p>方式二：Arrays.toString() 转换，完整代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;laowang&quot;</span>, <span class="string">&quot;stone&quot;</span>, <span class="string">&quot;wanglei&quot;</span>&#125;;</span><br><span class="line">String str2 = Arrays.toString(arr);</span><br><span class="line">System.out.println(str2);</span><br></pre></td></tr></table></figure><p>方式三：StringUtils.join() 转换，完整代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;laowang&quot;</span>, <span class="string">&quot;stone&quot;</span>, <span class="string">&quot;wanglei&quot;</span>&#125;;</span><br><span class="line">String str3 = StringUtils.join(Arrays.asList(arr), <span class="string">&quot;,&quot;</span>); <span class="comment">// 使用英文逗号分隔</span></span><br><span class="line">System.out.println(str3);</span><br></pre></td></tr></table></figure><h4 id="数组遍历有哪几种方式？"><a href="#数组遍历有哪几种方式？" class="headerlink" title="数组遍历有哪几种方式？"></a>数组遍历有哪几种方式？</h4><p>答：常见的数组遍历有以下三种方式。</p><ul><li>传统 for 循环，如 for (int i = 0; i &lt; arr.length; i++) { //…… }</li><li>for each 循环，如 for (int i : arr) { //…… }</li><li>jdk 8 Lambda 方式，如 <code>Integer[] arr = &#123;2, 3, 6, 7, 9&#125;; Arrays._asList_(arr).forEach(x -&gt; System._out_.println(x));</code></li></ul><h4 id="以下数组比较的结果分别是什么？"><a href="#以下数组比较的结果分别是什么？" class="headerlink" title="以下数组比较的结果分别是什么？"></a>以下数组比较的结果分别是什么？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strArr = &#123;<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;pig&quot;</span>, <span class="string">&quot;bird&quot;</span>&#125;;</span><br><span class="line">String[] strArr2 = &#123;<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;pig&quot;</span>, <span class="string">&quot;bird&quot;</span>&#125;;</span><br><span class="line">System.out.println(Arrays.equals(strArr, strArr2));</span><br><span class="line">System.out.println(strArr.equals(strArr2));</span><br><span class="line">System.out.println(strArr == strArr2);</span><br></pre></td></tr></table></figure><p>答：上面代码执行的结果，分别为：true、false、false。</p><p>题目解析：strArr == strArr2 为引用比较，因此结果一定是 false，而数组本身的比较也就是 strArr.equals(strArr2) 为 false 的原因是因为数组没有重写 equals 方法，因此也是引用比较。数组 equals 源码实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 Arrays.equals 的结果之所以是 true 是因为 Arrays.equals 重写了 equals 方法。源代码实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object[] a, Object[] a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a==a2)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a==<span class="keyword">null</span> || a2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> length = a.length;</span><br><span class="line">        <span class="keyword">if</span> (a2.length != length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">            Object o1 = a[i];</span><br><span class="line">            Object o2 = a2[i];</span><br><span class="line">            <span class="keyword">if</span> (!(o1==<span class="keyword">null</span> ? o2==<span class="keyword">null</span> : o1.equals(o2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="以下程序使用-Arrays-binarySearch-返回的结果是-true-还是-false？"><a href="#以下程序使用-Arrays-binarySearch-返回的结果是-true-还是-false？" class="headerlink" title="以下程序使用 Arrays.binarySearch 返回的结果是 true 还是 false？"></a>以下程序使用 Arrays.binarySearch 返回的结果是 true 还是 false？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;pig&quot;</span>, <span class="string">&quot;bird&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> result = Arrays.binarySearch(arr, <span class="string">&quot;bird&quot;</span>);</span><br><span class="line">System.out.println(result == -<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>答：返回的结果是：true。</p><p>题目解析：使用 Arrays.binarySearch 之前一定要先调用 Arrays.sort() 对数组进行排序，否则返回的结果有误，本数组返回的结果是 ﹣1，是因为没有使用排序的结果，正确的使用请查看以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;pig&quot;</span>, <span class="string">&quot;bird&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="keyword">int</span> result = Arrays.binarySearch(arr, <span class="string">&quot;bird&quot;</span>);</span><br><span class="line">System.out.println(result == -<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="Arrays-对象有哪些常用的方法？"><a href="#Arrays-对象有哪些常用的方法？" class="headerlink" title="Arrays 对象有哪些常用的方法？"></a>Arrays 对象有哪些常用的方法？</h4><p>答：Arrays 常用方法如下：</p><ul><li>Arrays.copyOf() 数组拷贝</li><li>Arrays.asList() 数组转为 List 集合</li><li>Arrays.fill() 数组赋值</li><li>Arrays.sort() 数组排序</li><li>Arrays.toString() 数组转字符串</li><li>Arrays.binarySearch() 二分法查询元素</li><li>Arrays.equals() 比较两个数组的值</li></ul><h4 id="查询字符串数组中是否包含某个值有几种方法？"><a href="#查询字符串数组中是否包含某个值有几种方法？" class="headerlink" title="查询字符串数组中是否包含某个值有几种方法？"></a>查询字符串数组中是否包含某个值有几种方法？</h4><p>答：常见查询数组中是否包含某个值有以下两种方式：</p><ul><li>方式一：Arrays.asList(array).contains(“key”);</li><li>方式二：Arrays.binarySearch(array, “key”);</li></ul><p>具体的实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;doc&quot;</span>, <span class="string">&quot;pig&quot;</span>, <span class="string">&quot;cat&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 方式一：Arrays.asList(array).contains</span></span><br><span class="line"><span class="keyword">boolean</span> bool = Arrays.asList(arr).contains(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">System.out.println(bool);</span><br><span class="line"><span class="comment">// 方式二：Arrays.binarySearch</span></span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="keyword">boolean</span> bool2 = Arrays.binarySearch(arr, <span class="string">&quot;cat&quot;</span>) &gt; -<span class="number">1</span>;</span><br><span class="line">System.out.println(bool2);</span><br></pre></td></tr></table></figure><h4 id="如何修改数组的第三个到第五个元素的值为-6？"><a href="#如何修改数组的第三个到第五个元素的值为-6？" class="headerlink" title="如何修改数组的第三个到第五个元素的值为 6？"></a>如何修改数组的第三个到第五个元素的值为 6？</h4><p>答：本题考察的知识点显然不是使用 for 循环修改那么简单，而是考察对 Arrays.fill() 方法的掌握，以下提供了两种实现方式可供参考。</p><p>方式一：for 循环方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrInt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrInt.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">2</span> &amp;&amp; i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        arrInt[i] = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：Arrays.fill() 方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrInt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">Arrays.fill(arrInt, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在 Java 中数组本质是引用类型，数组只能用来存储固定大小的同类型元素。在 Java 中很多集合的内部都是依赖数组实现的，如 ArrayList 和 HashMap 等。数组的冒泡排序和选择排序也是面试常考的内容，很多公司会要求面试者手写冒泡排序。本文也介绍了数组、字符串和集合之间的相互转换，只有掌握好这些技能才能开发出更好的 Java 程序。</p><h2 id="类与-Object-的应用-面试题"><a href="#类与-Object-的应用-面试题" class="headerlink" title="类与 Object 的应用 + 面试题"></a>类与 Object 的应用 + 面试题</h2><h3 id="类介绍"><a href="#类介绍" class="headerlink" title="类介绍"></a>类介绍</h3><p>Java 程序是由若干个类组成的，类也是面向对象编程思想的具体实现。</p><p>以下为类的基本使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃吃吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对外包装属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类引用"><a href="#类引用" class="headerlink" title="类引用"></a>类引用</h4><p>当我们需要使用不同包下的类时，就需要使用 import 导入包或类，这个时候才能正常使用。例如，我们要使用 java.util 下的 ArrayList 就必须使用 <code>import java.util.ArrayList</code>，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入 ArrayList 类</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">importTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类引用的高级用法</strong></p><p>import 还可以导入静态方法和静态域的功能，比如以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入 static 静态域的功能</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">staticTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码也可以顺利的执行，这也是 import 好玩的一个地方。</p><h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><p>在 Java 中访问修饰符有以下四种：</p><ul><li>public</li><li>protected</li><li>默认</li><li>private</li></ul><p>具体介绍如下表：</p><table><thead><tr><th align="left">访问级别</th><th align="left">访问控制修饰符</th><th align="left">同类</th><th align="left">同包</th><th align="left">子类</th><th align="left">不同的包</th></tr></thead><tbody><tr><td align="left">公开</td><td align="left">public</td><td align="left">✓</td><td align="left">✓</td><td align="left">✓</td><td align="left">✓</td></tr><tr><td align="left">受保护</td><td align="left">protected</td><td align="left">✓</td><td align="left">✓</td><td align="left">✓</td><td align="left">×</td></tr><tr><td align="left">默认</td><td align="left">没有访问修饰符</td><td align="left">✓</td><td align="left">✓</td><td align="left">×</td><td align="left">×</td></tr><tr><td align="left">私有</td><td align="left">private</td><td align="left">✓</td><td align="left">×</td><td align="left">×</td><td align="left">×</td></tr></tbody></table><p>（1）在开发中要尽可能地加上访问修饰符（提高程序的可读性）；</p><p>（2）无特殊要求的情况下，类内部的变量应该设置为私有的（防止外部篡改）。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>构造方法也叫构造器或构造函数，它的作用是对类进行初始化，比如以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cat cat = <span class="keyword">new</span> Cat(<span class="string">&quot;喵星人&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(cat.getName());</span><br><span class="line">        System.out.println(cat.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码执行结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">喵星人</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>构造方法五大原则：</strong></p><ol><li>构造方法必须与类同名；</li><li>构造方法的参数可以没有或者有多个；</li><li>构造方法不能有返回值；</li><li>每个类可以有一个或多个构造方法；</li><li>构造方法总是伴随着 new 操作一起使用。</li></ol><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>用法：使用 extends 关键字来实现类的继承，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">eTest</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal cat = <span class="keyword">new</span> Cat();</span><br><span class="line">        cat.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果：<code>Animal</code></p><p><strong>继承使用技巧：</strong></p><ul><li>将公共的变量或者方法提取到超类中；</li><li>除非所有的方法都有继承的意义，否则不要使用继承；</li><li>在方法覆盖时不要改变原有方法的预期行为。</li></ul><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Object 类是 Java 中的一个特殊类，它是所有类的父类，Java 中的类都直接或间接的继承自 Object 类。</p><p>Object 类的常用方法如下：</p><ul><li>equals()：对比两个对象是否相同</li><li>getClass()：返回一个对象的运行时类</li><li>hashCode()：返回该对象的哈希码值</li><li>toString()：返回该对象的字符串描述</li><li>wait()：使当前的线程等待</li><li>notify()：唤醒在此对象监视器上等待的单个线程</li><li>notifyAll()：唤醒在此对象监视器上等待的所有线程</li><li>clone()：克隆一个新对象</li></ul><p>关于更多 Object 的内容，如克隆（深克隆、浅克隆）、线程等待和唤醒，会在后面的章节中详细介绍。</p><h3 id="相关面试题-7"><a href="#相关面试题-7" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="类的组成部分有哪些？"><a href="#类的组成部分有哪些？" class="headerlink" title="类的组成部分有哪些？"></a>类的组成部分有哪些？</h4><p>答：在 Java 语言中，类主要是由方法和变量两部分组成。</p><h4 id="类与对象有哪些区别？"><a href="#类与对象有哪些区别？" class="headerlink" title="类与对象有哪些区别？"></a>类与对象有哪些区别？</h4><p>答：类是一个抽象的概念，是对某一事物的描述；而对象是类的实例，是实实在在存在的个体。比如，“人”就是一个类（一个概念），而老王（王磊）就是实实在在的一个“对象”。</p><h4 id="Java-中可以多继承吗？"><a href="#Java-中可以多继承吗？" class="headerlink" title="Java 中可以多继承吗？"></a>Java 中可以多继承吗？</h4><p>答：Java 中只能单继承，但可以实现多接口。</p><h4 id="Java-中为什么不能实现多继承？"><a href="#Java-中为什么不能实现多继承？" class="headerlink" title="Java 中为什么不能实现多继承？"></a>Java 中为什么不能实现多继承？</h4><p>答：从技术的实现角度来说，是为了降低编程的复杂性。假设 A 类中有一个 m() 方法，B 类中也有一个 m() 方法，如果 C 类同时继承 A 类和 B 类，那调用 C 类的 m() 方法时就会产生歧义，这无疑增加了程序开发的复杂性，为了避免这种问题的产生，Java 语言规定不能多继承类，但可以实现多接口。</p><h4 id="覆盖和重载有哪些区别？"><a href="#覆盖和重载有哪些区别？" class="headerlink" title="覆盖和重载有哪些区别？"></a>覆盖和重载有哪些区别？</h4><p>答：覆盖和重载的区别如下：</p><ul><li>覆盖（Override）是指子类对父类方法的一种重写，只能比父类抛出更少的异常，访问权限不能比父类的小，被覆盖的方法不能是 private，否则只是在子类中重新定义了一个方法；</li><li>重载（Overload）表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同。</li></ul><h4 id="以下不属于重载特性的是？"><a href="#以下不属于重载特性的是？" class="headerlink" title="以下不属于重载特性的是？"></a>以下不属于重载特性的是？</h4><p>A：方法的参数类型不同<br>B：方法的返回值不同<br>C：方法的参数个数不同<br>D：方法的参数顺序不同</p><p>答：B</p><h4 id="为什么方法不能根据返回类型来区分重载？"><a href="#为什么方法不能根据返回类型来区分重载？" class="headerlink" title="为什么方法不能根据返回类型来区分重载？"></a>为什么方法不能根据返回类型来区分重载？</h4><p>答：因为在方法调用时，如果不指定类型信息，编译器就不知道你要调用哪个方法了。比如，以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="comment">// 方法调用</span></span><br><span class="line">max(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>因为 <code>max(1,2)</code> 没有指定返回值，编译器就不知道要调用哪个方法了。</p><h4 id="构造方法有哪些特征？"><a href="#构造方法有哪些特征？" class="headerlink" title="构造方法有哪些特征？"></a>构造方法有哪些特征？</h4><p>答：构造方法的特征如下：</p><ul><li>构造方法必须与类名相同；</li><li>构造方法没有返回类型（void 也不能有）；</li><li>构造方法不能被继承、覆盖、直接调用；</li><li>类定义时提供了默认的无参构造方法；</li><li>构造方法可以私有，外部无法使用私有构造方法创建对象。</li></ul><h4 id="构造函数能不能被覆盖？能不能被重载？"><a href="#构造函数能不能被覆盖？能不能被重载？" class="headerlink" title="构造函数能不能被覆盖？能不能被重载？"></a>构造函数能不能被覆盖？能不能被重载？</h4><p>答：构造函数可以重载，但不能覆盖。</p><h4 id="以下说法正确的是？"><a href="#以下说法正确的是？" class="headerlink" title="以下说法正确的是？"></a>以下说法正确的是？</h4><p>A：类中的构造方法不能忽略<br>B：构造方法可以作为普通方法被调用<br>C：构造方法在对象被 new 时被调用<br>D：一个类只能有一个构造方法</p><p>答：C</p><h4 id="以下程序执行的结果是？-3"><a href="#以下程序执行的结果是？-3" class="headerlink" title="以下程序执行的结果是？"></a>以下程序执行的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExecTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：打印的结果是：<code>251346</code></p><p>加载顺序如下：</p><ul><li>执行父类的静态成员；</li><li>执行子类的静态成员；</li><li>父类的实例成员和实例初始化；</li><li>执行父类构造方法；</li><li>子类的实例成员和实例初始化；</li><li>子类构造方法。</li></ul><h4 id="以下程序执行的结果是？-4"><a href="#以下程序执行的结果是？-4" class="headerlink" title="以下程序执行的结果是？"></a>以下程序执行的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A myClass = <span class="keyword">new</span> B();</span><br><span class="line">        System.out.print(myClass.x);</span><br><span class="line">        System.out.print(myClass.y);</span><br><span class="line">        myClass.m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：打印的结果是：<code>00B</code></p><p>题目解析：在 Java 语言中，变量不能被重写。</p><h4 id="以下程序执行的结果是？-5"><a href="#以下程序执行的结果是？-5" class="headerlink" title="以下程序执行的结果是？"></a>以下程序执行的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">(D d)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> B();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        D d = <span class="keyword">new</span> D();</span><br><span class="line">        a.m(a);</span><br><span class="line">        a.m(b);</span><br><span class="line">        a.m(c);</span><br><span class="line">        a.m(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>答：打印结果如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BA</span><br><span class="line">BA</span><br><span class="line">BA</span><br><span class="line">AD</span><br></pre></td></tr></table></figure><p>题目解析：</p><ul><li>第一个 BA：因为 A 的 m() 方法，被子类 B 重写了，所以输出是：BA；</li><li>第二个 BA：因为 B 是 A 的子类，当调用父类 m() 方法时，发现 m() 方法被 B 类重写了，所以会调用 B 中的 m() 方法，输出就是：BA；</li><li>第三个 BA：因为 C 是 B 的子类，会直接调用 B 的 m() 方法，所以输出就是：BA；</li><li>第四个 AD：因为 D 是 A 的子类，所以会调用 A 的 m() 方法，所以输出就是：AD。</li></ul><h4 id="Java-中的-this-和-super-有哪些区别？"><a href="#Java-中的-this-和-super-有哪些区别？" class="headerlink" title="Java 中的 this 和 super 有哪些区别？"></a>Java 中的 this 和 super 有哪些区别？</h4><p>答：this 和 super 都是 Java 中的关键字，起指代作用，在构造方法中必须出现在第一行，它们的区别如下。</p><ul><li>基础概念：this 是访问本类实例属性或方法；super 是子类访问父类中的属性或方法。</li><li>查找范围：this 先查本类，没有的话再查父类；super 直接访问父类。</li><li>使用：this 单独使用时，表示当前对象；super 在子类覆盖父类方法时，访问父类同名方法。</li></ul><h4 id="在静态方法中可以使用-this-或-super-吗？为什么？"><a href="#在静态方法中可以使用-this-或-super-吗？为什么？" class="headerlink" title="在静态方法中可以使用 this 或 super 吗？为什么？"></a>在静态方法中可以使用 this 或 super 吗？为什么？</h4><p>答：在静态方法中不能使用 this 或 super，因为 this 和 super 指代的都是需要被创建出来的对象，而静态方法在类加载的时候就已经创建了，所以没办法在静态方法中使用 this 或 super。</p><h4 id="静态方法的使用需要注意哪些问题？"><a href="#静态方法的使用需要注意哪些问题？" class="headerlink" title="静态方法的使用需要注意哪些问题？"></a>静态方法的使用需要注意哪些问题？</h4><p>答：静态方法的使用需要注意以下两个问题：</p><ul><li>静态方法中不能使用实例成员变量和实例方法；</li><li>静态方法中不能使用 this 和 super。</li></ul><h4 id="final-修饰符的作用有哪些？"><a href="#final-修饰符的作用有哪些？" class="headerlink" title="final 修饰符的作用有哪些？"></a>final 修饰符的作用有哪些？</h4><p>答：final 修饰符作用如下：</p><ul><li>被 final 修饰的类不能被继承；</li><li>被 final 修饰的方法不能被重写；</li><li>被 final 修饰的变量不能被修改。</li></ul><h4 id="覆盖-equals-方法的时候需要遵守哪些规则？"><a href="#覆盖-equals-方法的时候需要遵守哪些规则？" class="headerlink" title="覆盖 equals() 方法的时候需要遵守哪些规则？"></a>覆盖 equals() 方法的时候需要遵守哪些规则？</h4><p>答：Oracle 官方的文档对于 equals() 重写制定的规则如下。</p><ul><li>自反性：对于任意非空的引用值 x，x.equals(x) 返回值为真。</li><li>对称性：对于任意非空的引用值 x 和 y，x.equals(y) 必须和 y.equals(x) 返回相同的结果。</li><li>传递性：对于任意的非空引用值 x、y 和 z，如果 x.equals(y) 返回值为真，y.equals(z) 返回值也为真，那么 x.equals(z) 也必须返回值为真。</li><li>一致性：对于任意非空的引用值 x 和 y，无论调用 x.equals(y) 多少次，都要返回相同的结果。在比较的过程中，对象中的数据不能被修改。</li><li>对于任意的非空引用值 x，x.equals(null) 必须返回假。</li></ul><p>此题目不要求记忆，能知道大概即可，属于加分项题目。</p><h4 id="在-Object-中-notify-和-notifyAll-方法有什么区别？"><a href="#在-Object-中-notify-和-notifyAll-方法有什么区别？" class="headerlink" title="在 Object 中 notify() 和 notifyAll() 方法有什么区别？"></a>在 Object 中 notify() 和 notifyAll() 方法有什么区别？</h4><p>答：notify() 方法随机唤醒一个等待的线程，而 notifyAll() 方法将唤醒所有在等待的线程。</p><h4 id="如何使用-clone-方法？"><a href="#如何使用-clone-方法？" class="headerlink" title="如何使用 clone() 方法？"></a>如何使用 clone() 方法？</h4><p>答：如果是同一个类中使用的话，只需要实现 Cloneable 接口，定义或者处理 CloneNotSupportedException 异常即可，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        CloneTest ct = <span class="keyword">new</span> CloneTest();</span><br><span class="line">        ct.num = <span class="number">666</span>;</span><br><span class="line">        System.out.println(ct.num);</span><br><span class="line">        CloneTest ct2 = (CloneTest) ct.clone();</span><br><span class="line">        System.out.println(ct2.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果非内部类调用 clone() 的话，需要重写 clone() 方法，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        CloneTest ct = <span class="keyword">new</span> CloneTest();</span><br><span class="line">        ct.num = <span class="number">666</span>;</span><br><span class="line">        System.out.println(ct.num);</span><br><span class="line">        CloneTest ct2 = (CloneTest) ct.clone();</span><br><span class="line">        System.out.println(ct2.num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        CloneTest ct = <span class="keyword">new</span> CloneTest();</span><br><span class="line">        ct.num = <span class="number">666</span>;</span><br><span class="line">        System.out.println(ct.num);</span><br><span class="line">        CloneTest ct2 = (CloneTest) ct.clone();</span><br><span class="line">        System.out.println(ct2.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>本文我们学习了类的基础用法，类引用：import 和 import static，访问修饰符的作用，构造函数和继承的特点以及使用技巧等，通过这些内容让我们对整个 Java 程序的组成，有了更加清晰直观的印象。</p><h2 id="各种内部类和枚举类的使用-面试题"><a href="#各种内部类和枚举类的使用-面试题" class="headerlink" title="各种内部类和枚举类的使用 + 面试题"></a>各种内部类和枚举类的使用 + 面试题</h2><p>内部类不仅经常出现在各种面试题中，还会在 Java 源码中频频出现，因此只有搞明白了 Java 内部类，才能搞定面试和看懂各种 Java 源码。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>Java 内部类，分为以下四种：</p><ul><li>成员内部类</li><li>静态成员内部类</li><li>局部内部类</li><li>匿名内部类</li></ul><p>下面分别来看这些内部类的使用。</p><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h5><p>在一个类中定义了另一个类，则将定义在类中的那个类称之为成员内部类。成员内部类也是最普通的内部类。</p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h5><p>成员内部类的使用示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer Class.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hi, Inner.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 Inner 类则为成员内部类。<br>而成员内部类的创建和使用，请参考以下完整的示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">// 创建成员内部类</span></span><br><span class="line">        Outer.Inner inner = out.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        inner.sayHi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer Class.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hi, Inner.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="成员内部类的创建"><a href="#成员内部类的创建" class="headerlink" title="成员内部类的创建"></a><strong>成员内部类的创建</strong></h5><p>语法：</p><blockquote><p>Outer.Inner inner = new Outer().new Inner();</p></blockquote><h5 id="内部类访问外部类"><a href="#内部类访问外部类" class="headerlink" title="内部类访问外部类"></a><strong>内部类访问外部类</strong></h5><p>语法：</p><blockquote><p>Outer.this.xxx</p></blockquote><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;OuterClass&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hi, Outer.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 内部类访问外部类</span></span><br><span class="line">            Outer.<span class="keyword">this</span>.sayHi();</span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.name);</span><br><span class="line">            System.out.println(<span class="string">&quot;Hi, Inner.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer.Inner inner =  <span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        inner.sayHi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="外部类访问内部类"><a href="#外部类访问内部类" class="headerlink" title="外部类访问内部类"></a><strong>外部类访问内部类</strong></h5><p>语法：</p><blockquote><p>new Inner().xxx</p></blockquote><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Inner().name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hi, Outer.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">&quot;InnerClass&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hi, Inner.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Outer().sayHi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h5><ul><li>成员内部类可直接访问外部类（使用：外部类.this.xxx）；</li><li>外部成员类要访问内部类，必须先建立成员内部类对象；</li><li>成员内部类可使用任意作用域修饰（public、protected、默认、private）；</li><li>成员内部类可访问外部类任何作用域修饰的属性和方法；</li><li>外部类建立成员内部类对象之后，可以访问任何作用域修饰的内部类属性和方法。</li></ul><h4 id="静态成员内部类"><a href="#静态成员内部类" class="headerlink" title="静态成员内部类"></a>静态成员内部类</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong></h5><p>在一个类中定义了另一个 static 类，则将定义在类中的那个 static 类称之为静态成员内部类。</p><p>静态成员内部类也就是给内部成员类加上 static 修饰符。</p><h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a><strong>使用</strong></h5><p>静态成员内部类的使用示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OuterClass Init.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hi, InnerClass.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass.InnerClass innerClass = <span class="keyword">new</span> OuterClass.InnerClass();</span><br><span class="line">        innerClass.sayHi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与内部成员类的创建方式 new Outer().new Inner() 不同，静态成员内部类可使用 new OuterClass.InnerClass() 的方式进行创建。</p><p><strong>注意</strong>：不能从静态成员内部类中访问非静态外部类对象。</p><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a><strong>定义</strong></h5><p>一个类定义在另一个类的局部（方法或者任意作用域），这个类就称之为局部内部类。</p><h5 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a><strong>使用</strong></h5><p>局部内部类的使用示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">            InnerClass(String name) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;InnerClass:&quot;</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> InnerClass(<span class="string">&quot;Three&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Hi, OutClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> OutClass().sayHi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="局部内部类特点"><a href="#局部内部类特点" class="headerlink" title="局部内部类特点"></a><strong>局部内部类特点</strong></h5><ul><li>局部内部类不能使用任何访问修饰符；</li><li>局部类如果在方法中，可以直接使用方法中的变量，不需要通过 OutClass.this.xxx 的方式获得。</li></ul><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a><strong>定义</strong></h5><p>没有名字的内部类就叫做匿名内部类。</p><h5 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a><strong>使用</strong></h5><p>匿名内部类的使用示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AnonymityOuter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnonymityTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnonymityOuter anonymityOuter = <span class="keyword">new</span> AnonymityOuter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hi, AnonymityOuter.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        anonymityOuter.hi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，new AnonymityOuter() 之后的 {…} 大括号包含的部分就为匿名内部类。</p><h5 id="匿名内部类特点"><a href="#匿名内部类特点" class="headerlink" title="匿名内部类特点"></a><strong>匿名内部类特点</strong></h5><ul><li>匿名内部类必须继承一个父类或者实现一个接口</li><li>匿名内部类不能定义任何静态成员和方法</li><li>匿名内部类中的方法不能是抽象的</li></ul><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>枚举类是 JDK 1.5 引入的新特性，使用关键字“enum”声明。枚举功能虽小，却非常实用，大大方便了程序的开发者。</p><h5 id="枚举类的使用"><a href="#枚举类的使用" class="headerlink" title="枚举类的使用"></a><strong>枚举类的使用</strong></h5><p>请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> ColorEnum &#123;</span><br><span class="line">    RED,</span><br><span class="line">    BLUE,</span><br><span class="line">    YELLOW,</span><br><span class="line">    GREEN</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ColorEnum color = ColorEnum.GREEN;</span><br><span class="line">        <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">            <span class="keyword">case</span> RED:</span><br><span class="line">                System.out.println(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BLUE:</span><br><span class="line">                System.out.println(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YELLOW:</span><br><span class="line">                System.out.println(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GREEN:</span><br><span class="line">                System.out.println(<span class="string">&quot;Green&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="枚举类命名规范"><a href="#枚举类命名规范" class="headerlink" title="枚举类命名规范"></a><strong>枚举类命名规范</strong></h5><p>《阿里巴巴 Java 开发手册》对枚举类的命名规范建议，如下图：</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/64e7ff70-c7b3-11e9-a87f-3bdeb236b9c4"></p><h5 id="扩展枚举类"><a href="#扩展枚举类" class="headerlink" title="扩展枚举类"></a><strong>扩展枚举类</strong></h5><p>我们可以自定义一些枚举类方法，扩展枚举类的使用，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> ColorsEnum &#123;</span><br><span class="line">    RED(<span class="string">&quot;红色&quot;</span>, <span class="number">1</span>),</span><br><span class="line">    BLUE(<span class="string">&quot;蓝色&quot;</span>, <span class="number">2</span>),</span><br><span class="line">    YELLOW(<span class="string">&quot;黄色&quot;</span>, <span class="number">3</span>),</span><br><span class="line">    GREEN(<span class="string">&quot;绿色&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    ColorsEnum(String name, <span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ColorsEnum.RED.getName());</span><br><span class="line">        System.out.println(ColorsEnum.RED.getIndex());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上代码返回的结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">红色</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="相关面试题-8"><a href="#相关面试题-8" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="Java-中的内部类有哪些？"><a href="#Java-中的内部类有哪些？" class="headerlink" title="Java 中的内部类有哪些？"></a>Java 中的内部类有哪些？</h4><p>答：内部类包含以下 4 种：</p><ul><li>静态内部类：static class StaticInnerClass{}；</li><li>成员内部类：private class InstanceInnerClass{}；</li><li>局部内部类：定义在方法或者表达式内部；</li><li>匿名内部类：(new Thread(){}).start()。</li></ul><h4 id="以下关于匿名内部类说法错误的是？"><a href="#以下关于匿名内部类说法错误的是？" class="headerlink" title="以下关于匿名内部类说法错误的是？"></a>以下关于匿名内部类说法错误的是？</h4><p>A：匿名内部类必须继承一个父类或者实现一个接口<br>B：匿名内部类中的方法不能是抽象的<br>C：匿名内部类可以实现接口的部分抽象方法<br>D：匿名内部类不能定义任何静态成员和方法</p><p>答：C<br>题目解析：匿名内部类规定必须实现接口的所有抽象方法，否则程序会报错，如下图所示。</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/7d00d230-c7b3-11e9-9e56-8d3dec542204"></p><h4 id="以下枚举类比较“-”和“equals”结果一致吗？为什么？"><a href="#以下枚举类比较“-”和“equals”结果一致吗？为什么？" class="headerlink" title="以下枚举类比较“==”和“equals”结果一致吗？为什么？"></a>以下枚举类比较“==”和“equals”结果一致吗？为什么？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ColorEnum redColor = ColorEnum.RED;</span><br><span class="line">        ColorEnum redColor2 = ColorEnum.RED;</span><br><span class="line">        System.out.println(redColor == redColor2);</span><br><span class="line">        System.out.println(redColor.equals(redColor2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> ColorEnum &#123;</span><br><span class="line">    RED,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：结果一致，都是 <code>true</code>。<br>题目分析：因为枚举类重写了 equals 方法，equals 方法里直接使用的 <code>==</code> 比较的，而枚举类不能通过 new 进行创建，使用 ColorEnum.RED 得到的对象，其实使用的是对象的引用地址，所以 <code>==</code> 比较的结果一定是 true。equals 被重写的源码如下图：</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/8feae480-c7b3-11e9-9e56-8d3dec542204"></p><h4 id="使用静态内部类的好处有哪些？"><a href="#使用静态内部类的好处有哪些？" class="headerlink" title="使用静态内部类的好处有哪些？"></a>使用静态内部类的好处有哪些？</h4><p>答：使用静态内部类的好处如下：<br>作用域不会扩散到包外；</p><ul><li>可以通过“外部类.内部类”的方式直接访问；</li><li>内部类可以访问外部类中的所有静态属性和方法。</li></ul><h4 id="以下代码执行的结果是？"><a href="#以下代码执行的结果是？" class="headerlink" title="以下代码执行的结果是？"></a>以下代码执行的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">&quot;OuterClass&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">&quot;InnerClass&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(OuterClass.<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass.InnerClass innerClass = <span class="keyword">new</span> OuterClass.InnerClass();</span><br><span class="line">        innerClass.sayHi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：程序报错。<br>题目解析：在静态成员内部类中不能直接访问非静态外部类，因此程序会报错。</p><h4 id="成员内部类和局部内部类有什么区别？"><a href="#成员内部类和局部内部类有什么区别？" class="headerlink" title="成员内部类和局部内部类有什么区别？"></a>成员内部类和局部内部类有什么区别？</h4><p>答：内部成员类和局部内部类的区别如下。</p><ul><li>内部成员类可以使用任意访问修饰符，局部内部类不能使用任何访问修饰符；</li><li>局部内部类是声明在外部类的方法或其他作用域范围内的，内部类是直接声明在外部类之中的，与方法和属性平级。</li></ul><h4 id="为什么要使用内部类？内部类的使用场景有哪些？"><a href="#为什么要使用内部类？内部类的使用场景有哪些？" class="headerlink" title="为什么要使用内部类？内部类的使用场景有哪些？"></a>为什么要使用内部类？内部类的使用场景有哪些？</h4><p>答：使用内部类的好处有以下两个。</p><ul><li>可以作为多继承的一种实现方式，最早内部类的实现就是平衡 Java 语言中没有多继承的一种方式；</li><li>方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。<br>内部类可以作为多继承的一种实现方式进行使用，因为每个内部类都能独立的继承一个类或接口，所以整个类就可以实现多继承。</li></ul><h4 id="以下代码执行的结果是？-1"><a href="#以下代码执行的结果是？-1" class="headerlink" title="以下代码执行的结果是？"></a>以下代码执行的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.num);</span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span>.<span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：输出内容如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="枚举有哪些应用场景？"><a href="#枚举有哪些应用场景？" class="headerlink" title="枚举有哪些应用场景？"></a>枚举有哪些应用场景？</h4><p>答：枚举类的主要应用场景如下：<br><strong>① 枚举类可作为高级的常量类</strong><br>示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">    RED(<span class="string">&quot;#FF0000&quot;</span>, <span class="string">&quot;255,0,0&quot;</span>),</span><br><span class="line">    GREEN(<span class="string">&quot;#00FFFF&quot;</span>, <span class="string">&quot;0,255,255&quot;</span>),</span><br><span class="line">    YELLOW(<span class="string">&quot;#FFFF00&quot;</span>, <span class="string">&quot;255,255,0&quot;</span>);</span><br><span class="line">    String hex, rgb;</span><br><span class="line">    Color(String hex, String rgb) &#123;</span><br><span class="line"> <span class="keyword">this</span>.hex = hex;</span><br><span class="line"> <span class="keyword">this</span>.rgb = rgb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>② 枚举类可方便的用于 switch 判断</strong><br>示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(color)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> RED:</span><br><span class="line">    System.out.println(<span class="string">&quot;红灯停&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> GREEN:</span><br><span class="line">    System.out.println(<span class="string">&quot;绿灯行&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> YELLOW:</span><br><span class="line">    System.out.println(<span class="string">&quot;看情况&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;灯坏了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举类在-JVM-中是如何实现的？"><a href="#枚举类在-JVM-中是如何实现的？" class="headerlink" title="枚举类在 JVM 中是如何实现的？"></a>枚举类在 JVM 中是如何实现的？</h4><p>答：枚举类在 JVM（Java 虚拟机） 中其实是通过普通的 static final 形式实现的。<br>题目解析：我们使用 javap 命令来分析枚举类最终编译的结果，查看编译后的结果，就找到了枚举类在 JVM 中的具体实现了。<br>首先定义一个枚举类，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> DBEnum &#123;</span><br><span class="line">    ORACLE,</span><br><span class="line">    DB2,</span><br><span class="line">    MYSQL,</span><br><span class="line">    SQLSERVER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再使用命令 <code>javac DBEnum.java</code> 编译 .class 文件，然后再使用命令 <code>javap DBEnum.class</code>，我们看到最终执行的结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;EnumTest.java&quot;</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DBEnum</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">DBEnum</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DBEnum ORACLE;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DBEnum DB2;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DBEnum MYSQL;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DBEnum SQLSERVER;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DBEnum[] values();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DBEnum <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line"><span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以断定，枚举类在 JVM 中的实现也是通过普通的 static final 实现的。</p><h4 id="枚举类可以被继承吗？"><a href="#枚举类可以被继承吗？" class="headerlink" title="枚举类可以被继承吗？"></a>枚举类可以被继承吗？</h4><p>答：不能被继承，因为枚举类编译后的实际代码是 final class 的形式，类被 final 修饰了自然不能被继承。</p><h4 id="枚举类是否是线程安全的？"><a href="#枚举类是否是线程安全的？" class="headerlink" title="枚举类是否是线程安全的？"></a>枚举类是否是线程安全的？</h4><p>答：枚举类是线程安全的，因为枚举类被编译后是 final class 的形式存在的，所以枚举类是线程安全的。</p><h4 id="枚举是否可以被序列化？"><a href="#枚举是否可以被序列化？" class="headerlink" title="枚举是否可以被序列化？"></a>枚举是否可以被序列化？</h4><p>答：枚举是可以被序列化的，Oracle 官方对此给出了说明，内容如下：</p><blockquote><p>Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not transmitted. To serialize an enum constant, ObjectOutputStream writes the string returned by the constant’s name method. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream. The process by which enum constants are serialized cannot be customized; any class-specific writeObject and writeReplace methods defined by enum types are ignored during serialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored–all enum types have a fixed serialVersionUID of 0L</p></blockquote><p>原文地址：<a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectOutputStream.html">https://docs.oracle.com/javase/8/docs/api/java/io/ObjectOutputStream.html</a><br>大致的意思是说：枚举的序列化和其他普通类的序列化不同，枚举序列化的时候，只是将枚举对象的 name 属性输出到结果中，反序列化的时候则是通过 java.lang.Enum 的 valueOf 方法根据名字查找枚举对象。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>通过本文我们系统地学习了 Java 的各种内部类：静态内部类、成员内部类、局部内部类、匿名内部类，知道了它们特点和区别，并学习了枚举类了使用，知道了枚举类在编译之后，其实还是普通的最终类（final class）。</p><h2 id="抽象类和接口的应用-面试题"><a href="#抽象类和接口的应用-面试题" class="headerlink" title="抽象类和接口的应用 + 面试题"></a>抽象类和接口的应用 + 面试题</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。简单来说，使用关键字 <strong>abstract</strong> 修饰的类就叫做抽象类。</p><h4 id="抽象类使用"><a href="#抽象类使用" class="headerlink" title="抽象类使用"></a>抽象类使用</h4><p>示例代码，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractAnimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Init AbstractAnimal.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> String name = <span class="string">&quot;AbstractAnimal&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AbstractAnimal Run.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">AbstractAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractAnimal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        animal.run();</span><br><span class="line">        System.out.println(animal.name);</span><br><span class="line">        animal.eat();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 必须重写抽象父类方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal Eat.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码执行的结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Init AbstractAnimal.</span><br><span class="line">AbstractAnimal Run.</span><br><span class="line">AbstractAnimal</span><br><span class="line">Animal Eat.</span><br></pre></td></tr></table></figure><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>使用 <strong>abstract</strong> 关键字修饰的方法叫做抽象方法，抽象方法仅有声明没有方法体。如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="抽象类的特性"><a href="#抽象类的特性" class="headerlink" title="抽象类的特性"></a>抽象类的特性</h4><ul><li>抽象类不能被初始化</li><li>抽象类可以有构造方法</li><li>抽象类的子类如果为普通类，则必须重写抽象类中的所有抽象方法</li><li>抽象类中的方法可以是抽象方法或普通方法</li><li>一个类中如果包含了一个抽象方法，这个类必须是抽象类</li><li>子类中的抽象方法不能与父类中的抽象方法同名</li><li>抽象方法不能为 private、static、final 等关键字修饰</li><li>抽象类中可以包含普通成员变量，访问类型可以任意指定，也可以使用静态变量（static）</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>接口（interface）是抽象类的延伸，它允许一个类可以实现多个接口，弥补了抽象类不能多继承的缺陷，接口是对类的描述，使用 <strong>interface</strong> 关键字来声明。</p><h4 id="接口使用"><a href="#接口使用" class="headerlink" title="接口使用"></a>接口使用</h4><p>示例代码，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalImpl</span> <span class="keyword">implements</span> <span class="title">IAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IAnimal animal = <span class="keyword">new</span> AnimalImpl();</span><br><span class="line">        animal.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AnimalImpl Run.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java-8-中接口的改动"><a href="#Java-8-中接口的改动" class="headerlink" title="Java 8 中接口的改动"></a>Java 8 中接口的改动</h4><p><strong>1）接口中增加了 default 方法和 static 方法，可以有方法体</strong><br>示例代码，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Male Dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">printAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;18&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalImpl</span> <span class="keyword">implements</span> <span class="title">IAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IAnimal.printSex();</span><br><span class="line">        IAnimal animal = <span class="keyword">new</span> AnimalImpl();</span><br><span class="line">        animal.printAge();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：static 方法属于接口方法，可以直接使用；default 属于实例方法，必须先创建实例。</p><p><strong>2）接口中的静态变量会被继承</strong><br>示例代码，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IAnimal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String animalName = <span class="string">&quot;Animal Name&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Male Dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalImpl</span> <span class="keyword">implements</span> <span class="title">IAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(animalName);</span><br><span class="line">        IAnimal.printSex();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：静态变量会被继承，静态方法不会被继承。</p><p><strong>3）新增函数式接口</strong></p><p>函数式接口（Function Interface）是一个特殊的接口，使用 <code>@FunctionInterface</code> 注解声明，定义这种接口可以使用 <strong>Lambda</strong> 表达式直接调用。<br>示例代码，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IAnimal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String animalName = <span class="string">&quot;Animal Name&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Male Dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">printAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;18&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionInterfaceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IAnimal animal = name -&gt; System.out.println(name);</span><br><span class="line">        animal.sayHi(<span class="string">&quot;WangWang&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：使用 <code>@FunctionInterface</code> 声明的函数式接口，抽象方法必须有且仅有一个，但可以包含其他非抽象方法。</p><h3 id="相关面试题-9"><a href="#相关面试题-9" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="抽象类中能不能包含方法体？"><a href="#抽象类中能不能包含方法体？" class="headerlink" title="抽象类中能不能包含方法体？"></a>抽象类中能不能包含方法体？</h4><p>答：抽象类中可以包含方法体。抽象类的构成也可以完全是包含方法体的普通方法，只不过这样并不是抽象类最优的使用方式。</p><p>题目解析：包含了方法体的抽象类示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AbstractAnimal Run.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">AbstractAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractAnimal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        animal.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码执行的结果是： <code>AbstractAnimal Run.</code></p><h4 id="抽象类能不能被实例化？为什么？"><a href="#抽象类能不能被实例化？为什么？" class="headerlink" title="抽象类能不能被实例化？为什么？"></a>抽象类能不能被实例化？为什么？</h4><p>答：抽象类不能被实例化，因为抽象类和接口的设计就是用来规定子类行为特征的，就是让其他类来继承，是多态思想的一种设计体现，所以强制规定抽象类不能被实例化。</p><h4 id="抽象方法可以被-private-修饰吗？为什么？"><a href="#抽象方法可以被-private-修饰吗？为什么？" class="headerlink" title="抽象方法可以被 private 修饰吗？为什么？"></a>抽象方法可以被 private 修饰吗？为什么？</h4><p>答：抽象方法不能使用 private 修饰，因为抽象方法就是要子类继承重写的，如果设置 private 则子类不能重写此抽象方法，这与抽象方法的设计理念相违背，所以不能被 private 修饰。</p><h4 id="添加以下哪个选项不会引起编译器报错？"><a href="#添加以下哪个选项不会引起编译器报错？" class="headerlink" title="添加以下哪个选项不会引起编译器报错？"></a>添加以下哪个选项不会引起编译器报错？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAnimal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String animalName = <span class="string">&quot;AbstractAnimal&quot;</span>;</span><br><span class="line">      <span class="comment">// 添加代码处</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：protected abstract void eat();<br>B： void eat();<br>C：abstract void eat(){};<br>D：animalName += “Cat”;</p><p>答：A</p><p>题目解析：选项 B 普通方法必须有方法体；选项 C 抽象方法不能有方法体；选项 D 变量赋值操作必须在方法内。</p><h4 id="以下关于抽象类和抽象方法说法正确的是？"><a href="#以下关于抽象类和抽象方法说法正确的是？" class="headerlink" title="以下关于抽象类和抽象方法说法正确的是？"></a>以下关于抽象类和抽象方法说法正确的是？</h4><p>A：抽象类中的方法必须全部为抽象方法<br>B： 抽象类中必须包含一个抽象方法<br>C：抽象类中不能包含普通方法<br>D：抽象类中的方法可以全部为普通方法（包含方法体）</p><p>答：D</p><p>题目解析：抽象类中可以没有方法或者全部为普通方法，都是允许的，如下代码所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AbstractAnimal Run.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">AbstractAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractAnimal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        animal.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果为：AbstractAnimal Run.</p><h4 id="接口和普通类有什么关系？"><a href="#接口和普通类有什么关系？" class="headerlink" title="接口和普通类有什么关系？"></a>接口和普通类有什么关系？</h4><p>答：在 Java 语言设计中，接口不是类，而是对类的一组需求描述，这些类必须要遵循接口描述的统一格式进行定义。</p><h4 id="接口能不能有方法体？"><a href="#接口能不能有方法体？" class="headerlink" title="接口能不能有方法体？"></a>接口能不能有方法体？</h4><p>答：JDK 8 之前接口不能有方法体，JDK 8 之后新增了 static 方法和 default 方法，可以包含方法体。</p><h4 id="执行以下代码会输出什么结果？-1"><a href="#执行以下代码会输出什么结果？-1" class="headerlink" title="执行以下代码会输出什么结果？"></a>执行以下代码会输出什么结果？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IAnimal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String animalName = <span class="string">&quot;Animal Name&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalImpl</span> <span class="keyword">implements</span> <span class="title">IAnimal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String animalName = <span class="keyword">new</span> String(<span class="string">&quot;Animal Name&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(IAnimal.animalName == animalName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：执行的结果为 false。</p><p>题目解析：子类使用 new String… 重新创建了变量 animalName，又因为使用 == 进行内存地址比较，所以结果就是 false。</p><h4 id="抽象类和接口有什么区别？"><a href="#抽象类和接口有什么区别？" class="headerlink" title="抽象类和接口有什么区别？"></a>抽象类和接口有什么区别？</h4><p>答：抽象类和接口的区别，主要分为以下几个部分。</p><ul><li>默认方法</li><li>抽象类可以有默认方法的实现</li><li>JDK 8 之前接口不能有默认方法的实现，JDK 8 之后接口可以有默认方法的实现</li><li>继承方式</li><li>子类使用 extends 关键字来继承抽象类</li><li>子类使用 implements 关键字类实现接口</li><li>构造器</li><li>抽象类可以有构造器</li><li>接口不能有构造器</li><li>方法访问修饰符</li><li>抽象方法可以用 public / protected / default 等修饰符</li><li>接口默认是 public 访问修饰符，并且不能使用其他修饰符</li><li>多继承</li><li>一个子类只能继承一个抽象类</li><li>一个子类可以实现多个接口</li></ul><h4 id="以下抽象方法描述正确的是？"><a href="#以下抽象方法描述正确的是？" class="headerlink" title="以下抽象方法描述正确的是？"></a>以下抽象方法描述正确的是？</h4><p>A：抽象方法可以是静态（static）的<br>B：抽象方法可同时是本地方法（native）<br>C：抽象方法可以被 synchronized 修饰<br>D：以上都不是</p><p>答：D</p><p>题目解析：抽象方法需要被子类重写，而静态方法是无法被重写的，因此抽象方法不能被静态（static）修饰；本地方法是由本地代码实现的方法，而抽象方法没有实现，所以抽象方法不能同时是本地方法；synchronized 和方法的实现细节有关，而抽象方法不涉及实现细节，因此抽象方法不能被 synchronized 修饰。</p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>抽象类和接口都是面向对象编程中多态的具体实现，在 Java 编程思想中占据着重要的地位，同时也是初级面试岗位必问的问题之一，但由于接口在 JDK 8 中的改动比较大，因而面试者在网上搜到的绝大数关于接口和抽象类区别的答案也是不准确的，这点需要面试者特别注意一下。</p><h2 id="克隆和序列化应用-面试题"><a href="#克隆和序列化应用-面试题" class="headerlink" title="克隆和序列化应用 + 面试题"></a>克隆和序列化应用 + 面试题</h2><h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><p>在开始学习克隆之前，我们先来看看下面的代码，普通的对象复制，存在什么问题？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// 等号赋值（ 基本类型）</span></span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span> number2 = number;</span><br><span class="line">        <span class="comment">// 修改 number2 的值</span></span><br><span class="line">        number2 = <span class="number">9</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;number：&quot;</span> + number);</span><br><span class="line">        System.out.println(<span class="string">&quot;number2：&quot;</span> + number2);</span><br><span class="line">        <span class="comment">// 等号赋值（对象）</span></span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        dog.name = <span class="string">&quot;旺财&quot;</span>;</span><br><span class="line">        dog.age = <span class="number">5</span>;</span><br><span class="line">        Dog dog2 = dog;</span><br><span class="line">        <span class="comment">// 修改 dog2 的值</span></span><br><span class="line">        dog2.name = <span class="string">&quot;大黄&quot;</span>;</span><br><span class="line">        dog2.age = <span class="number">3</span>;</span><br><span class="line">        System.out.println(dog.name + <span class="string">&quot;，&quot;</span> + dog.age + <span class="string">&quot;岁&quot;</span>);</span><br><span class="line">        System.out.println(dog2.name + <span class="string">&quot;，&quot;</span> + dog2.age + <span class="string">&quot;岁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">number：<span class="number">6</span></span><br><span class="line">number2：<span class="number">9</span></span><br><span class="line">大黄，<span class="number">3</span>岁</span><br><span class="line">大黄，<span class="number">3</span>岁</span><br></pre></td></tr></table></figure><p>可以看出，如果使用等号复制时，对于值类型来说，彼此之间的修改操作是相对独立的，而对于引用类型来说，因为复制的是引用对象的内存地址，所以修改其中一个值，另一个值也会跟着变化，原理如下图所示：</p><p><img src="/" alt="img" class="lazyload" data-src="https://images.gitbook.cn/21bdbb00-c95b-11e9-80ba-3b9ebd4a5c21"></p><p>因此为了防止这种问题的发生，就要使用对象克隆来解决引用类型复制的问题。</p><h4 id="1）浅克隆"><a href="#1）浅克隆" class="headerlink" title="1）浅克隆"></a>1）浅克隆</h4><p>默认的 clone() 方法，为浅克隆，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        dog.name = <span class="string">&quot;旺财&quot;</span>;</span><br><span class="line">        dog.age = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 克隆</span></span><br><span class="line">        Dog dog3 = (Dog) dog.clone();</span><br><span class="line">        dog3.name = <span class="string">&quot;小白&quot;</span>;</span><br><span class="line">        dog3.age = <span class="number">2</span>;</span><br><span class="line">        System.out.println(dog.name + <span class="string">&quot;，&quot;</span> + dog.age + <span class="string">&quot;岁&quot;</span>);</span><br><span class="line">        System.out.println(dog3.name + <span class="string">&quot;，&quot;</span> + dog3.age + <span class="string">&quot;岁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">旺财，<span class="number">5</span>岁</span><br><span class="line">小白，<span class="number">2</span>岁</span><br></pre></td></tr></table></figure><p>可以看出使用克隆就可以解决引用类型复制的问题了，原理如下图所示：</p><p><img src="/" alt="img" class="lazyload" data-src="https://images.gitbook.cn/15e71230-c95c-11e9-a43e-c98246251c8a"></p><p>以上这种复制方式叫做<strong>浅克隆。</strong></p><p><strong>浅克隆的实现条件</strong>：需要克隆的对象必须实现 Cloneable 接口，并重写 clone() 方法，即可实现对此对象的克隆。</p><p>然而<strong>使用浅克隆也会存在一个问题</strong>，请参考以下代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaclass CloneTest &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        DogChild dogChild = <span class="keyword">new</span> DogChild();</span><br><span class="line">        dogChild.name = <span class="string">&quot;二狗&quot;</span>;</span><br><span class="line">        Dog dog4 = <span class="keyword">new</span> Dog();</span><br><span class="line">        dog4.name = <span class="string">&quot;大黄&quot;</span>;</span><br><span class="line">        dog4.dogChild = dogChild;</span><br><span class="line">        Dog dog5 = (Dog) dog4.clone();</span><br><span class="line">        dog5.name = <span class="string">&quot;旺财&quot;</span>;</span><br><span class="line">        dog5.dogChild.name = <span class="string">&quot;狗二&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog name 4：&quot;</span>+dog4.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;dog name 5：&quot;</span>+dog5.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;dog child name 4：&quot;</span>+dog4.dogChild.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;dog child name 5：&quot;</span>+dog5.dogChild.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> DogChild dogChild;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogChild</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dog name <span class="number">4</span>：大黄</span><br><span class="line">dog name <span class="number">5</span>：旺财</span><br><span class="line">dog child name <span class="number">4</span>：狗二</span><br><span class="line">dog child name <span class="number">5</span>：狗二</span><br></pre></td></tr></table></figure><p>也就是说浅克隆，只会复制对象的值类型，而不会复制对象的引用类型。原因如下图所示：</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/3e983f10-c95c-11e9-80ba-3b9ebd4a5c21"></p><p>要处理引用类型不被复制的问题，就要使用到<strong>深克隆</strong>。</p><h4 id="2）深克隆"><a href="#2）深克隆" class="headerlink" title="2）深克隆"></a>2）深克隆</h4><p><strong>定义</strong>：深克隆就是复制整个对象信息，包含值类型和引用类型。</p><p><strong>深克隆的实现方式</strong>通常包含以下两种。</p><ul><li>序列化实现深克隆：先将原对象序列化到内存的字节流中，再从字节流中反序列化出刚刚存储的对象，这个新对象和原对象就不存在任何地址上的共享，这样就实现了深克隆。</li><li>所有引用类型都实现克隆：要复制对象的所有引用类型都要实现克隆，所有对象都是复制的新对象，从而实现了深克隆。</li></ul><p><strong>深克隆实现方式一：序列化</strong></p><p>实现思路：先将要拷贝对象写入到内存中的字节流中，然后再从这个字节流中读出刚刚存储的信息，作为一个新对象返回，那么这个新对象和原对象就不存在任何地址上的共享，自然实现了深拷贝。请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        BirdChild birdChild = <span class="keyword">new</span> BirdChild();</span><br><span class="line">        birdChild.name = <span class="string">&quot;小小鸟&quot;</span>;</span><br><span class="line">        Bird bird = <span class="keyword">new</span> Bird();</span><br><span class="line">        bird.name = <span class="string">&quot;小鸟&quot;</span>;</span><br><span class="line">        bird.birdChild = birdChild;</span><br><span class="line">        <span class="comment">// 使用序列化克隆对象</span></span><br><span class="line">        Bird bird2 = CloneUtils.clone(bird);</span><br><span class="line">        bird2.name = <span class="string">&quot;黄雀&quot;</span>;</span><br><span class="line">        bird2.birdChild.name = <span class="string">&quot;小黄雀&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;bird name:&quot;</span> + bird.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;bird child name:&quot;</span> + bird.birdChild.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;bird name 2:&quot;</span> + bird2.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;bird child name 2:&quot;</span> + bird2.birdChild.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        T cloneObj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//写入字节流</span></span><br><span class="line">            ByteArrayOutputStream bo = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bo);</span><br><span class="line">            oos.writeObject(obj);</span><br><span class="line">            oos.close();</span><br><span class="line">            <span class="comment">//分配内存,写入原始对象,生成新对象</span></span><br><span class="line">            ByteArrayInputStream bi = <span class="keyword">new</span> ByteArrayInputStream(bo.toByteArray());<span class="comment">//获取上面的输出字节流</span></span><br><span class="line">            ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(bi);</span><br><span class="line">            <span class="comment">//返回生成的新对象</span></span><br><span class="line">            cloneObj = (T) oi.readObject();</span><br><span class="line">            oi.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneObj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bird name:小鸟</span><br><span class="line">bird child name:小小鸟</span><br><span class="line">bird name <span class="number">2</span>:黄雀</span><br><span class="line">bird child name <span class="number">2</span>:小黄雀</span><br></pre></td></tr></table></figure><p><strong>深克隆实现方式二：所有引用类型都实现克隆</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    ParrotChild parrotChild = <span class="keyword">new</span> ParrotChild();</span><br><span class="line">        parrotChild.name = <span class="string">&quot;小鹦鹉&quot;</span>;</span><br><span class="line">        Parrot parrot = <span class="keyword">new</span> Parrot();</span><br><span class="line">        parrot.name = <span class="string">&quot;大鹦鹉&quot;</span>;</span><br><span class="line">        parrot.parrotChild = parrotChild;</span><br><span class="line">        <span class="comment">// 克隆</span></span><br><span class="line">        Parrot parrot2 = (Parrot) parrot.clone();</span><br><span class="line">        parrot2.name = <span class="string">&quot;老鹦鹉&quot;</span>;</span><br><span class="line">        parrot2.parrotChild.name = <span class="string">&quot;少鹦鹉&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;parrot name:&quot;</span> + parrot.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;parrot child name:&quot;</span> + parrot.parrotChild.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;parrot name 2:&quot;</span> + parrot2.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;parrot child name 2:&quot;</span> + parrot2.parrotChild.name);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parrot</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> ParrotChild parrotChild;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Parrot bird = (Parrot) <span class="keyword">super</span>.clone();</span><br><span class="line">        bird.parrotChild = (ParrotChild) parrotChild.clone();</span><br><span class="line">        <span class="keyword">return</span> bird;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParrotChild</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">parrot name:大鹦鹉</span><br><span class="line">parrot child name:小鹦鹉</span><br><span class="line">parrot name <span class="number">2</span>:老鹦鹉</span><br><span class="line">parrot child name <span class="number">2</span>:少鹦鹉</span><br></pre></td></tr></table></figure><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><h4 id="1）介绍"><a href="#1）介绍" class="headerlink" title="1）介绍"></a>1）介绍</h4><p>内存中的数据对象只有转换成二进制流才能进行数据持久化或者网络传输，将对象转换成二进制流的过程叫做序列化（Serialization）；相反，把二进制流恢复为数据对象的过程就称之为反序列化（Deserialization）。</p><h4 id="2）序列化和反序列代码实现"><a href="#2）序列化和反序列代码实现" class="headerlink" title="2）序列化和反序列代码实现"></a>2）序列化和反序列代码实现</h4><p>先把对象序列化到磁盘，再从磁盘中反序列化出对象，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 对象赋值</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">30</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="comment">// 创建输出流（序列化内容到磁盘）</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.out&quot;</span>));</span><br><span class="line">        <span class="comment">// 序列化对象</span></span><br><span class="line">        oos.writeObject(user);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">        <span class="comment">// 创建输入流（从磁盘反序列化）</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.out&quot;</span>));</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        User user2 = (User) ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">        System.out.println(user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3831264392873197003L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;name:&quot;</span> + name + <span class="string">&quot;,age:&quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// setter/getter...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;name:老王,age:<span class="number">30</span>&#125;</span><br><span class="line">&#123;name:老王,age:<span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure><p>更多序列化和反序列化的实现方式以及代码示例，请看下文面试部分的内容。</p><p><strong>开发工具设置</strong>：IDEA 开启自动生成 serialVersionUID<br>点击 Settings → Inspections → 搜索 Serialization issues → 勾选 Serializable class without ‘SerialVersionUID’ 保存设置，如下图所示：</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/60afa9d0-c95c-11e9-a43e-c98246251c8a"></p><p>设置完之后，光标放到类名上，点击提示，生成 serialVersionUID，如下图所示：</p><p><img src="/" alt="img" class="lazyload" data-src="https://images.gitbook.cn/8d290240-c95c-11e9-a43e-c98246251c8a"></p><h3 id="相关面试题-10"><a href="#相关面试题-10" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="serialVersionUID-的作用是什么？"><a href="#serialVersionUID-的作用是什么？" class="headerlink" title="serialVersionUID 的作用是什么？"></a>serialVersionUID 的作用是什么？</h4><p>答：如果显示定义了 serialVersionUID 值之后，可以使序列化和反序列化向后兼容。也就是说如果 serialVersionUID 的值相同，修改对象的字段（删除或增加），程序不会报错，之后给没有的字段赋值为 null，而如果没有指定 serialVersionUID 的值，如果修改对象的字段，程序就会报错。如下图所示：</p><p><img src="/" alt="img" class="lazyload" data-src="https://images.gitbook.cn/a15a3a90-c95c-11e9-b6d8-9980966b523c"></p><h4 id="可序列化接口（Serializalbe）的用途是什么？"><a href="#可序列化接口（Serializalbe）的用途是什么？" class="headerlink" title="可序列化接口（Serializalbe）的用途是什么？"></a>可序列化接口（Serializalbe）的用途是什么？</h4><p>答：可序列化 Serializalbe 接口存在于 java.io 包中，构成了 Java 序列化机制的核心，它没有任何方法，它的用途是标记某对象为可序列化对象，指示编译器使用 Java 序列化机制序列化此对象。</p><h4 id="常用的序列化方式都有哪些？"><a href="#常用的序列化方式都有哪些？" class="headerlink" title="常用的序列化方式都有哪些？"></a>常用的序列化方式都有哪些？</h4><p>答：常用的序列化有以下三种方式：</p><p><strong>1）Java 原生序列化方式</strong></p><p>请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 序列化和反序列化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 对象赋值</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">30</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="comment">// 创建输出流（序列化内容到磁盘）</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.out&quot;</span>));</span><br><span class="line">        <span class="comment">// 序列化对象</span></span><br><span class="line">        oos.writeObject(user);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">        <span class="comment">// 创建输入流（从磁盘反序列化）</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.out&quot;</span>));</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        User user2 = (User) ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">        System.out.println(user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5132320539584511249L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;name:&quot;</span> + name + <span class="string">&quot;,age:&quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）JSON 格式，可使用 fastjson 或 GSON</strong></p><p>JSON 是一种轻量级的数据格式，JSON 序列化的优点是可读性比较高，方便调试。我们本篇以 fastjson 的序列化为例，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 序列化和反序列化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 对象赋值</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">30</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        String jsonSerialize = JSON.toJSONString(user);</span><br><span class="line">        User user3 = (User) JSON.parseObject(jsonSerialize, User.class);</span><br><span class="line">        System.out.println(user3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5132320539584511249L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;name:&quot;</span> + name + <span class="string">&quot;,age:&quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）Hessian 方式序列化</strong></p><p>Hessian 序列化的优点是可以跨编程语言，比 Java 原生的序列化和反序列化效率高。<br>请参考以下示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 序列化和反序列化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">       <span class="comment">// 序列化</span></span><br><span class="line">        ByteArrayOutputStream bo = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        HessianOutput hessianOutput = <span class="keyword">new</span> HessianOutput(bo);</span><br><span class="line">        hessianOutput.writeObject(user);</span><br><span class="line">        <span class="keyword">byte</span>[] hessianBytes = bo.toByteArray();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        ByteArrayInputStream bi = <span class="keyword">new</span> ByteArrayInputStream(hessianBytes);</span><br><span class="line">        HessianInput hessianInput = <span class="keyword">new</span> HessianInput(bi);</span><br><span class="line">        User user4 = (User) hessianInput.readObject();</span><br><span class="line">        System.out.println(user4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5132320539584511249L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;name:&quot;</span> + name + <span class="string">&quot;,age:&quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用克隆有什么好处？"><a href="#使用克隆有什么好处？" class="headerlink" title="使用克隆有什么好处？"></a>使用克隆有什么好处？</h4><p>答：好处包含以下几点。</p><ul><li>使用方便：假如要复制一个对象，但这个对象中的部分属性已经被修改过了，如果不使用克隆的话，需要给属性手动赋值，相比克隆而已麻烦很多；</li><li>性能高：查看 clone 方法可以知道，它是 native 方法，native 方法是原生函数，使用操作系统底层的语言实现的，因此执行效率更高；</li><li>隔离性：克隆可以确保对象操作时相互隔离。</li></ul><p>clone() 源代码，如下图：</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/dd3da650-c95c-11e9-a43e-c98246251c8a"></p><h4 id="浅克隆和深克隆有什么区别？"><a href="#浅克隆和深克隆有什么区别？" class="headerlink" title="浅克隆和深克隆有什么区别？"></a>浅克隆和深克隆有什么区别？</h4><p>答：区别主要在对引用类型的复制上，具体信息如下。</p><ul><li>浅克隆：只会复制对象的值类型，而不会复制对象的引用类型；</li><li>深克隆：复制整个对象，包含值类型和引用类型。</li></ul><h4 id="如何实现浅克隆？"><a href="#如何实现浅克隆？" class="headerlink" title="如何实现浅克隆？"></a>如何实现浅克隆？</h4><p>答：克隆的对象实现 Cloneable 接口，并重写 clone() 方法就可以实现浅克隆了。</p><h4 id="以下代码执行的结果是？-2"><a href="#以下代码执行的结果是？-2" class="headerlink" title="以下代码执行的结果是？"></a>以下代码执行的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        CloneObj cloneObj = <span class="keyword">new</span> CloneObj();</span><br><span class="line">        cloneObj.name = <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">        cloneObj.age = <span class="number">30</span>;</span><br><span class="line">        cloneObj.sistersAge = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">18</span>, <span class="number">19</span>&#125;;</span><br><span class="line">        CloneObj cloneObj2 = (CloneObj) cloneObj.clone();</span><br><span class="line">        cloneObj2.name = <span class="string">&quot;磊哥&quot;</span>;</span><br><span class="line">        cloneObj2.age = <span class="number">33</span>;</span><br><span class="line">        cloneObj2.sistersAge[<span class="number">0</span>] = <span class="number">20</span>;</span><br><span class="line">        System.out.println(cloneObj.name + <span class="string">&quot;|&quot;</span> + cloneObj2.name);</span><br><span class="line">        System.out.println(cloneObj.age + <span class="string">&quot;|&quot;</span> + cloneObj2.age);</span><br><span class="line">        System.out.println(Arrays.toString(cloneObj.sistersAge) + <span class="string">&quot;|&quot;</span> + Arrays.toString(cloneObj2.sistersAge));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneObj</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sistersAge;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：执行结果如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">老王|磊哥</span><br><span class="line"><span class="number">30</span>|<span class="number">33</span></span><br><span class="line">[<span class="number">20</span>, <span class="number">19</span>]|[<span class="number">20</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure><h4 id="深克隆如何实现？有几种实现方式？"><a href="#深克隆如何实现？有几种实现方式？" class="headerlink" title="深克隆如何实现？有几种实现方式？"></a>深克隆如何实现？有几种实现方式？</h4><p>答：一般实现方式有两种。</p><ul><li>通过序列化实现深克隆（序列化实现方式：Java 原生序列化、JSON 序列化、Hessian 序列化）；</li><li>所有引用类型都实现克隆，从而实现深克隆。</li></ul><h4 id="为什么不能直接使用-Object-的-Clone-方法，还要重写-clone-方法之后才能实现克隆？"><a href="#为什么不能直接使用-Object-的-Clone-方法，还要重写-clone-方法之后才能实现克隆？" class="headerlink" title="为什么不能直接使用 Object 的 Clone 方法，还要重写 clone() 方法之后才能实现克隆？"></a>为什么不能直接使用 Object 的 Clone 方法，还要重写 clone() 方法之后才能实现克隆？</h4><p>答：虽然所有类都是 Object 的子类，但因为 Object 中的 clone() 方法被声明为 protected 访问级别，所以非 java.lang 包下的其他类是不能直接使用的。因此要想实现克隆功能，就必须实现 Cloneable，并重写 clone() 方法才行。</p><h4 id="序列化可不可以实现深克隆？实现的原理是什么？"><a href="#序列化可不可以实现深克隆？实现的原理是什么？" class="headerlink" title="序列化可不可以实现深克隆？实现的原理是什么？"></a>序列化可不可以实现深克隆？实现的原理是什么？</h4><p>答：先将原对象序列化到内存的字节流中，再从字节流中反序列化出刚刚存储的对象，这个新对象和原对象就不存在任何地址上的共享，这样就实现了深克隆。</p><h4 id="序列化时某些成员不需要序列化，如何实现？"><a href="#序列化时某些成员不需要序列化，如何实现？" class="headerlink" title="序列化时某些成员不需要序列化，如何实现？"></a>序列化时某些成员不需要序列化，如何实现？</h4><p>答：可以把不需要序列化的成员设置为瞬态（trasient）和静态变量，这样就不会被序列化了，瞬态的使用如下：</p><blockquote><p>public transient int num;</p></blockquote><h4 id="是否可以自定义序列化过程，覆盖-Java-中的默认序列化过程？"><a href="#是否可以自定义序列化过程，覆盖-Java-中的默认序列化过程？" class="headerlink" title="是否可以自定义序列化过程，覆盖 Java 中的默认序列化过程？"></a>是否可以自定义序列化过程，覆盖 Java 中的默认序列化过程？</h4><p>答：可以，在 Java 中默认序列化一个对象需要调用 ObjectOutputStream.writeObject(saveThisObject) 和 ObjectInputStream.readObject() 读取对象，你可以自定义这两个方法，从而实现自定义序列化的过程。需要注意的重要一点是，记得声明这些方法为私有方法，以避免被继承、重写或重载。</p><h4 id="在-Java-中的序列化和反序列化过程中使用了哪些方法？"><a href="#在-Java-中的序列化和反序列化过程中使用了哪些方法？" class="headerlink" title="在 Java 中的序列化和反序列化过程中使用了哪些方法？"></a>在 Java 中的序列化和反序列化过程中使用了哪些方法？</h4><p>答：在 Java 中序列化由 java.io.ObjectOutputStream 类完成，该类是一个筛选器流，它封装在较低级别的字节流中，以处理序列化机制。要通过序列化机制存储任何对象，我们需要调用 ObjectOutputStream.writeObject(savethisobject) 方法，如果要反序列化该对象，我们需要调用 ObjectInputStream.readObject() 方法，readObject() 方法会读取字节，并把这些字节转换为对象再返回。</p><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>序列化常见的使用场景是远程服务调用（RPC）和网络对象传输等，可通过 implements Serializable 来实现对象序列化，在序列化对象中通过定义 serialVersionUID 来防止执行不兼容的类更改。调用 Object 类中的 clone() 方法默认是浅克隆，浅克隆只能复制值类型，不能复制引用类型，因此更多的时候我们需要深克隆，深克隆通常的实现方式有两种：序列化和所有引用类型都实现克隆。</p><h2 id="集合详解之-Collection-面试题"><a href="#集合详解之-Collection-面试题" class="headerlink" title="集合详解之 Collection + 面试题"></a>集合详解之 Collection + 面试题</h2><p>先来看看集合的继承关系图，如下图所示：</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/ae489970-ca62-11e9-bd50-998f3938aecb"></p><p>其中：</p><ul><li>外框为虚线的表示接口，边框为实线的表示类；</li><li>箭头为虚线的表示实现了接口，箭头为实线的表示继承了类。</li></ul><p>为了方便理解，我隐藏了一些与本文内容无关的信息，隐藏的这些内容会在后面的章节中进行详细地介绍。</p><p>从图中可以看出，集合的根节点是 Collection，而 Collection 下又提供了两大常用集合，分别是：</p><ul><li>List：使用最多的有序集合，提供方便的新增、修改、删除的操作；</li><li>Set：集合不允许有重复的元素，在许多需要保证元素唯一性的场景中使用。</li></ul><p>下面我们分别对集合类进行详细地介绍。</p><h3 id="集合使用"><a href="#集合使用" class="headerlink" title="集合使用"></a>集合使用</h3><h4 id="1）Vector"><a href="#1）Vector" class="headerlink" title="1）Vector"></a>1）Vector</h4><p>Vector 是 Java 早期提供的线程安全的有序集合，如果不需要线程安全，不建议使用此集合，毕竟同步是有线程开销的。</p><p>使用示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vector vector = <span class="keyword">new</span> Vector();</span><br><span class="line">vector.add(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">vector.add(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">vector.remove(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">System.out.println(vector);</span><br></pre></td></tr></table></figure><p>程序执行结果：<code>[dog]</code></p><h4 id="2）ArrayList"><a href="#2）ArrayList" class="headerlink" title="2）ArrayList"></a>2）ArrayList</h4><p>ArrayList 是最常见的非线程安全的有序集合，因为内部是数组存储的，所以随机访问效率很高，但非尾部的插入和删除性能较低，如果在中间插入元素，之后的所有元素都要后移。ArrayList 的使用与 Vector 类似。</p><h4 id="3）LinkedList"><a href="#3）LinkedList" class="headerlink" title="3）LinkedList"></a>3）LinkedList</h4><p>LinkedList 是使用双向链表数据结构实现的，因此增加和删除效率比较高，而随机访问效率较差。</p><p>LinkedList 除了包含以上两个类的操作方法之外，还新增了几个操作方法，如 offer() 、peek() 等，具体详情，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">linkedList.offer(<span class="string">&quot;bird&quot;</span>);</span><br><span class="line">linkedList.push(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">linkedList.push(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line"><span class="comment">// 获取第一个元素</span></span><br><span class="line">System.out.println(linkedList.peek());</span><br><span class="line"><span class="comment">// 获取第一个元素，并删除此元素</span></span><br><span class="line">System.out.println(linkedList.poll());</span><br><span class="line">System.out.println(linkedList);</span><br></pre></td></tr></table></figure><p>程序的执行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dog</span><br><span class="line">dog</span><br><span class="line">[cat, bird]</span><br></pre></td></tr></table></figure><h4 id="4）HashSet"><a href="#4）HashSet" class="headerlink" title="4）HashSet"></a>4）HashSet</h4><p>HashSet 是一个没有重复元素的集合。虽然它是 Set 集合的子类，实际却为 HashMap 的实例，相关源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此 HashSet 是无序集合，没有办法保证元素的顺序性。</p><p>HashSet 默认容量为 16，每次扩充 0.75 倍，相关源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashSet 的使用与 Vector 类似。</p><h4 id="5）TreeSet"><a href="#5）TreeSet" class="headerlink" title="5）TreeSet"></a>5）TreeSet</h4><p>TreeSet 集合实现了自动排序，也就是说 TreeSet 会把你插入数据进行自动排序。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet treeSet = <span class="keyword">new</span> TreeSet();</span><br><span class="line">treeSet.add(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">treeSet.add(<span class="string">&quot;camel&quot;</span>);</span><br><span class="line">treeSet.add(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">treeSet.add(<span class="string">&quot;ant&quot;</span>);</span><br><span class="line">System.out.println(treeSet);</span><br></pre></td></tr></table></figure><p>程序执行结果：<code>[ant, camel, cat, dog]</code></p><p>可以看出，TreeSet 的使用与 Vector 类似，只是实现了自动排序。</p><h4 id="6）LinkedHashSet"><a href="#6）LinkedHashSet" class="headerlink" title="6）LinkedHashSet"></a>6）LinkedHashSet</h4><p>LinkedHashSet 是按照元素的 hashCode 值来决定元素的存储位置，但同时又使用链表来维护元素的次序，这样使得它看起来像是按照插入顺序保存的。</p><p>LinkedHashSet 的使用与 Vector 类似。</p><h3 id="集合与数组"><a href="#集合与数组" class="headerlink" title="集合与数组"></a>集合与数组</h3><p>集合和数组的转换可使用 toArray() 和 Arrays.asList() 来实现，请参考以下代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line"><span class="comment">// 集合转数组</span></span><br><span class="line">String[] arr = list.toArray(<span class="keyword">new</span> String[list.size()]);</span><br><span class="line"><span class="comment">// 数组转集合</span></span><br><span class="line">List&lt;String&gt; list2 = Arrays.asList(arr);</span><br></pre></td></tr></table></figure><p>集合与数组的区别，可以参考<a href="https://gitbook.cn/gitchat/column/5d493b4dcb702a087ef935d9/topic/5d4d7ea069004b174ccfffef">「数组和排序算法的应用 + 面试题」</a>的内容。</p><h3 id="集合排序"><a href="#集合排序" class="headerlink" title="集合排序"></a>集合排序</h3><p>在 Java 语言中排序提供了两种方式：Comparable 和 Comparator，它们的区别也是常见的面试题之一。下面我们彻底地来了解一下 Comparable 和 Comparator 的使用与区别。</p><h4 id="1）Comparable"><a href="#1）Comparable" class="headerlink" title="1）Comparable"></a>1）Comparable</h4><p>Comparable 位于 java.lang 包下，是一个排序接口，也就是说如果一个类实现了 Comparable 接口，就意味着该类有了排序功能。</p><p>Comparable 接口只包含了一个函数，定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Comparable 使用示例</strong>，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComparableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog[] dogs = <span class="keyword">new</span> Dog[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Dog(<span class="string">&quot;老旺财&quot;</span>, <span class="number">10</span>),</span><br><span class="line">                <span class="keyword">new</span> Dog(<span class="string">&quot;小旺财&quot;</span>, <span class="number">3</span>),</span><br><span class="line">                <span class="keyword">new</span> Dog(<span class="string">&quot;二旺财&quot;</span>, <span class="number">5</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// Comparable 排序</span></span><br><span class="line">        Arrays.sort(dogs);</span><br><span class="line">        <span class="keyword">for</span> (Dog d : dogs) &#123;</span><br><span class="line">            System.out.println(d.getName() + <span class="string">&quot;：&quot;</span> + d.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Dog</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Dog o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age - o.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">小旺财：<span class="number">3</span></span><br><span class="line">二旺财：<span class="number">5</span></span><br><span class="line">老旺财：<span class="number">10</span></span><br></pre></td></tr></table></figure><p>如果 Dog 类未实现 Comparable 执行代码会报程序异常的信息，错误信息为：</p><blockquote><p>Exception in thread “main” java.lang.ClassCastException: xxx cannot be cast to java.lang.Comparable</p><p>compareTo() 返回值有三种：</p></blockquote><ul><li>e1.compareTo(e2) &gt; 0 即 e1 &gt; e2；</li><li>e1.compareTo(e2) = 0 即 e1 = e2；</li><li>e1.compareTo(e2) &lt; 0 即 e1 &lt; e2。</li></ul><h4 id="2）Comparator"><a href="#2）Comparator" class="headerlink" title="2）Comparator"></a>2）Comparator</h4><p>Comparator 是一个外部比较器，位于 java.util 包下，之所以说 Comparator 是一个外部比较器，是因为它无需在比较类中实现 Comparator 接口，而是要新创建一个比较器类来进行比较和排序。</p><p>Comparator 接口包含的主要方法为 compare()，定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Comparator 使用示例</strong>，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComparatorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog[] dogs = <span class="keyword">new</span> Dog[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Dog(<span class="string">&quot;老旺财&quot;</span>, <span class="number">10</span>),</span><br><span class="line">                <span class="keyword">new</span> Dog(<span class="string">&quot;小旺财&quot;</span>, <span class="number">3</span>),</span><br><span class="line">                <span class="keyword">new</span> Dog(<span class="string">&quot;二旺财&quot;</span>, <span class="number">5</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// Comparator 排序</span></span><br><span class="line">        Arrays.sort(dogs,<span class="keyword">new</span> DogComparator());</span><br><span class="line">        <span class="keyword">for</span> (Dog d : dogs) &#123;</span><br><span class="line">            System.out.println(d.getName() + <span class="string">&quot;：&quot;</span> + d.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Dog</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dog o1, Dog o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">小旺财：<span class="number">3</span></span><br><span class="line">二旺财：<span class="number">5</span></span><br><span class="line">老旺财：<span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="相关面试题-11"><a href="#相关面试题-11" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="List-和-Set-有什么区别？"><a href="#List-和-Set-有什么区别？" class="headerlink" title="List 和 Set 有什么区别？"></a>List 和 Set 有什么区别？</h4><p>答：区别分为以下几个方面：</p><ul><li>List 允许有多个 null 值，Set 只允许有一个 null 值；</li><li>List 允许有重复元素，Set 不允许有重复元素；</li><li>List 可以保证每个元素的存储顺序，Set 无法保证元素的存储顺序。</li></ul><h4 id="哪种集合可以实现自动排序？"><a href="#哪种集合可以实现自动排序？" class="headerlink" title="哪种集合可以实现自动排序？"></a>哪种集合可以实现自动排序？</h4><p>答：TreeSet 集合实现了元素的自动排序，也就是说无需任何操作，即可实现元素的自动排序功能。</p><h4 id="Vector-和-ArrayList-初始化大小和容量扩充有什么区别？"><a href="#Vector-和-ArrayList-初始化大小和容量扩充有什么区别？" class="headerlink" title="Vector 和 ArrayList 初始化大小和容量扩充有什么区别？"></a>Vector 和 ArrayList 初始化大小和容量扩充有什么区别？</h4><p>答：Vector 和 ArrayList 的默认容量都为 10，源码如下。</p><p>Vector 默认容量源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList 默认容量源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>Vector 容量扩充默认增加 1 倍，源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 capacityIncrement 为初始化 Vector 指定的，默认情况为 0。</p><p>ArrayList 容量扩充默认增加大概 0.5 倍（oldCapacity + (oldCapacity &gt;&gt; 1)），源码如下（JDK 8）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Vector、ArrayList、LinkedList-有什么区别？"><a href="#Vector、ArrayList、LinkedList-有什么区别？" class="headerlink" title="Vector、ArrayList、LinkedList 有什么区别？"></a>Vector、ArrayList、LinkedList 有什么区别？</h4><p>答：这三者都是 List 的子类，因此功能比较相似，比如增加和删除操作、查找元素等，但在性能、线程安全等方面表现却又不相同，差异如下：</p><ul><li>Vector 是 Java 早期提供的动态数组，它使用 synchronized 来保证线程安全，如果非线程安全需要不建议使用，毕竟线程同步是有性能开销的；</li><li>ArrayList 是最常用的动态数组，本身并不是线程安全的，因此性能要好很多，与 Vector 类似，它也是动态调整容量的，只不过 Vector 扩容时会增加 1 倍，而 ArrayList 会增加 50%；</li><li>LinkedList 是双向链表集合，因此它不需要像上面两种那样调整容量，它也是非线程安全的集合。</li></ul><h4 id="Vector、ArrayList、LinkedList-使用场景有什么区别？"><a href="#Vector、ArrayList、LinkedList-使用场景有什么区别？" class="headerlink" title="Vector、ArrayList、LinkedList 使用场景有什么区别？"></a>Vector、ArrayList、LinkedList 使用场景有什么区别？</h4><p>答：Vector 和 ArrayList 的内部结构是以数组形式存储的，因此非常适合随机访问，但非尾部的删除或新增性能较差，比如我们在中间插入一个元素，就需要把后续的所有元素都进行移动。</p><p>LinkedList 插入和删除元素效率比较高，但随机访问性能会比以上两个动态数组慢。</p><h4 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h4><p>答：Collection 和 Collections 的区别如下：</p><ul><li>Collection 是集合类的上级接口，继承它的主要有 List 和 Set；</li><li>Collections 是针对集合类的一个帮助类，它提供了一些列的静态方法实现，如 Collections.sort() 排序、Collections.reverse() 逆序等。</li></ul><h4 id="以下选项没有继承-Collection-接口的是？"><a href="#以下选项没有继承-Collection-接口的是？" class="headerlink" title="以下选项没有继承 Collection 接口的是？"></a>以下选项没有继承 Collection 接口的是？</h4><p>A：List<br>B：Set<br>C：Map<br>D：HashSet</p><p>答：C</p><h4 id="LinkedHashSet-如何保证有序和唯一性？"><a href="#LinkedHashSet-如何保证有序和唯一性？" class="headerlink" title="LinkedHashSet 如何保证有序和唯一性？"></a>LinkedHashSet 如何保证有序和唯一性？</h4><p>答：LinkedHashSet 底层数据结构由哈希表和链表组成，链表保证了元素的有序即存储和取出一致，哈希表保证了元素的唯一性。</p><h4 id="HashSet-是如何保证数据不可重复的？"><a href="#HashSet-是如何保证数据不可重复的？" class="headerlink" title="HashSet 是如何保证数据不可重复的？"></a>HashSet 是如何保证数据不可重复的？</h4><p>答：HashSet 的底层其实就是 HashMap，只不过 HashSet 实现了 Set 接口并且把数据作为 K 值，而 V 值一直使用一个相同的虚值来保存，我们可以看到源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;<span class="comment">// 调用 HashMap 的 put 方法,PRESENT 是一个至始至终都相同的虚值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 HashMap 的 K 值本身就不允许重复，并且在 HashMap 中如果 K/V 相同时，会用新的 V 覆盖掉旧的 V，然后返回旧的 V，那么在 HashSet 中执行这一句话始终会返回一个 false，导致插入失败，这样就保证了数据的不可重复性。</p><h4 id="执行以下程序会输出什么结果？为什么？"><a href="#执行以下程序会输出什么结果？为什么？" class="headerlink" title="执行以下程序会输出什么结果？为什么？"></a>执行以下程序会输出什么结果？为什么？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer num = <span class="number">10</span>;</span><br><span class="line">Integer num2 = <span class="number">5</span>;</span><br><span class="line">System.out.println(num.compareTo(num2));</span><br></pre></td></tr></table></figure><p>答：程序输出的结果是 <code>1</code>，因为 Integer 默认实现了 compareTo 方法，定义了自然排序规则，所以当 num 比 num2 大时会返回 1，Integer 相关源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Integer anotherInteger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compare(<span class="keyword">this</span>.value, anotherInteger.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &lt; y) ? -<span class="number">1</span> : ((x == y) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何用程序实现后进先出的栈结构？"><a href="#如何用程序实现后进先出的栈结构？" class="headerlink" title="如何用程序实现后进先出的栈结构？"></a>如何用程序实现后进先出的栈结构？</h4><p>答：可以使用集合中的 Stack 实现，Stack 是标准的后进先出的栈结构，使用 Stack 中的 pop() 方法返回栈顶元素并删除该元素，示例代码如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line">stack.push(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 移除并返回栈顶元素</span></span><br><span class="line">    System.out.print(stack.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果：<code>c b a</code></p><h4 id="LinkedList-中的-peek-和-poll-有什么区别？"><a href="#LinkedList-中的-peek-和-poll-有什么区别？" class="headerlink" title="LinkedList 中的 peek() 和 poll() 有什么区别？"></a>LinkedList 中的 peek() 和 poll() 有什么区别？</h4><p>答：peek() 方法返回第一个元素，但不删除当前元素，当元素不存在时返回 null；poll() 方法返回第一个元素并删除此元素，当元素不存在时返回 null。</p><h4 id="Comparable-和-Comparator-有哪些区别？"><a href="#Comparable-和-Comparator-有哪些区别？" class="headerlink" title="Comparable 和 Comparator 有哪些区别？"></a>Comparable 和 Comparator 有哪些区别？</h4><p>答：Comparable 和 Comparator 的主要区别如下：</p><ul><li>Comparable 位于 java.lang 包下，而 Comparator 位于 java.util 包下；</li><li>Comparable 在排序类的内部实现，而 Comparator 在排序类的外部实现；</li><li>Comparable 需要重写 CompareTo() 方法，而 Comparator 需要重写 Compare() 方法；</li><li>Comparator 在类的外部实现，更加灵活和方便。</li></ul><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>本文介绍的集合都实现自 Collection，因此它们都有同样的操作方法，如 add()、addAll()、remove() 等，Collection 接口的方法列表如下图：</p><p><img src="/" alt="img" class="lazyload" data-src="https://images.gitbook.cn/4cfddf30-ca63-11e9-bd50-998f3938aecb"></p><p>当然部分集合也在原有方法上扩充了自己特有的方法，如 LinkedList 的 offer()、push() 等方法。本文也提供了数组和集合互转方法，List.toArray() 把集合转换为数组，Arrays.asList(array) 把数组转换为集合。最后介绍了 Comparable 和 Comparator 的使用和区别，Comparable 和 Comparator 是 Java 语言排序提供的两种排序方式，Comparable 位于 java.lang 包下，如果一个类实现了 Comparable 接口，就意味着该类有了排序功能；而 Comparator 位于 java.util 包下，是一个外部比较器，它无需在比较类中实现 Comparator 接口，而是要新创建一个比较器类来进行比较和排序。</p><h2 id="集合详解之-Map-面试题"><a href="#集合详解之-Map-面试题" class="headerlink" title="集合详解之 Map + 面试题"></a>集合详解之 Map + 面试题</h2><p>集合有两个大接口：Collection 和 Map，本文重点来讲解集合中另一个常用的集合类型 Map。</p><p>以下是 Map 的继承关系图：</p><p><img src="/" alt="11" class="lazyload" data-src="https://images.gitbook.cn/e9786a20-e691-11e9-80c2-21d8cc9d922e"></p><h3 id="Map-简介"><a href="#Map-简介" class="headerlink" title="Map 简介"></a>Map 简介</h3><p>Map 常用的实现类如下：</p><ul><li><strong>Hashtable</strong>：Java 早期提供的一个哈希表实现，它是线程安全的，不支持 null 键和值，因为它的性能不如 ConcurrentHashMap，所以很少被推荐使用。</li><li><strong>HashMap</strong>：最常用的哈希表实现，如果程序中没有多线程的需求，HashMap 是一个很好的选择，支持 null 键和值，如果在多线程中可用 ConcurrentHashMap 替代。</li><li><strong>TreeMap</strong>：基于红黑树的一种提供顺序访问的 Map，自身实现了 key 的自然排序，也可以指定 Comparator 来自定义排序。</li><li><strong>LinkedHashMap</strong>：HashMap 的一个子类，保存了记录的插入顺序，可在遍历时保持与插入一样的顺序。</li></ul><h3 id="Map-常用方法"><a href="#Map-常用方法" class="headerlink" title="Map 常用方法"></a>Map 常用方法</h3><p>常用方法包括：put、remove、get、size 等，所有方法如下图：</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/319c8410-ccc7-11e9-93b3-c35630e1847c"></p><p>使用示例，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="comment">// 增加元素</span></span><br><span class="line">hashMap.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;30&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;你猜&quot;</span>);</span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">hashMap.remove(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="comment">// 查找单个元素</span></span><br><span class="line">System.out.println(hashMap.get(<span class="string">&quot;age&quot;</span>));</span><br><span class="line"><span class="comment">// 循环所有的 key</span></span><br><span class="line"><span class="keyword">for</span> (Object k : hashMap.keySet()) &#123;</span><br><span class="line">    System.out.println(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环所有的值</span></span><br><span class="line"><span class="keyword">for</span> (Object v : hashMap.values()) &#123;</span><br><span class="line">    System.out.println(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上为 HashMap 的使用示例，其他类的使用也是类似。</p><h3 id="HashMap-数据结构"><a href="#HashMap-数据结构" class="headerlink" title="HashMap 数据结构"></a>HashMap 数据结构</h3><p>HashMap 底层的数据是数组被成为哈希桶，每个桶存放的是链表，链表中的每个节点，就是 HashMap 中的每个元素。在 JDK 8 当链表长度大于等于 8 时，就会转成红黑树的数据结构，以提升查询和插入的效率。</p><p>HashMap 数据结构，如下图：</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/54a52ca0-ccc7-11e9-b229-e35eb1d6e740"></p><h3 id="HashMap-重要方法"><a href="#HashMap-重要方法" class="headerlink" title="HashMap 重要方法"></a>HashMap 重要方法</h3><h4 id="1）添加方法：put-Object-key-Object-value"><a href="#1）添加方法：put-Object-key-Object-value" class="headerlink" title="1）添加方法：put(Object key, Object value)"></a>1）添加方法：put(Object key, Object value)</h4><p>执行流程如下：</p><ul><li>对 key 进行 hash 操作，计算存储 index；</li><li>判断是否有哈希碰撞，如果没碰撞直接放到哈希桶里，如果有碰撞则以链表的形式存储；</li><li>判断已有元素的类型，决定是追加树还是追加链表，当链表大于等于 8 时，把链表转换成红黑树；</li><li>如果节点已经存在就替换旧值；</li><li>判断是否超过阀值，如果超过就要扩容。</li></ul><p>源码及说明：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对 key 进行 hash()</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">  <span class="comment">// 对 key 进行 hash() 的具体实现</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 计算 index，并对 null 做处理</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 节点存在</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 该链为树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写入</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 超过load factor*current capacity，resize</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put() 执行流程图如下：</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/727836f0-ccc7-11e9-a9bd-857608719494"></p><h4 id="2）获取方法：get-Object-key"><a href="#2）获取方法：get-Object-key" class="headerlink" title="2）获取方法：get(Object key)"></a>2）获取方法：get(Object key)</h4><p>执行流程如下：</p><ul><li>首先比对首节点，如果首节点的 hash 值和 key 的 hash 值相同，并且首节点的键对象和 key 相同（地址相同或 equals 相等），则返回该节点；</li><li>如果首节点比对不相同、那么看看是否存在下一个节点，如果存在的话，可以继续比对，如果不存在就意味着 key 没有匹配的键值对。</li></ul><p>源码及说明：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 该方法是 Map.get 方法的具体实现</span></span><br><span class="line"><span class="comment">* 接收两个参数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> hash key 的 hash 值，根据 hash 值在节点数组中寻址，该 hash 值是通过 hash(key) 得到的</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> key key 对象，当存在 hash 碰撞时，要逐个比对是否相等</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 查找到则返回键值对节点对象，否则返回 null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k; <span class="comment">// 声明节点数组对象、链表的第一个节点对象、循环遍历时的当前节点对象、数组长度、节点的键对象</span></span><br><span class="line">    <span class="comment">// 节点数组赋值、数组长度赋值、通过位运算得到求模结果确定链表的首节点</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// 首先比对首节点，如果首节点的 hash 值和 key 的 hash 值相同，并且首节点的键对象和 key 相同（地址相同或 equals 相等），则返回该节点</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first; <span class="comment">// 返回首节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果首节点比对不相同、那么看看是否存在下一个节点，如果存在的话，可以继续比对，如果不存在就意味着 key 没有匹配的键值对    </span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果存在下一个节点 e，那么先看看这个首节点是否是个树节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">// 如果是首节点是树节点，那么遍历树来查找</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果首节点不是树节点，就说明还是个普通的链表，那么逐个遍历比对即可    </span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 比对时还是先看 hash 值是否相同、再看地址或 equals</span></span><br><span class="line">                    <span class="keyword">return</span> e; <span class="comment">// 如果当前节点e的键对象和key相同，那么返回 e</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>); <span class="comment">// 看看是否还有下一个节点，如果有，继续下一轮比对，否则跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 在比对完了应该比对的树节点 或者全部的链表节点 都没能匹配到 key，那么就返回 null</span></span><br></pre></td></tr></table></figure><h3 id="相关面试题-12"><a href="#相关面试题-12" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="Map-常见实现类有哪些？"><a href="#Map-常见实现类有哪些？" class="headerlink" title="Map 常见实现类有哪些？"></a>Map 常见实现类有哪些？</h4><p>答：Map 的常见实现类如下列表：</p><ul><li>Hashtable：Java 早期提供的一个哈希表实现，它是线程安全的，不支持 null 键和值，因为它的性能不如 ConcurrentHashMap，所以很少被推荐使用；</li><li>HashMap：最常用的哈希表实现，如果程序中没有多线程的需求，HashMap 是一个很好的选择，支持 null 键和值，如果在多线程中可用 ConcurrentHashMap 替代；</li><li>TreeMap：基于红黑树的一种提供顺序访问的 Map，自身实现了 key 的自然排序，也可以指定的 Comparator 来自定义排序；</li><li>LinkedHashMap：HashMap 的一个子类，保存了记录的插入顺序，可在遍历时保持与插入一样的顺序。</li></ul><h4 id="使用-HashMap-可能会遇到什么问题？如何避免？"><a href="#使用-HashMap-可能会遇到什么问题？如何避免？" class="headerlink" title="使用 HashMap 可能会遇到什么问题？如何避免？"></a>使用 HashMap 可能会遇到什么问题？如何避免？</h4><p>答：HashMap 在并发场景中可能出现死循环的问题，这是因为 HashMap 在扩容的时候会对链表进行一次倒序处理，假设两个线程同时执行扩容操作，第一个线程正在执行 B→A 的时候，第二个线程又执行了 A→B ，这个时候就会出现 B→A→B 的问题，造成死循环。<br>解决的方法：升级 JDK 版本，在 JDK 8 之后扩容不会再进行倒序，因此死循环的问题得到了极大的改善，但这不是终极的方案，因为 HashMap 本来就不是用在多线程版本下的，如果是多线程可使用 ConcurrentHashMap 替代 HashMap。</p><h4 id="以下说法正确的是？-1"><a href="#以下说法正确的是？-1" class="headerlink" title="以下说法正确的是？"></a>以下说法正确的是？</h4><p>A：Hashtable 和 HashMap 都是非线程安全的<br>B：ConcurrentHashMap 允许 null 作为 key<br>C：HashMap 允许 null 作为 key<br>D：Hashtable 允许 null 作为 key<br>答：C<br>题目解析：Hashtable 是线程安全的，ConcurrentHashMap 和 Hashtable 是不允许 null 作为键和值的。</p><h4 id="TreeMap-怎么实现根据-value-值倒序？"><a href="#TreeMap-怎么实现根据-value-值倒序？" class="headerlink" title="TreeMap 怎么实现根据 value 值倒序？"></a>TreeMap 怎么实现根据 value 值倒序？</h4><p>答：使用 <code>Collections.sort(list, new Comparator&lt;Map.Entry&lt;String, String&gt;&gt;()</code> 自定义比较器实现，先把 TreeMap 转换为 ArrayList，在使用 Collections.sort() 根据 value 进行倒序，完整的实现代码如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap&lt;String, String&gt; treeMap = <span class="keyword">new</span> TreeMap();</span><br><span class="line">treeMap.put(<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;dog&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;camel&quot;</span>, <span class="string">&quot;camel&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;cat&quot;</span>);</span><br><span class="line">treeMap.put(<span class="string">&quot;ant&quot;</span>, <span class="string">&quot;ant&quot;</span>);</span><br><span class="line"><span class="comment">// map.entrySet() 转成 List</span></span><br><span class="line">List&lt;Map.Entry&lt;String, String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(treeMap.entrySet());</span><br><span class="line"><span class="comment">// 通过比较器实现比较排序</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;String, String&gt; m1, Map.Entry&lt;String, String&gt; m2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m2.getValue().compareTo(m1.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; item : list) &#123;</span><br><span class="line">  System.out.println(item.getKey() + <span class="string">&quot;:&quot;</span> + item.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dog:dog</span><br><span class="line">cat:cat</span><br><span class="line">camel:camel</span><br><span class="line">ant:ant</span><br></pre></td></tr></table></figure><h4 id="以下哪个-Set-实现了自动排序？"><a href="#以下哪个-Set-实现了自动排序？" class="headerlink" title="以下哪个 Set 实现了自动排序？"></a>以下哪个 Set 实现了自动排序？</h4><p>A：LinedHashSet<br>B：HashSet<br>C：TreeSet<br>D：AbstractSet</p><p>答：C</p><h4 id="以下程序运行的结果是什么？"><a href="#以下程序运行的结果是什么？" class="headerlink" title="以下程序运行的结果是什么？"></a>以下程序运行的结果是什么？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hashtable hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">hashtable.put(<span class="string">&quot;table&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">System.out.println(hashtable.get(<span class="string">&quot;table&quot;</span>));</span><br></pre></td></tr></table></figure><p>答：程序执行报错：java.lang.NullPointerException。Hashtable 不允许 null 键和值。</p><h4 id="HashMap-有哪些重要的参数？用途分别是什么？"><a href="#HashMap-有哪些重要的参数？用途分别是什么？" class="headerlink" title="HashMap 有哪些重要的参数？用途分别是什么？"></a>HashMap 有哪些重要的参数？用途分别是什么？</h4><p>答：HashMap 有两个重要的参数：容量（Capacity）和负载因子（LoadFactor）。</p><ul><li>容量（Capacity）：是指 HashMap 中桶的数量，默认的初始值为 16。</li><li>负载因子（LoadFactor）：也被称为装载因子，LoadFactor 是用来判定 HashMap 是否扩容的依据，默认值为 0.75f，装载因子的计算公式 = HashMap 存放的 KV 总和（size）/ Capacity。</li></ul><h4 id="HashMap-和-Hashtable-有什么区别？"><a href="#HashMap-和-Hashtable-有什么区别？" class="headerlink" title="HashMap 和 Hashtable 有什么区别？"></a>HashMap 和 Hashtable 有什么区别？</h4><p>答：HashMap 和 Hashtable 区别如下：</p><ul><li>Hashtable 使用了 synchronized 关键字来保障线程安全，而 HashMap 是非线程安全的；</li><li>HashMap 允许 K/V 都为 null，而 Hashtable K/V 都不允许 null；</li><li>HashMap 继承自 AbstractMap 类；而 Hashtable 继承自 Dictionary 类。</li></ul><h4 id="什么是哈希冲突？"><a href="#什么是哈希冲突？" class="headerlink" title="什么是哈希冲突？"></a>什么是哈希冲突？</h4><p>答：当输入两个不同值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。</p><h4 id="有哪些方法可以解决哈希冲突？"><a href="#有哪些方法可以解决哈希冲突？" class="headerlink" title="有哪些方法可以解决哈希冲突？"></a>有哪些方法可以解决哈希冲突？</h4><p>答：哈希冲突的常用解决方案有以下 4 种。</p><ul><li>开放定址法：当关键字的哈希地址 p=H（key）出现冲突时，以 p 为基础，产生另一个哈希地址 p1，如果 p1 仍然冲突，再以 p 为基础，产生另一个哈希地址 p2，循环此过程直到找出一个不冲突的哈希地址，将相应元素存入其中。</li><li>再哈希法：这种方法是同时构造多个不同的哈希函数，当哈希地址 Hi=RH1（key）发生冲突时，再计算 Hi=RH2（key），循环此过程直到找到一个不冲突的哈希地址，这种方法唯一的缺点就是增加了计算时间。</li><li>链地址法：这种方法的基本思想是将所有哈希地址为 i 的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第 i 个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</li><li>建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</li></ul><h4 id="HashMap-使用哪种方法来解决哈希冲突（哈希碰撞）？"><a href="#HashMap-使用哪种方法来解决哈希冲突（哈希碰撞）？" class="headerlink" title="HashMap 使用哪种方法来解决哈希冲突（哈希碰撞）？"></a>HashMap 使用哪种方法来解决哈希冲突（哈希碰撞）？</h4><p>答：HashMap 使用链表和红黑树来解决哈希冲突，详见本文 put() 方法的执行过程。</p><h4 id="HashMap-的扩容为什么是-2-n-？"><a href="#HashMap-的扩容为什么是-2-n-？" class="headerlink" title="HashMap 的扩容为什么是 2^n ？"></a>HashMap 的扩容为什么是 2^n ？</h4><p>答：这样做的目的是为了让散列更加均匀，从而减少哈希碰撞，以提供代码的执行效率。</p><h4 id="有哈希冲突的情况下-HashMap-如何取值？"><a href="#有哈希冲突的情况下-HashMap-如何取值？" class="headerlink" title="有哈希冲突的情况下 HashMap 如何取值？"></a>有哈希冲突的情况下 HashMap 如何取值？</h4><p>答：如果有哈希冲突，HashMap 会循环链表中的每项 key 进行 equals 对比，返回对应的元素。相关源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 比对时还是先看 hash 值是否相同、再看地址或 equals</span></span><br><span class="line">        <span class="keyword">return</span> e; <span class="comment">// 如果当前节点 e 的键对象和 key 相同，那么返回 e</span></span><br><span class="line">&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>); <span class="comment">// 看看是否还有下一个节点，如果有，继续下一轮比对，否则跳出循环</span></span><br></pre></td></tr></table></figure><h4 id="以下程序会输出什么结果？"><a href="#以下程序会输出什么结果？" class="headerlink" title="以下程序会输出什么结果？"></a>以下程序会输出什么结果？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || !(o <span class="keyword">instanceof</span> Person)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getAge().equals(((Person) o).getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Person, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">18</span>);</span><br><span class="line">        hashMap.put(person, <span class="number">1</span>);</span><br><span class="line">        System.out.println(hashMap.get(<span class="keyword">new</span> Person(<span class="number">18</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：1<br>题目解析：因为 Person 重写了 equals 和 hashCode 方法，所有 person 对象和 new Person(18) 的键值相同，所以结果就是 1。</p><h4 id="为什么重写-equals-时一定要重写-hashCode-？"><a href="#为什么重写-equals-时一定要重写-hashCode-？" class="headerlink" title="为什么重写 equals() 时一定要重写 hashCode()？"></a>为什么重写 equals() 时一定要重写 hashCode()？</h4><p>答：因为 Java 规定，如果两个对象 equals 比较相等（结果为 true），那么调用 hashCode 也必须相等。如果重写了 equals() 但没有重写 hashCode()，就会与规定相违背，比如以下代码（故意注释掉 hashCode 方法）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || !(o <span class="keyword">instanceof</span> Person)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getAge().equals(((Person) o).getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    public int hashCode() &#123;</span></span><br><span class="line"><span class="comment">//        return age.hashCode();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">18</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">18</span>);</span><br><span class="line">        System.out.println(p1.equals(p2));</span><br><span class="line">        System.out.println(p1.hashCode() + <span class="string">&quot; : &quot;</span> + p2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="number">21685669</span> : <span class="number">2133927002</span></span><br></pre></td></tr></table></figure><p>如果重写 hashCode() 之后，执行的结果是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="number">18</span> : <span class="number">18</span></span><br></pre></td></tr></table></figure><p>这样就符合了 Java 的规定，因此重写 equals() 时一定要重写 hashCode()。</p><h4 id="HashMap-在-JDK-7-多线程中使用会导致什么问题？"><a href="#HashMap-在-JDK-7-多线程中使用会导致什么问题？" class="headerlink" title="HashMap 在 JDK 7 多线程中使用会导致什么问题？"></a>HashMap 在 JDK 7 多线程中使用会导致什么问题？</h4><p>答：HashMap 在 JDK 7 中会导致死循环的问题。因为在 JDK 7 中，多线程进行 HashMap 扩容时会导致链表的循环引用，这个时候使用 get() 获取元素时就会导致死循环，造成 CPU 100% 的情况。</p><h4 id="HashMap-在-JDK-7-和-JDK-8-中有哪些不同？"><a href="#HashMap-在-JDK-7-和-JDK-8-中有哪些不同？" class="headerlink" title="HashMap 在 JDK 7 和 JDK 8 中有哪些不同？"></a>HashMap 在 JDK 7 和 JDK 8 中有哪些不同？</h4><p>答：HashMap 在 JDK 7 和 JDK 8 的主要区别如下。</p><ul><li>存储结构：JDK 7 使用的是数组 + 链表；JDK 8 使用的是数组 + 链表 + 红黑树。</li><li>存放数据的规则：JDK 7 无冲突时，存放数组；冲突时，存放链表；JDK 8 在没有冲突的情况下直接存放数组，有冲突时，当链表长度小于 8 时，存放在单链表结构中，当链表长度大于 8 时，树化并存放至红黑树的数据结构中。</li><li>插入数据方式：JDK 7 使用的是头插法（先将原位置的数据移到后 1 位，再插入数据到该位置）；JDK 8 使用的是尾插法（直接插入到链表尾部/红黑树）。</li></ul><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>通过本文可以了解到：</p><ul><li>Map 的常用实现类 Hashtable 是 Java 早期的线程安全的哈希表实现；</li><li>HashMap 是最常用的哈希表实现，但它是非线程安全的，可使用 ConcurrentHashMap 替代；</li><li>TreeMap 是基于红黑树的一种提供顺序访问的哈希表实现；</li><li>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，可在遍历时保持与插入一样的顺序。</li></ul><p>HashMap 在 JDK 7 可能在扩容时会导致链表的循环引用而造成 CPU 100%，HashMap 在 JDK 8 时数据结构变更为：数组 + 链表 + 红黑树的存储方式，在没有冲突的情况下直接存放数组，有冲突，当链表长度小于 8 时，存放在单链表结构中，当链表长度大于 8 时，树化并存放至红黑树的数据结构中。</p><h2 id="为什么要使用泛型和迭代器-面试题"><a href="#为什么要使用泛型和迭代器-面试题" class="headerlink" title="为什么要使用泛型和迭代器 + 面试题"></a>为什么要使用泛型和迭代器 + 面试题</h2><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="为什么要用泛型？"><a href="#为什么要用泛型？" class="headerlink" title="为什么要用泛型？"></a>为什么要用泛型？</h4><p>在泛型没有诞生之前，我们经常会遇到这样的问题，如以下代码所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">arrayList.add(<span class="number">24</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">    String str = (String) arrayList.get(i);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来好像没有什么大问题，也能正常编译，但真正运行起来就会报错：</p><blockquote><p>Exception in thread “main” java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</p><p>at xxx(xxx.java:12)</p><p>类型转换出错，当我们给 ArrayList 放入不同类型的数据，却使用一种类型进行接收的时候，就会出现很多类似的错误，可能更多的时候，是因为开发人员的不小心导致的。那有没有好的办法可以杜绝此类问题的发生呢？这个时候 Java 语言提供了一个很好的解决方案——“泛型”。</p></blockquote><h4 id="泛型介绍"><a href="#泛型介绍" class="headerlink" title="泛型介绍"></a>泛型介绍</h4><p><strong>泛型</strong>：泛型本质上是类型参数化，解决了不确定对象的类型问题。<br>泛型的使用，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">&quot;Java&quot;</span>);</span><br></pre></td></tr></table></figure><p>这个时候如果给 arrayList 添加非 String 类型的元素，编译器就会报错，提醒开发人员插入相同类型的元素。</p><p>报错信息如下图所示：</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/83dce010-cdeb-11e9-932d-6123ff488b55"></p><p>这样就可以避免开头示例中，类型不一致导致程序运行过程中报错的问题了。</p><h4 id="泛型的优点"><a href="#泛型的优点" class="headerlink" title="泛型的优点"></a>泛型的优点</h4><p>泛型的优点主要体现在以下三个方面。</p><ul><li>安全：不用担心程序运行过程中出现类型转换的错误。</li><li>避免了类型转换：如果是非泛型，获取到的元素是 Object 类型的，需要强制类型转换。</li><li>可读性高：编码阶段就明确的知道集合中元素的类型。</li></ul><h3 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（Iterator）</h3><h4 id="为什么要用迭代器？"><a href="#为什么要用迭代器？" class="headerlink" title="为什么要用迭代器？"></a>为什么要用迭代器？</h4><p>我们回想一下，在迭代器（Iterator）没有出现之前，如果要遍历数组和集合，需要使用方法。</p><p>数组遍历，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Java虚拟机&quot;</span>, <span class="string">&quot;Java中文社群&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    String item = arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合遍历，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;Java虚拟机&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    String item = list.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而迭代器的产生，就是为不同类型的容器遍历，提供标准统一的方法。</p><p>迭代器遍历，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Object object = iterator.next();</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：使用了迭代器就可以不用关注容器的内部细节，用同样的方式遍历不同类型的容器。</p><h4 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h4><p>迭代器是用来遍历容器内所有元素对象的，也是一种常见的设计模式。</p><p>迭代器包含以下四个方法。</p><ul><li>hasNext():boolean —— 容器内是否还有可以访问的元素。</li><li>next():E —— 返回下一个元素。</li><li>remove():void —— 删除当前元素。</li><li>forEachRemaining(Consumer):void —— JDK 8 中添加的，提供一个 lambda 表达式遍历容器元素。</li></ul><p>迭代器使用如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;Java虚拟机&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">Iterator iterator =  list.iterator();</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    String str = (String) iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (str.equals(<span class="string">&quot;Java中文社群&quot;</span>))&#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Java, Java虚拟机]</span><br></pre></td></tr></table></figure><p>forEachRemaining 使用如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;Java虚拟机&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"><span class="comment">// forEachRemaining 使用</span></span><br><span class="line">list.iterator().forEachRemaining(item -&gt; System.out.println(item));</span><br></pre></td></tr></table></figure><h3 id="相关面试题-13"><a href="#相关面试题-13" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="为什么迭代器的-next-返回的是-Object-类型？"><a href="#为什么迭代器的-next-返回的是-Object-类型？" class="headerlink" title="为什么迭代器的 next() 返回的是 Object 类型？"></a>为什么迭代器的 next() 返回的是 Object 类型？</h4><p>答：因为迭代器不需要关注容器的内部细节，所以 next() 返回 Object 类型就可以接收任何类型的对象。</p><h4 id="2-HashMap-的遍历方式都有几种？"><a href="#2-HashMap-的遍历方式都有几种？" class="headerlink" title="2.HashMap 的遍历方式都有几种？"></a>2.HashMap 的遍历方式都有几种？</h4><p>答：HashMap 的遍历分为以下四种方式。</p><ul><li>方式一：entrySet 遍历</li><li>方式二：iterator 遍历</li><li>方式三：遍历所有的 key 和 value</li><li>方式四：通过 key 值遍历</li></ul><p>以上方式的代码实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">hashMap.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">hashMap.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;你猜&quot;</span>);</span><br><span class="line"><span class="comment">// 方式一：entrySet 遍历</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry item : hashMap.entrySet()) &#123;</span><br><span class="line">  System.out.println(item.getKey() + <span class="string">&quot;:&quot;</span> + item.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式二：iterator 遍历</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = hashMap.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">  Map.Entry&lt;String, String&gt; entry = iterator.next();</span><br><span class="line">  System.out.println(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式三：遍历所有的 key 和 value</span></span><br><span class="line"><span class="keyword">for</span> (Object k : hashMap.keySet()) &#123;</span><br><span class="line">  <span class="comment">// 循环所有的 key</span></span><br><span class="line">  System.out.println(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Object v : hashMap.values()) &#123;</span><br><span class="line">  <span class="comment">// 循环所有的值</span></span><br><span class="line">  System.out.println(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式四：通过 key 值遍历</span></span><br><span class="line"><span class="keyword">for</span> (Object k : hashMap.keySet()) &#123;</span><br><span class="line">  System.out.println(k + <span class="string">&quot;:&quot;</span> + hashMap.get(k));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="以下关于泛型说法错误的是？"><a href="#以下关于泛型说法错误的是？" class="headerlink" title="以下关于泛型说法错误的是？"></a>以下关于泛型说法错误的是？</h4><p>A：泛型可以修饰类<br>B：泛型可以修饰方法<br>C：泛型不可以修饰接口<br>D：以上说法全错</p><p>答：选 C，泛型可以修饰类、方法、接口、变量。<br>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="以下程序执行的结果是什么？"><a href="#以下程序执行的结果是什么？" class="headerlink" title="以下程序执行的结果是什么？"></a>以下程序执行的结果是什么？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">System.out.println(list.getClass() == list2.getClass());</span><br></pre></td></tr></table></figure><p>答：程序的执行结果是 <code>true</code>。<br>题目解析：Java 中泛型在编译时会进行类型擦除，因此 <code>List&lt;String&gt; list</code> 和 <code>List&lt;Integer&gt; list2</code> 类型擦除后的结果都是 java.util.ArrayLis ，进而 list.getClass() == list2.getClass() 的结果也一定是 true。</p><h4 id="List-lt-Object-gt-和-List-lt-gt-有什么区别？"><a href="#List-lt-Object-gt-和-List-lt-gt-有什么区别？" class="headerlink" title="List&lt;Object&gt; 和 List&lt;?&gt; 有什么区别？"></a><code>List&lt;Object&gt;</code> 和 <code>List&lt;?&gt;</code> 有什么区别？</h4><p>答：<code>List&lt;?&gt;</code> 可以容纳任意类型，只不过 <code>List&lt;?&gt;</code> 被赋值之后，就不允许添加和修改操作了；而 <code>List&lt;Object&gt;</code> 和 <code>List&lt;?&gt;</code> 不同的是它在赋值之后，可以进行添加和修改操作，如下图所示：</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/b3a90d00-cdeb-11e9-932d-6123ff488b55"></p><h4 id="可以把-List-lt-String-gt-赋值给-List-lt-Object-gt-吗？"><a href="#可以把-List-lt-String-gt-赋值给-List-lt-Object-gt-吗？" class="headerlink" title="可以把 List&lt;String&gt; 赋值给 List&lt;Object&gt; 吗？"></a>可以把 <code>List&lt;String&gt;</code> 赋值给 <code>List&lt;Object&gt;</code> 吗？</h4><p>答：不可以，编译器会报错，如下图所示：</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/cb2aa8d0-cdeb-11e9-b572-5118f14310d8"></p><h4 id="List-和-List-lt-Object-gt-的区别是什么？"><a href="#List-和-List-lt-Object-gt-的区别是什么？" class="headerlink" title="List 和 List&lt;Object&gt; 的区别是什么？"></a><code>List</code> 和 <code>List&lt;Object&gt;</code> 的区别是什么？</h4><p>答： <code>List</code> 和 <code>List&lt;Object&gt;</code> 都能存储任意类型的数据，但 <code>List</code> 和 <code>List&lt;Object&gt;</code> 的唯一区别就是，<code>List</code> 不会触发编译器的类型安全检查，比如把 <code>List&lt;String&gt;</code> 赋值给 <code>List</code> 是没有任何问题的，但赋值给 <code>List&lt;Object&gt;</code> 就不行，如下图所示：</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/e34947f0-cdeb-11e9-932d-6123ff488b55"></p><h4 id="以下程序执行的结果是？-6"><a href="#以下程序执行的结果是？-6" class="headerlink" title="以下程序执行的结果是？"></a>以下程序执行的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Java虚拟机&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">Iterator iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    String str = (String) iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (str.equals(<span class="string">&quot;Java中文社群&quot;</span>)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;Over&quot;</span>);</span><br></pre></td></tr></table></figure><p>答：程序打印结果是 <code>Over</code>。<br>题目解析：因为第一个 while 循环之后，iterator.hasNext() 返回值就为 false 了，所以不会进入第二个循环，之后打印最后的 Over。</p><h4 id="泛型的工作原理是什么？为什么要有类型擦除？"><a href="#泛型的工作原理是什么？为什么要有类型擦除？" class="headerlink" title="泛型的工作原理是什么？为什么要有类型擦除？"></a>泛型的工作原理是什么？为什么要有类型擦除？</h4><p>答：泛型是通过类型擦除来实现的，类型擦除指的是编译器在编译时，会擦除了所有类型相关的信息，比如 <code>List&lt;String&gt;</code> 在编译后就会变成 <code>List</code> 类型，这样做的目的就是确保能和 Java 5 之前的版本（二进制类库）进行兼容。</p><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>通过本文知道了泛型的优点：安全性、避免类型转换、提高了代码的可读性。泛型的本质是类型参数化，但编译之后会执行类型擦除，这样就可以和 Java 5 之前的二进制类库进行兼容。本文也介绍了迭代器（Iterator）的使用，使用迭代器的好处是不用关注容器的内部细节，用同样的方式遍历不同类型的容器。</p><h2 id="数据结构之队列的使用-面试题"><a href="#数据结构之队列的使用-面试题" class="headerlink" title="数据结构之队列的使用 + 面试题"></a>数据结构之队列的使用 + 面试题</h2><p>队列（Queue）：与栈相对的一种数据结构， 集合（Collection）的一个子类。队列允许在一端进行插入操作，而在另一端进行删除操作的线性表，栈的特点是后进先出，而队列的特点是先进先出。队列的用处很大，比如实现消息队列。</p><p>Queue 类关系图，如下图所示：</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/64fedb10-cebf-11e9-956a-e59402c7f15a"></p><p>注：为了让读者更直观地理解，上图为精简版的 Queue 类关系图。本文如无特殊说明，内容都是基于 Java 1.8 版本。</p><h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><h4 id="Queue-分类"><a href="#Queue-分类" class="headerlink" title="Queue 分类"></a>Queue 分类</h4><p>从上图可以看出 Queue 大体可分为以下三类。</p><ul><li>双端队列：双端队列（Deque）是 Queue 的子类也是 Queue 的补充类，头部和尾部都支持元素插入和获取。</li><li>阻塞队列：阻塞队列指的是在元素操作时（添加或删除），如果没有成功，会阻塞等待执行。例如，当添加元素时，如果队列元素已满，队列会阻塞等待直到有空位时再插入。</li><li>非阻塞队列：非阻塞队列和阻塞队列相反，会直接返回操作的结果，而非阻塞等待。双端队列也属于非阻塞队列。</li></ul><h4 id="Queue-方法说明"><a href="#Queue-方法说明" class="headerlink" title="Queue 方法说明"></a>Queue 方法说明</h4><p>Queue 常用方法，如下图所示：</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/78539610-cebf-11e9-956a-e59402c7f15a"></p><p>方法说明：</p><ul><li>add(E)：添加元素到队列尾部，成功返回 true，队列超出时抛出异常；</li><li>offer(E)：添加元素到队列尾部，成功返回 true，队列超出时返回 false；</li><li>remove()：删除元素，成功返回 true，失败返回 false；</li><li>poll()：获取并移除此队列的第一个元素，若队列为空，则返回 null；</li><li>peek()：获取但不移除此队列的第一个元素，若队列为空，则返回 null；</li><li>element()：获取但不移除此队列的第一个元素，若队列为空，则抛异常。</li></ul><h4 id="Queue-使用实例"><a href="#Queue-使用实例" class="headerlink" title="Queue 使用实例"></a>Queue 使用实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">linkedList.add(<span class="string">&quot;Dog&quot;</span>);</span><br><span class="line">linkedList.add(<span class="string">&quot;Camel&quot;</span>);</span><br><span class="line">linkedList.add(<span class="string">&quot;Cat&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (!linkedList.isEmpty()) &#123;</span><br><span class="line">    System.out.println(linkedList.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><blockquote><p>Dog</p><p>Camel</p><p>Cat</p></blockquote><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>BlockingQueue 在 java.util.concurrent 包下，其他阻塞类都实现自 BlockingQueue 接口，BlockingQueue 提供了线程安全的队列访问方式，当向队列中插入数据时，如果队列已满，线程则会阻塞等待队列中元素被取出后再插入；当从队列中取数据时，如果队列为空，则线程会阻塞等待队列中有新元素再获取。</p><p>BlockingQueue 核心方法</p><p>插入方法：</p><ul><li>add(E)：添加元素到队列尾部，成功返回 true，队列超出时抛出异常；</li><li>offer(E)：添加元素到队列尾部，成功返回 true，队列超出时返回 false ；</li><li>put(E)：将元素插入到队列的尾部，如果该队列已满，则一直阻塞。 删除方法：</li><li>remove(Object)：移除指定元素，成功返回 true，失败返回 false；</li><li>poll()： 获取并移除队列的第一个元素，如果队列为空，则返回 null；</li><li>take()：获取并移除队列第一个元素，如果没有元素则一直阻塞。 检查方法：</li><li>peek()：获取但不移除队列的第一个元素，若队列为空，则返回 null。</li></ul><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>LinkedBlockingQueue 是一个由链表实现的有界阻塞队列，容量默认值为 Integer.MAX_VALUE，也可以自定义容量，建议指定容量大小，默认大小在添加速度大于删除速度情况下有造成内存溢出的风险，LinkedBlockingQueue 是先进先出的方式存储元素。</p><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>ArrayBlockingQueue 是一个有边界的阻塞队列，它的内部实现是一个数组。它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。</p><p>ArrayBlockingQueue 也是先进先出的方式存储数据，ArrayBlockingQueue 内部的阻塞队列是通过重入锁 ReenterLock 和 Condition 条件队列实现的，因此 ArrayBlockingQueue 中的元素存在公平访问与非公平访问的区别，对于公平访问队列，被阻塞的线程可以按照阻塞的先后顺序访问队列，即先阻塞的线程先访问队列。而非公平队列，当队列可用时，阻塞的线程将进入争夺访问资源的竞争中，也就是说谁先抢到谁就执行，没有固定的先后顺序。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认非公平阻塞队列</span></span><br><span class="line">ArrayBlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">6</span>);</span><br><span class="line"><span class="comment">// 公平阻塞队列</span></span><br><span class="line">ArrayBlockingQueue queue2 = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">6</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayBlockingQueue 源码展示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>DelayQueue 是一个支持延时获取元素的无界阻塞队列，队列中的元素必须实现 Delayed 接口，在创建元素时可以指定延迟时间，只有到达了延迟的时间之后，才能获取到该元素。</p><p>实现了 Delayed 接口必须重写两个方法 ，getDelay(TimeUnit) 和 compareTo(Delayed)，如下代码所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayElement</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">// 获取剩余时间</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">// 队列里元素的排序依据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>DelayQueue 使用的完整示例</strong>，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        DelayQueue delayQueue = <span class="keyword">new</span> DelayQueue();</span><br><span class="line">        delayQueue.put(<span class="keyword">new</span> DelayElement(<span class="number">1000</span>));</span><br><span class="line">        delayQueue.put(<span class="keyword">new</span> DelayElement(<span class="number">3000</span>));</span><br><span class="line">        delayQueue.put(<span class="keyword">new</span> DelayElement(<span class="number">5000</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;开始时间：&quot;</span> +  DateFormat.getDateTimeInstance().format(<span class="keyword">new</span> Date()));</span><br><span class="line">        <span class="keyword">while</span> (!delayQueue.isEmpty())&#123;</span><br><span class="line">            System.out.println(delayQueue.take());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束时间：&quot;</span> +  DateFormat.getDateTimeInstance().format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayElement</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 延迟截止时间（单面：毫秒）</span></span><br><span class="line">        <span class="keyword">long</span> delayTime = System.currentTimeMillis();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DelayElement</span><span class="params">(<span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.delayTime = (<span class="keyword">this</span>.delayTime + delayTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">// 获取剩余时间</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> unit.convert(delayTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">// 队列里元素的排序依据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DateFormat.getDateTimeInstance().format(<span class="keyword">new</span> Date(delayTime));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><blockquote><p>开始时间：2019-6-13 20:40:38</p><p>2019-6-13 20:40:39</p><p>2019-6-13 20:40:41</p><p>2019-6-13 20:40:43</p><p>结束时间：2019-6-13 20:40:43</p></blockquote><h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><p><strong>ConcurrentLinkedQueue</strong> 是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，它会返回队列头部的元素。</p><p>它的入队和出队操作均利用 CAS（Compare And Set）更新，这样允许多个线程并发执行，并且不会因为加锁而阻塞线程，使得并发性能更好。</p><p>ConcurrentLinkedQueue 使用示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConcurrentLinkedQueue concurrentLinkedQueue = <span class="keyword">new</span> ConcurrentLinkedQueue();</span><br><span class="line">concurrentLinkedQueue.add(<span class="string">&quot;Dog&quot;</span>);</span><br><span class="line">concurrentLinkedQueue.add(<span class="string">&quot;Cat&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (!concurrentLinkedQueue.isEmpty()) &#123;</span><br><span class="line">    System.out.println(concurrentLinkedQueue.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>Dog</p><p>Cat</p></blockquote><p>可以看出不管是阻塞队列还是非阻塞队列，使用方法都是类似的，区别是底层的实现方式。</p><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p><strong>PriorityQueue</strong> 一个基于优先级堆的无界优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。优先级队列不允许使用 null 元素。</p><p><strong>PriorityQueue 代码使用示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 非自然排序，数字倒序</span></span><br><span class="line">        <span class="keyword">return</span> o2 - o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">priorityQueue.add(<span class="number">3</span>);</span><br><span class="line">priorityQueue.add(<span class="number">1</span>);</span><br><span class="line">priorityQueue.add(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">    Integer i = priorityQueue.poll();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果是：</p><blockquote><p>3</p><p>2</p><p>1</p></blockquote><p><strong>PriorityQueue 注意的点</strong>：</p><ul><li>PriorityQueue 是非线程安全的，在多线程情况下可使用 PriorityBlockingQueue 类替代；</li><li>PriorityQueue 不允许插入 null 元素。</li></ul><h3 id="相关面试题-14"><a href="#相关面试题-14" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="ArrayBlockingQueue-和-LinkedBlockingQueue-的区别是什么？"><a href="#ArrayBlockingQueue-和-LinkedBlockingQueue-的区别是什么？" class="headerlink" title="ArrayBlockingQueue 和 LinkedBlockingQueue 的区别是什么？"></a>ArrayBlockingQueue 和 LinkedBlockingQueue 的区别是什么？</h4><p>答：ArrayBlockingQueue 和 LinkedBlockingQueue 都实现自阻塞队列 BlockingQueue，它们的区别主要体现在以下几个方面：</p><ul><li>ArrayBlockingQueue 使用时必须指定容量值，LinkedBlockingQueue 可以不用指定；</li><li>ArrayBlockingQueue 的最大容量值是使用时指定的，并且指定之后就不允许修改；而 LinkedBlockingQueue 最大的容量为 Integer.MAX_VALUE；</li><li>ArrayBlockingQueue 数据存储容器是采用数组存储的；而 LinkedBlockingQueue 采用的是 Node 节点存储的。</li></ul><h4 id="LinkedList-中-add-和-offer-有什么关系？"><a href="#LinkedList-中-add-和-offer-有什么关系？" class="headerlink" title="LinkedList 中 add() 和 offer() 有什么关系？"></a>LinkedList 中 add() 和 offer() 有什么关系？</h4><p>答：add() 和 offer() 都是添加元素到队列尾部。offer 方法是基于 add 方法实现的，Offer 的源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Queue-和-Deque-有什么区别？"><a href="#Queue-和-Deque-有什么区别？" class="headerlink" title="Queue 和 Deque 有什么区别？"></a>Queue 和 Deque 有什么区别？</h4><p>答：Queue 属于一般队列，Deque 属于双端队列。一般队列是先进先出，也就是只有先进的才能先出；而双端队列则是两端都能插入和删除元素。</p><h4 id="LinkedList-属于一般队列还是双端队列？"><a href="#LinkedList-属于一般队列还是双端队列？" class="headerlink" title="LinkedList 属于一般队列还是双端队列？"></a>LinkedList 属于一般队列还是双端队列？</h4><p>答：LinkedList 实现了 Deque 属于双端队列，因此拥有 addFirst(E)、addLast(E)、getFirst()、getLast() 等方法。</p><h4 id="以下说法错误的是？"><a href="#以下说法错误的是？" class="headerlink" title="以下说法错误的是？"></a>以下说法错误的是？</h4><p>A：DelayQueue 内部是基于 PriorityQueue 实现的<br>B：PriorityBlockingQueue 不是先进先出的数据存储方式<br>C：LinkedBlockingQueue 默认容量是无限大的<br>D：ArrayBlockingQueue 内部的存储单元是数组，初始化时必须指定队列容量</p><p>答：C</p><p>题目解析：LinkedBlockingQueue 默认容量是 Integer.MAX_VALUE，并不是无限大的。</p><h4 id="关于-ArrayBlockingQueue-说法不正确的是？"><a href="#关于-ArrayBlockingQueue-说法不正确的是？" class="headerlink" title="关于 ArrayBlockingQueue 说法不正确的是？"></a>关于 ArrayBlockingQueue 说法不正确的是？</h4><p>A：ArrayBlockingQueue 是线程安全的<br>B：ArrayBlockingQueue 元素允许为 null<br>C：ArrayBlockingQueue 主要应用场景是“生产者-消费者”模型<br>D：ArrayBlockingQueue 必须显示地设置容量</p><p>答：B</p><p>题目解析：ArrayBlockingQueue 不允许元素为 null，如果添加一个 null 元素，会抛 NullPointerException 异常。</p><h4 id="以下程序执行的结果是什么？-1"><a href="#以下程序执行的结果是什么？-1" class="headerlink" title="以下程序执行的结果是什么？"></a>以下程序执行的结果是什么？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue priorityQueue = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">priorityQueue.add(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(priorityQueue.size());</span><br></pre></td></tr></table></figure><p>答：程序执行报错，PriorityQueue 不能插入 null。</p><h4 id="Java-中常见的阻塞队列有哪些？"><a href="#Java-中常见的阻塞队列有哪些？" class="headerlink" title="Java 中常见的阻塞队列有哪些？"></a>Java 中常见的阻塞队列有哪些？</h4><p>答：Java 中常见的阻塞队列如下：</p><ul><li>ArrayBlockingQueue，由数组结构组成的有界阻塞队列；</li><li>PriorityBlockingQueue，支持优先级排序的无界阻塞队列；</li><li>SynchronousQueue，是一个不存储元素的阻塞队列，会直接将任务交给消费者，必须等队列中的添加元素被消费后才能继续添加新的元素；</li><li>LinkedBlockingQueue，由链表结构组成的阻塞队列；</li><li>DelayQueue，支持延时获取元素的无界阻塞队列。</li></ul><h4 id="有界队列和无界队列有哪些区别？"><a href="#有界队列和无界队列有哪些区别？" class="headerlink" title="有界队列和无界队列有哪些区别？"></a>有界队列和无界队列有哪些区别？</h4><p>答：有界队列和无界队列的区别如下。</p><ul><li>有界队列：有固定大小的队列叫做有界队列，比如：new ArrayBlockingQueue(6)，6 就是队列的大小。</li><li>无界队列：指的是没有设置固定大小的队列，这些队列的特点是可以直接入列，直到溢出。它们并不是真的无界，它们最大值通常为 Integer.MAX_VALUE，只是平常很少能用到这么大的容量（超过 Integer.MAX_VALUE），因此从使用者的体验上，就相当于 “无界”。</li></ul><h4 id="如何手动实现一个延迟消息队列？"><a href="#如何手动实现一个延迟消息队列？" class="headerlink" title="如何手动实现一个延迟消息队列？"></a>如何手动实现一个延迟消息队列？</h4><p>答：说到延迟消息队列，我们应该可以第一时间想到要使用 DelayQueue 延迟队列来解决这个问题。实现思路，消息队列分为生产者和消费者，生产者用于增加消息，消费者用于获取并消费消息，我们只需要生产者把消息放入到 DelayQueue 队列并设置延迟时间，消费者循环使用 take() 阻塞获取消息即可。完整的实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDelayQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 消息编号</span></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger MESSAGENO = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        DelayQueue&lt;DelayedElement&gt; delayQueue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">// 生产者1</span></span><br><span class="line">        producer(delayQueue, <span class="string">&quot;生产者1&quot;</span>);</span><br><span class="line">        <span class="comment">// 生产者2</span></span><br><span class="line">        producer(delayQueue, <span class="string">&quot;生产者2&quot;</span>);</span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        consumer(delayQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">(DelayQueue&lt;DelayedElement&gt; delayQueue, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 产生 1~5 秒的随机数</span></span><br><span class="line">                    <span class="keyword">long</span> time = <span class="number">1000L</span> * (<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(time);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 组合消息体</span></span><br><span class="line">                    String message = String.format(<span class="string">&quot;%s，消息编号：%s 发送时间：%s 延迟：%s 秒&quot;</span>,</span><br><span class="line">                            name, MESSAGENO.getAndIncrement(), DateFormat.getDateTimeInstance().format(<span class="keyword">new</span> Date()), time / <span class="number">1000</span>);</span><br><span class="line">                    <span class="comment">// 生产消息</span></span><br><span class="line">                    delayQueue.put(<span class="keyword">new</span> DelayedElement(message, time));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">(DelayQueue&lt;DelayedElement&gt; delayQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    DelayedElement element = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 消费消息</span></span><br><span class="line">                        element = delayQueue.take();</span><br><span class="line">                        System.out.println(element);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟队列对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedElement</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 过期时间（单位：毫秒）</span></span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 消息体</span></span><br><span class="line">        String message;</span><br><span class="line">        <span class="comment">// 参数：delayTime 延迟时间（单位毫秒）</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DelayedElement</span><span class="params">(String message, <span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.time += delayTime;</span><br><span class="line">            <span class="keyword">this</span>.message = message;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">// 获取过期时间</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> unit.convert(time - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">// 队列元素排序</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS))</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 打印消息</span></span><br><span class="line">            <span class="keyword">return</span> message + <span class="string">&quot; |执行时间：&quot;</span> + DateFormat.getDateTimeInstance().format(<span class="keyword">new</span> Date());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序支持多生产者，执行的结果如下：</p><blockquote><p>生产者1，消息编号：1 发送时间：2019-6-12 20:38:37 延迟：2 秒 |执行时间：2019-6-12 20:38:39</p><p>生产者2，消息编号：2 发送时间：2019-6-12 20:38:37 延迟：2 秒 |执行时间：2019-6-12 20:38:39</p><p>生产者1，消息编号：3 发送时间：2019-6-12 20:38:41 延迟：4 秒 |执行时间：2019-6-12 20:38:45</p><p>生产者1，消息编号：5 发送时间：2019-6-12 20:38:43 延迟：2 秒 |执行时间：2019-6-12 20:38:45</p><p>……</p></blockquote><h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>队列（Queue）按照是否阻塞可分为：阻塞队列 BlockingQueue 和 非阻塞队列。其中，双端队列 Deque 也属于非阻塞队列，双端队列除了拥有队列的先进先出的方法之外，还拥有自己独有的方法，如 addFirst()、addLast()、getFirst()、getLast() 等，支持首未插入和删除元素。队列中比较常用的两个队列还有 PriorityQueue（优先级队列）和 DelayQueue（延迟队列），可使用延迟队列来实现延迟消息队列，这也是面试中比较常考的问题之一。需要面试朋友对延迟队列一定要做到心中有数，动手写一个消息队列也是非常有必要的。</p><h2 id="java-io-包下的类有哪些-面试题"><a href="#java-io-包下的类有哪些-面试题" class="headerlink" title="java.io 包下的类有哪些 + 面试题"></a>java.io 包下的类有哪些 + 面试题</h2><h3 id="IO-介绍"><a href="#IO-介绍" class="headerlink" title="IO 介绍"></a>IO 介绍</h3><p>IO 是 Input/Output 的缩写，它是基于流模型实现的，比如操作文件时使用输入流和输出流来写入和读取文件等。</p><h4 id="IO-分类"><a href="#IO-分类" class="headerlink" title="IO 分类"></a>IO 分类</h4><p>传统的 IO，按照流类型我们可以分为：</p><ul><li>字符流</li><li>字节流</li></ul><p>其中，字符流包括 Reader、Writer；字节流包括 InputStream、OutputStream。<br>传统 IO 的类关系图，如下图所示：</p><p><img src="/" alt="avatar" class="lazyload" data-src="https://images.gitbook.cn/Fk_zeSS6_npeS43a0lOi-DUbActn"></p><h4 id="IO-使用"><a href="#IO-使用" class="headerlink" title="IO 使用"></a>IO 使用</h4><p>了解了 IO 之间的关系，下面我们正式进入实战环节，分别来看字符流（Reader、Writer）和字节流（InputStream、OutputStream）的使用。</p><h5 id="Writer-使用"><a href="#Writer-使用" class="headerlink" title="Writer 使用"></a>Writer 使用</h5><p>Writer 可用来写入文件，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给指定目录下的文件追加信息</span></span><br><span class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;d:\\io.txt&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">writer.append(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure><p>这几行简单的代码就可以实现把信息 <code>老王</code> 追加到 <code>d:\\io.txt</code> 的文件下，参数二表示的是覆盖文字还是追加文字。</p><h5 id="Reader-使用"><a href="#Reader-使用" class="headerlink" title="Reader 使用"></a>Reader 使用</h5><p>Reader 可用来读取文件，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> FileReader(<span class="string">&quot;d:\\io.txt&quot;</span>);</span><br><span class="line">BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 逐行读取信息</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">null</span> != (str = bufferedReader.readLine())) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">bufferedReader.close();</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure><h5 id="InputStream-使用"><a href="#InputStream-使用" class="headerlink" title="InputStream 使用"></a>InputStream 使用</h5><p>InputStream 可用来读取文件，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;d:\\io.txt&quot;</span>));</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[inputStream.available()];</span><br><span class="line"><span class="comment">// 读取到 byte 数组</span></span><br><span class="line">inputStream.read(bytes);</span><br><span class="line"><span class="comment">// 内容转换为字符串</span></span><br><span class="line">String content = <span class="keyword">new</span> String(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">inputStream.close();</span><br></pre></td></tr></table></figure><h5 id="OutputStream-使用"><a href="#OutputStream-使用" class="headerlink" title="OutputStream 使用"></a>OutputStream 使用</h5><p>OutputStream 可用来写入文件，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;d:\\io.txt&quot;</span>),<span class="keyword">true</span>);</span><br><span class="line">outputStream.write(<span class="string">&quot;老王&quot;</span>.getBytes());</span><br><span class="line">outputStream.close();</span><br></pre></td></tr></table></figure><h3 id="NIO-介绍"><a href="#NIO-介绍" class="headerlink" title="NIO 介绍"></a>NIO 介绍</h3><p>上面讲的内容都是 java.io 包下的知识点，但随着 Java 的不断发展，在 Java 1.4 时新的 IO 包出现了 java.nio，NIO（Non-Blocking IO）的出现解决了传统 IO，也就是我们经常说的 BIO（Blocking IO）同步阻塞的问题，NIO 提供了 Channel、Selector 和 Buffer 等概念，可以实现多路复用和同步非阻塞 IO 操作，从而大大提升了 IO 操作的性能。<br>前面提到同步和阻塞的问题，那下面来看看同步和阻塞结合都有哪些含义。</p><table><thead><tr><th align="left">组合方式</th><th align="left">性能分析</th></tr></thead><tbody><tr><td align="left">同步阻塞</td><td align="left">最常用的一种用法，使用也是最简单的，但是 I/O 性能一般很差，CPU 大部分在空闲状态</td></tr><tr><td align="left">同步非阻塞</td><td align="left">提升 I/O 性能的常用手段，就是将 I/O 的阻塞改成非阻塞方式，尤其在网络 I/O 是长连接，同时传输数据也不是很多的情况下，提升性能非常有效。 这种方式通常能提升 I/O 性能，但是会增加 CPU 消耗，要考虑增加的 I/O 性能能不能补偿 CPU 的消耗，也就是系统的瓶颈是在 I/O 还是在 CPU 上</td></tr><tr><td align="left">异步阻塞</td><td align="left">这种方式在分布式数据库中经常用到。例如，在往一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，而还有两至三份是备份记录会写到其他机器上，这些备份记录通常都是采用异步阻塞的方式写 I/O；异步阻塞对网络 I/O 能够提升效率，尤其像上面这种同时写多份相同数据的情况</td></tr><tr><td align="left">异步非阻塞</td><td align="left">这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下使用，像集群之间的消息同步机制一般用这种 I/O 组合方式。例如，Cassandra 的 Gossip 通信机制就是采用异步非阻塞的方式。它适合同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大，但是却非常频繁。这种网络 I/O 用这个方式性能能达到最高</td></tr></tbody></table><p>了解了同步和阻塞的含义，下面来看 <strong>NIO 的具体使用</strong>，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> port = <span class="number">6666</span>;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Selector selector = Selector.open();</span><br><span class="line">             ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();) &#123;</span><br><span class="line">            serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(), port));</span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                selector.select(); <span class="comment">// 阻塞等待就绪的 Channel</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="keyword">try</span> (SocketChannel channel = ((ServerSocketChannel) key.channel()).accept()) &#123;</span><br><span class="line">                        channel.write(Charset.defaultCharset().encode(<span class="string">&quot;老王，你好~&quot;</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Socket 客户端 1（接收信息并打印）</span></span><br><span class="line">        <span class="keyword">try</span> (Socket cSocket = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), port)) &#123;</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(cSocket.getInputStream()));</span><br><span class="line">            bufferedReader.lines().forEach(s -&gt; System.out.println(<span class="string">&quot;客户端 1 打印：&quot;</span> + s));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Socket 客户端 2（接收信息并打印）</span></span><br><span class="line">        <span class="keyword">try</span> (Socket cSocket = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), port)) &#123;</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(cSocket.getInputStream()));</span><br><span class="line">            bufferedReader.lines().forEach(s -&gt; System.out.println(<span class="string">&quot;客户端 2 打印：&quot;</span> + s));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>以上代码创建了两个 Socket 客户端，用于收取和打印服务器端的消息。<br>其中，服务器端通过 SelectionKey（选择键）获取到 SocketChannel（通道），而通道都注册到 Selector（选择器）上，所有的客户端都可以获得对应的通道，而不是所有客户端都排队堵塞等待一个服务器连接，这样就实现多路复用的效果了。多路指的是多个通道（SocketChannel），而复用指的是一个服务器端连接重复被不同的客户端使用。</p><h3 id="AIO-介绍"><a href="#AIO-介绍" class="headerlink" title="AIO 介绍"></a>AIO 介绍</h3><p>AIO（Asynchronous IO）是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。<br>AIO 实现简单的 Socket 服务器，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> port = <span class="number">8888</span>;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AsynchronousChannelGroup group = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            group = AsynchronousChannelGroup.withThreadPool(Executors.newFixedThreadPool(<span class="number">4</span>));</span><br><span class="line">            AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open(group).bind(<span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(), port));</span><br><span class="line">            server.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, AsynchronousServerSocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel result, AsynchronousServerSocketChannel attachment)</span> </span>&#123;</span><br><span class="line">                    server.accept(<span class="keyword">null</span>, <span class="keyword">this</span>); <span class="comment">// 接收下一个请求</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Future&lt;Integer&gt; f = result.write(Charset.defaultCharset().encode(<span class="string">&quot;Hi, 老王&quot;</span>));</span><br><span class="line">                        f.get();</span><br><span class="line">                        System.out.println(<span class="string">&quot;服务端发送时间：&quot;</span> + DateFormat.getDateTimeInstance().format(<span class="keyword">new</span> Date()));</span><br><span class="line">                        result.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException | IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, AsynchronousServerSocketChannel attachment)</span> </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            group.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Socket 客户端</span></span><br><span class="line">AsynchronousSocketChannel client = AsynchronousSocketChannel.open();</span><br><span class="line">Future&lt;Void&gt; future = client.connect(<span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(), port));</span><br><span class="line">future.get();</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">client.read(buffer, <span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;Integer, Void&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Void attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端打印：&quot;</span> + <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Void attachment)</span> </span>&#123;</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h3 id="相关面试题-15"><a href="#相关面试题-15" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="使用以下哪个方法来判断一个文件是否存在？"><a href="#使用以下哪个方法来判断一个文件是否存在？" class="headerlink" title="使用以下哪个方法来判断一个文件是否存在？"></a>使用以下哪个方法来判断一个文件是否存在？</h4><p>A：createFile<br>B：exists<br>C：read<br>D：exist</p><p>答：B</p><h4 id="以下说法错误的是？-1"><a href="#以下说法错误的是？-1" class="headerlink" title="以下说法错误的是？"></a>以下说法错误的是？</h4><p>A：同步操作不一定会阻塞<br>B：异步操作不一定会阻塞<br>C：阻塞一定是同步操作<br>D：同步或异步都可能会阻塞</p><p>答：C</p><p>题目解析：异步操作也可能会阻塞，比如分布式集群消息同步，采用的就是异步阻塞的方式。</p><h4 id="BIO、NIO、AIO-的区别是什么？"><a href="#BIO、NIO、AIO-的区别是什么？" class="headerlink" title="BIO、NIO、AIO 的区别是什么？"></a>BIO、NIO、AIO 的区别是什么？</h4><p>答：它们三者的区别如下。</p><ul><li>BIO 就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。它的优点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</li><li>NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</li><li>AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，因此人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li></ul><p>简单来说 BIO 就是传统 IO 包，产生的最早；NIO 是对 BIO 的改进提供了多路复用的同步非阻塞 IO，而 AIO 是 NIO 的升级，提供了异步非阻塞 IO。</p><h4 id="读取和写入文件最简洁的方式是什么？"><a href="#读取和写入文件最简洁的方式是什么？" class="headerlink" title="读取和写入文件最简洁的方式是什么？"></a>读取和写入文件最简洁的方式是什么？</h4><p>答：使用 Java 7 提供的 Files 读取和写入文件是最简洁，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = Files.readAllBytes(Paths.get(<span class="string">&quot;d:\\io.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">Files.write(Paths.get(<span class="string">&quot;d:\\io.txt&quot;</span>), <span class="string">&quot;追加内容&quot;</span>.getBytes(), StandardOpenOption.APPEND);</span><br></pre></td></tr></table></figure><p>读取和写入都是一行代码搞定，可以说很简洁了。</p><h4 id="Files-常用方法都有哪些？"><a href="#Files-常用方法都有哪些？" class="headerlink" title="Files 常用方法都有哪些？"></a>Files 常用方法都有哪些？</h4><p>答：Files 是 Java 1.7 提供的，使得文件和文件夹的操作更加方便，它的常用方法有以下几个：</p><ul><li>Files. exists()：检测文件路径是否存在</li><li>Files. createFile()：创建文件</li><li>Files. createDirectory()：创建文件夹</li><li>Files. delete()：删除一个文件或目录</li><li>Files. copy()：复制文件</li><li>Files. move()：移动文件</li><li>Files. size()：查看文件个数</li><li>Files. read()：读取文件</li><li>Files. write()：写入文件</li></ul><h4 id="FileInputStream-可以实现什么功能？"><a href="#FileInputStream-可以实现什么功能？" class="headerlink" title="FileInputStream 可以实现什么功能？"></a>FileInputStream 可以实现什么功能？</h4><p>答：FileInputStream 可以实现文件的读取。</p><p>题目解析：因为 FileInputStream 和 FileOutputStream 很容易被记反，FileOutputStream 才是用来写入文件的，所以也经常被面试官问到。</p><h4 id="不定项选择：为了提高读写性能，可以采用什么流？"><a href="#不定项选择：为了提高读写性能，可以采用什么流？" class="headerlink" title="不定项选择：为了提高读写性能，可以采用什么流？"></a>不定项选择：为了提高读写性能，可以采用什么流？</h4><p>A：InputStream<br>B：DataInputStream<br>C：BufferedReader<br>D：BufferedInputStream<br>E：OutputStream<br>F：BufferedOutputStream</p><p>答：D、F</p><p>题目解析：BufferedInputStream 是一种带缓存区的输入流，在读取字节数据时可以从底层流中一次性读取多个字节到缓存区，而不必每次都调用系统底层；同理，BufferedOutputStream 也是一种带缓冲区的输出流，通过缓冲区输出流，应用程序先把字节写入缓冲区，缓存区满后再调用操作系统底层，从而提高系统性能，而不必每次都去调用系统底层方法。</p><h4 id="FileInputStream-和-BufferedInputStream-的区别是什么？"><a href="#FileInputStream-和-BufferedInputStream-的区别是什么？" class="headerlink" title="FileInputStream 和 BufferedInputStream 的区别是什么？"></a>FileInputStream 和 BufferedInputStream 的区别是什么？</h4><p>答：FileInputStream 在小文件读写时性能较好，而在大文件操作时使用 BufferedInputStream 更有优势。</p><h4 id="以下这段代码运行在-Windwos-平台，执行的结果是？"><a href="#以下这段代码运行在-Windwos-平台，执行的结果是？" class="headerlink" title="以下这段代码运行在 Windwos 平台，执行的结果是？"></a>以下这段代码运行在 Windwos 平台，执行的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.createFile(Paths.get(<span class="string">&quot;c:\\pf.txt&quot;</span>), PosixFilePermissions.asFileAttribute(</span><br><span class="line">    EnumSet.of(PosixFilePermission.OWNER_READ)));</span><br></pre></td></tr></table></figure><p>A：在指定的盘符产生了对应的文件，文件只读<br>B：在指定的盘符产生了对应的文件，文件只写<br>C：在指定的盘符产生了对应的文件，文件可读写<br>D：程序报错</p><p>答：D</p><p>题目解析：本题目考察的是 Files.createFile 参数传递的问题，PosixFilePermissions 不支持 Windows，因此在 Windows 执行会报错 java.lang.UnsupportedOperationException: ‘posix:permissions’ not supported as initial attribute。</p><h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>在 Java 1.4 之前只有 BIO（Blocking IO）可供使用，也就是 java.io 包下的那些类，它的缺点是同步阻塞式运行的。随后在 Java 1.4 时，提供了 NIO（Non-Blocking IO）属于 BIO 的升级，提供了同步非阻塞的 IO 操作方式，它的重要组件是 Selector（选择器）、Channel（通道）、Buffer（高效数据容器）实现了多路复用的高效 IO 操作。而 AIO（Asynchronous IO）也叫 NIO 2.0，属于 NIO 的补充和升级，提供了异步非阻塞的 IO 操作。</p><p>还有另一个重要的知识点，是 Java 7.0 时新增的 Files 类，极大地提升了文件操作的便利性，比如读、写文件 Files.write()、Files.readAllBytes() 等，都是非常简便和实用的方法。</p><h2 id="JDK-原生动态代理是怎么实现的-面试题"><a href="#JDK-原生动态代理是怎么实现的-面试题" class="headerlink" title="JDK 原生动态代理是怎么实现的 + 面试题"></a>JDK 原生动态代理是怎么实现的 + 面试题</h2><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时自省（introspect）的能力。简单来说就是通过反射，可以在运行期间获取、检测和调用对象的属性和方法。</p><h4 id="反射的使用场景"><a href="#反射的使用场景" class="headerlink" title="反射的使用场景"></a>反射的使用场景</h4><p>在现实中反射的使用场景有很多，比如以下几个。</p><p><strong>使用场景一</strong>：编程工具 IDEA 或 Eclipse 等，在写代码时会有代码（属性或方法名）提示，就是因为使用了反射。</p><p><strong>使用场景二</strong>：很多知名的框架，为了让程序更优雅更简洁，也会使用到反射。</p><p>例如，<strong>Spring</strong> 可以通过配置来加载不同的类，调用不同的方法，代码如下所示：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;person&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.spring.beans.Person&quot;</span> init-method=<span class="string">&quot;initPerson&quot;</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>例如，<strong>MyBatis</strong> 在 Mapper 使用外部类的 SQL 构建查询时，代码如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SelectProvider(type = PersonSql.class, method = &quot;getListSql&quot;)</span></span><br><span class="line"><span class="function">List&lt;Person&gt; <span class="title">getList</span><span class="params">()</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonSql</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getListSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="keyword">new</span> SQL() &#123;&#123;</span><br><span class="line">            SELECT(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            FROM(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">        &#125;&#125;.toString();</span><br><span class="line">        <span class="keyword">return</span> sql;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景三</strong>：数据库连接池，也会使用反射调用不同类型的数据库驱动，代码如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String url = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/mydb&quot;</span>;</span><br><span class="line">String username = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">String password = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">Connection connection = DriverManager.getConnection(url, username, password);</span><br></pre></td></tr></table></figure><p>当然反射还有其他很多类似的使用场景，这里就不一一列举，读者可以举一反三，想想在平常的开发中，还有哪些使用了反射功能的场景。</p><h4 id="反射的基本使用"><a href="#反射的基本使用" class="headerlink" title="反射的基本使用"></a>反射的基本使用</h4><p>下来我们通过反射调用类中的某个方法，来学习反射的基本使用。</p><p>使用反射调用类中的方法，分为三种情况：</p><ul><li>调用静态方法</li><li>调用公共方法</li><li>调用私有方法</li></ul><p>假设有一个实体类 MyReflect 包含了以上三种方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.chapter4;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReflect</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static Method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公共方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Public Method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Private Method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分别来看，使用反射如何调用以上三种类型的方法。</p><h5 id="反射调用静态方法"><a href="#反射调用静态方法" class="headerlink" title="反射调用静态方法"></a><strong>反射调用静态方法</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class myClass = Class.forName(<span class="string">&quot;com.interview.chapter4.MyReflect&quot;</span>);</span><br><span class="line">Method method = myClass.getMethod(<span class="string">&quot;staticMd&quot;</span>);</span><br><span class="line">method.invoke(myClass);</span><br></pre></td></tr></table></figure><h5 id="反射调用公共方法"><a href="#反射调用公共方法" class="headerlink" title="反射调用公共方法"></a><strong>反射调用公共方法</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class myClass = Class.forName(<span class="string">&quot;com.interview.chapter4.MyReflect&quot;</span>);</span><br><span class="line"><span class="comment">// 创建实例对象（相当于 new ）</span></span><br><span class="line">Object instance = myClass.newInstance();</span><br><span class="line">Method method2 = myClass.getMethod(<span class="string">&quot;publicMd&quot;</span>);</span><br><span class="line">method2.invoke(instance);</span><br></pre></td></tr></table></figure><h5 id="反射调用私有方法"><a href="#反射调用私有方法" class="headerlink" title="反射调用私有方法"></a><strong>反射调用私有方法</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class myClass = Class.forName(<span class="string">&quot;com.interview.chapter4.MyReflect&quot;</span>);</span><br><span class="line"><span class="comment">// 创建实例对象（相当于 new ）</span></span><br><span class="line">Object object = myClass.newInstance();</span><br><span class="line">Method method3 = myClass.getDeclaredMethod(<span class="string">&quot;privateMd&quot;</span>);</span><br><span class="line">method3.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">method3.invoke(object);</span><br></pre></td></tr></table></figure><h4 id="反射使用总结"><a href="#反射使用总结" class="headerlink" title="反射使用总结"></a>反射使用总结</h4><p>反射获取调用类可以通过 Class.forName()，反射获取类实例要通过 newInstance()，相当于 new 一个新对象，反射获取方法要通过 getMethod()，获取到类方法之后使用 invoke() 对类方法进行调用。如果是类方法为私有方法的话，则需要通过 setAccessible(true) 来修改方法的访问限制，以上的这些操作就是反射的基本使用。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理可以理解为，本来应该自己做的事情，却交给别人代为处理，这个过程就叫做动态代理。</p><h4 id="动态代理的使用场景"><a href="#动态代理的使用场景" class="headerlink" title="动态代理的使用场景"></a>动态代理的使用场景</h4><p>动态代理被广为人知的使用场景是 Spring 中的面向切面编程（AOP）。例如，依赖注入 @Autowired 和事务注解 @Transactional 等，都是利用动态代理实现的。</p><p>动态代理还可以封装一些 RPC 调用，也可以通过代理实现一个全局拦截器等。</p><h4 id="动态代理和反射的关系"><a href="#动态代理和反射的关系" class="headerlink" title="动态代理和反射的关系"></a>动态代理和反射的关系</h4><p>JDK 原生提供的动态代理就是通过反射实现的，但动态代理的实现方式还可以是 ASM（一个短小精悍的字节码操作框架）、cglib（基于 ASM）等，并不局限于反射。</p><p>下面我们分别来看：JDK 原生动态代理和 cglib 的实现。</p><h4 id="JDK-原生动态代理"><a href="#JDK-原生动态代理" class="headerlink" title="JDK 原生动态代理"></a>JDK 原生动态代理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The dog is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The cat is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK 代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target; <span class="comment">// 代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="comment">// 取得代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用前&quot;</span>);</span><br><span class="line">        Object result = method.invoke(target, args); <span class="comment">// 方法调用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// JDK 动态代理调用</span></span><br><span class="line">    AnimalProxy proxy = <span class="keyword">new</span> AnimalProxy();</span><br><span class="line">    Animal dogProxy = (Animal) proxy.getInstance(<span class="keyword">new</span> Dog());</span><br><span class="line">    dogProxy.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，我们实现了通过动态代理，在所有请求前、后都打印了一个简单的信息。</p><p><strong>注意：</strong> JDK Proxy 只能代理实现接口的类（即使是 extends 继承类也是不可以代理的）。</p><h4 id="cglib-动态代理"><a href="#cglib-动态代理" class="headerlink" title="cglib 动态代理"></a>cglib 动态代理</h4><p>要是用 cglib 实现要添加对 cglib 的引用，如果是 maven 项目的话，直接添加以下代码：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>cglib 的具体实现，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The panda is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target; <span class="comment">// 代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置父类为实例类</span></span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">        <span class="comment">// 回调方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用前&quot;</span>);</span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects); <span class="comment">// 执行方法调用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cglib 动态代理调用</span></span><br><span class="line">    CglibProxy proxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">    Panda panda = (Panda)proxy.getInstance(<span class="keyword">new</span> Panda());</span><br><span class="line">    panda.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行的结果：</p><blockquote><p>调用前</p><p>The panda is eating</p><p>调用后</p></blockquote><p>由以上代码可以知道，cglib 的调用通过实现 MethodInterceptor 接口的 intercept 方法，调用 invokeSuper 进行动态代理的。它可以直接对普通类进行动态代理，并不需要像 JDK 代理那样，需要通过接口来完成，值得一提的是 Spring 的动态代理也是通过 cglib 实现的。</p><p><strong>注意</strong>：cglib 底层是通过子类继承被代理对象的方式实现动态代理的，因此代理类不能是最终类（final），否则就会报错 java.lang.IllegalArgumentException: Cannot subclass final class xxx。</p><h3 id="相关面试题-16"><a href="#相关面试题-16" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="动态代理解决了什么问题？"><a href="#动态代理解决了什么问题？" class="headerlink" title="动态代理解决了什么问题？"></a>动态代理解决了什么问题？</h4><p>答：首先它是一个代理机制，如果熟悉设计模式中的代理模式，我们会知道，代理可以看作是对调用目标的一个包装，这样我们对目标代码的调用不是直接发生的，而是通过代理完成，通过代理可以让调用者与实现者之间解耦。比如进行 RPC 调用，通过代理，可以提供更加友善的界面；还可以通过代理，做一个全局的拦截器。</p><h4 id="动态代理和反射的关系是什么？"><a href="#动态代理和反射的关系是什么？" class="headerlink" title="动态代理和反射的关系是什么？"></a>动态代理和反射的关系是什么？</h4><p>答：反射可以用来实现动态代理，但动态代理还有其他的实现方式，比如 ASM（一个短小精悍的字节码操作框架）、cglib 等。</p><h4 id="3-以下描述错误的是？"><a href="#3-以下描述错误的是？" class="headerlink" title="3.以下描述错误的是？"></a>3.以下描述错误的是？</h4><p>A：cglib 的性能更高<br>B：Spring 中有使用 cglib 来实现动态代理<br>C：Spring 中有使用 JDK 原生的动态代理<br>D：JDK 原生动态代理性能更高</p><p>答：D</p><p>题目解析：Spring 动态代理的实现方式有两种：cglib 和 JDK 原生动态代理。</p><h4 id="请补全以下代码？"><a href="#请补全以下代码？" class="headerlink" title="请补全以下代码？"></a>请补全以下代码？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReflect</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Private Method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        Class myClass = Class.forName(<span class="string">&quot;MyReflect&quot;</span>);</span><br><span class="line">        Object object = myClass.newInstance();</span><br><span class="line">        <span class="comment">// 补充此行代码</span></span><br><span class="line">        method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        method.invoke(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：Method method = myClass.getDeclaredMethod(“privateMd”);</p><p>题目解析：此题主要考的是私有方法的获取，私有方法的获取并不是通过 getMethod() 方式，而是通过 getDeclaredMethod() 获取的。</p><h4 id="cglib-可以代理任何类这句话对吗？为什么？"><a href="#cglib-可以代理任何类这句话对吗？为什么？" class="headerlink" title="cglib 可以代理任何类这句话对吗？为什么？"></a>cglib 可以代理任何类这句话对吗？为什么？</h4><p>答：这句话不完全对，因为 cglib 只能代理可以有子类的普通类，对于像最终类（final），cglib 是不能实现动态代理的，因为 cglib 的底层是通过继承代理类的子类来实现动态代理的，所以不能被继承类无法使用 cglib。</p><h4 id="JDK-原生动态代理和-cglib-有什么区别？"><a href="#JDK-原生动态代理和-cglib-有什么区别？" class="headerlink" title="JDK 原生动态代理和 cglib 有什么区别？"></a>JDK 原生动态代理和 cglib 有什么区别？</h4><p>答：JDK 原生动态代理和 cglib 区别如下：</p><ul><li>JDK 原生动态代理是基于接口实现的，不需要添加任何依赖，可以平滑的支持 JDK 版本的升级；</li><li>cglib 不需要实现接口，可以直接代理普通类，需要添加依赖包，性能更高。</li></ul><h4 id="为什么-JDK-原生的动态代理必须要通过接口来完成？"><a href="#为什么-JDK-原生的动态代理必须要通过接口来完成？" class="headerlink" title="为什么 JDK 原生的动态代理必须要通过接口来完成？"></a>为什么 JDK 原生的动态代理必须要通过接口来完成？</h4><p>答：这是由于 JDK 原生设计的原因，来看动态代理的实现方法 newProxyInstance() 的源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ......</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   loader the class loader to define the proxy class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   interfaces the list of interfaces for the proxy class to implement</span></span><br><span class="line"><span class="comment"> * ......</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br></pre></td></tr></table></figure><p>来看前两个参数的声明：</p><ul><li>loader：为类加载器，也就是 target.getClass().getClassLoader()</li><li>interfaces：接口代理类的接口实现列表</li></ul><p>看了上面的参数说明，我们就明白了，要使用 JDK 原生的动态只能通过实现接口来完成。</p><h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>通过本文可以知道 JDK 原生动态代理是使用反射实现的，但动态代理的实现方式不止有反射，还可以是 ASM（一个短小精悍的字节码操作框架）、cglib（基于 ASM）等。其中 JDK 原生的动态代理是通过接口实现的，而 cglib 是通过子类实现的，因此 cglib 不能代理最终类（final）。而反射不但可以反射调用静态方法，还可以反射调用普通方法和私有方法，其中调用私有方法时要设置 setAccessible 为 true。</p><h2 id="为什么需要线程-面试题"><a href="#为什么需要线程-面试题" class="headerlink" title="为什么需要线程 + 面试题"></a>为什么需要线程 + 面试题</h2><h3 id="线程介绍"><a href="#线程介绍" class="headerlink" title="线程介绍"></a>线程介绍</h3><p>线程（Thread）是程序运行的执行单元，依托于进程存在。一个进程中可以包含多个线程，多线程可以共享一块内存空间和一组系统资源，因此线程之间的切换更加节省资源、更加轻量化，因而也被称为轻量级的进程。</p><h4 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h4><p>进程（Processes）是程序的一次动态执行，是系统进行资源分配和调度的基本单位，是操作系统运行的基础，通常每一个进程都拥有自己独立的内存空间和系统资源。简单来说，进程可以被当做是一个正在运行的程序。</p><h4 id="为什么需要线程"><a href="#为什么需要线程" class="headerlink" title="为什么需要线程"></a>为什么需要线程</h4><p>程序的运行必须依靠进程，进程的实际执行单元就是线程。</p><h4 id="为什么需要多线程"><a href="#为什么需要多线程" class="headerlink" title="为什么需要多线程"></a>为什么需要多线程</h4><p>多线程可以提高程序的执行性能。例如，有个 90 平方的房子，一个人打扫需要花费 30 分钟，三个人打扫就只需要 10 分钟，这三个人就是程序中的“多线程”。</p><h3 id="线程使用"><a href="#线程使用" class="headerlink" title="线程使用"></a>线程使用</h3><p>线程的创建，分为以下三种方式：</p><ul><li>继承 Thread 类，重写 run 方法</li><li>实现 Runnable 接口，实现 run 方法</li><li>实现 Callable 接口，实现 call 方法</li></ul><p>下面分别来看看线程创建和使用的具体代码。</p><h4 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h4><p>请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>Thread</p></blockquote><h4 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h4><p>请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable runnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Runnable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>Runnable</p></blockquote><h4 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h4><p>请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyCallable callable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">        <span class="comment">// 定义返回结果</span></span><br><span class="line">        FutureTask&lt;String&gt; result = <span class="keyword">new</span> FutureTask(callable);</span><br><span class="line">        <span class="comment">// 执行程序</span></span><br><span class="line">        <span class="keyword">new</span> Thread(result).start();</span><br><span class="line">        <span class="comment">// 输出返回结果</span></span><br><span class="line">        System.out.println(result.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Callable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>Callable</p><p>Success</p></blockquote><p>可以看出，Callable 的调用是可以有返回值的，它弥补了之前调用线程没有返回值的情况，它是随着 JDK 1.5 一起发布的。</p><h4 id="JDK-8-创建线程"><a href="#JDK-8-创建线程" class="headerlink" title="JDK 8 创建线程"></a>JDK 8 创建线程</h4><p>JDK 8 之后可以使用 Lambda 表达式很方便地创建线程，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;Lambda Of Thread.&quot;</span>)).start();</span><br></pre></td></tr></table></figure><h3 id="线程高级用法"><a href="#线程高级用法" class="headerlink" title="线程高级用法"></a>线程高级用法</h3><h5 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h5><p>使用 wait() 方法实现线程等待，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(LocalDateTime.now());</span><br><span class="line">Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 秒钟之后自动唤醒</span></span><br><span class="line">            lock.wait(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(LocalDateTime.now());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>2019-06-22T20:53:08.776</p><p>2019-06-22T20:53:09.788</p></blockquote><p>注意：当使用 wait() 方法时，必须先持有当前对象的锁，否则会抛出异常 java.lang.IllegalMonitorStateException。</p><h5 id="线程唤醒"><a href="#线程唤醒" class="headerlink" title="线程唤醒"></a>线程唤醒</h5><p>使用 notify()/notifyAll() 方法唤醒线程。</p><ul><li>notify() 方法随机唤醒对象的等待池中的一个线程；</li><li>notifyAll() 唤醒对象的等待池中的所有线程。</li></ul><p>使用如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">lock.wait();</span><br><span class="line">lock.notify();</span><br><span class="line"><span class="comment">// lock.notifyAll();</span></span><br></pre></td></tr></table></figure><h5 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 休眠 1 秒</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h5 id="等待线程执行完成"><a href="#等待线程执行完成" class="headerlink" title="等待线程执行完成"></a>等待线程执行完成</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread joinThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行前&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;执行后&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">joinThread.start();</span><br><span class="line">joinThread.join();</span><br><span class="line">System.out.println(<span class="string">&quot;主程序&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上程序执行结果：</p><blockquote><p>执行前</p><p>执行后</p><p>主程序</p></blockquote><h5 id="yield-交出-CPU-执行权"><a href="#yield-交出-CPU-执行权" class="headerlink" title="yield 交出 CPU 执行权"></a>yield 交出 CPU 执行权</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="comment">// 让同优先级的线程有执行的机会</span></span><br><span class="line">                <span class="keyword">this</span>.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure><p>注意：yield 方法是让同优先级的线程有执行的机会，但不能保证自己会从正在运行的状态迅速转换到可运行的状态。</p><h5 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h5><p>使用 <code>System.exit(0)</code> 可以让整个程序退出；要中断单个线程，可配合 <code>interrupt()</code> 对线程进行“中断”。<br>使用代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread interruptThread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i：&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">interruptThread.start();</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">interruptThread.interrupt();</span><br></pre></td></tr></table></figure><h5 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h5><p>在 Java 语言中，每一个线程有一个优先级，默认情况下，一个线程继承它父类的优先级。可以使用 setPriority 方法设置（1-10）优先级，默认的优先级是 5，数字越大表示优先级越高，优先级越高的线程可能优先被执行的概率就越大。<br>设置优先级的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">thread.setPriority(<span class="number">10</span>);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。<br>比如，当线程 A 持有独占锁 a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 A B 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。<br>死锁示意图如下所示：<br><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/65072410-d2d3-11e9-a6f3-5b822f50de09"><br>死锁代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 线程1拥有对象1，想要等待获取对象2</span></span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"><span class="comment">// 线程2拥有对象2，想要等待获取对象1</span></span><br><span class="line"><span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure><h3 id="相关面试题-17"><a href="#相关面试题-17" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="线程和进程有什么区别和联系？"><a href="#线程和进程有什么区别和联系？" class="headerlink" title="线程和进程有什么区别和联系？"></a>线程和进程有什么区别和联系？</h4><p>答：从本质上来说，线程是进程的实际执行单元，一个程序至少有一个进程，一个进程至少有一个线程，它们的区别主要体现在以下几个方面：</p><ul><li>进程间是独立的，不能共享内存空间和上下文，而线程可以；</li><li>进程是程序的一次执行，线程是进程中执行的一段程序片段；</li><li>线程占用的资源比进程少。</li></ul><h4 id="如何保证一个线程执行完再执行第二个线程？"><a href="#如何保证一个线程执行完再执行第二个线程？" class="headerlink" title="如何保证一个线程执行完再执行第二个线程？"></a>如何保证一个线程执行完再执行第二个线程？</h4><p>答：使用 join() 方法，等待上一个线程的执行完之后，再执行当前线程。<br>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread joinThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行前&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;执行后&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">joinThread.start();</span><br><span class="line">joinThread.join();</span><br><span class="line">System.out.println(<span class="string">&quot;主程序&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="线程有哪些常用的方法？"><a href="#线程有哪些常用的方法？" class="headerlink" title="线程有哪些常用的方法？"></a>线程有哪些常用的方法？</h4><p>答：线程的常用方法如下：</p><ul><li>currentThread()：返回当前正在执行的线程引用</li><li>getName()：返回此线程的名称</li><li>setPriority()/getPriority()：设置和返回此线程的优先级</li><li>isAlive()：检测此线程是否处于活动状态，活动状态指的是程序处于正在运行或准备运行的状态</li><li>sleep()：使线程休眠</li><li>join()：等待线程执行完成</li><li>yield()：让同优先级的线程有执行的机会，但不能保证自己会从正在运行的状态迅速转换到可运行的状态</li><li>interrupted()：是线程处于中断的状态，但不能真正中断线程</li></ul><h4 id="wait-和-sleep-有什么区别？"><a href="#wait-和-sleep-有什么区别？" class="headerlink" title="wait() 和 sleep() 有什么区别？"></a>wait() 和 sleep() 有什么区别？</h4><p>答：wait() 和 sleep() 的区别主要体现在以下三个方面。</p><ul><li>存在类的不同：sleep() 来自 Thread，wait() 来自 Object。</li><li>释放锁：sleep() 不释放锁；wait() 释放锁。</li><li>用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll() 直接唤醒。</li></ul><h4 id="守护线程是什么？"><a href="#守护线程是什么？" class="headerlink" title="守护线程是什么？"></a>守护线程是什么？</h4><p>答：守护线程是一种比较低级别的线程，一般用于为其他类别线程提供服务，因此当其他线程都退出时，它也就没有存在的必要了。例如，JVM（Java 虚拟机）中的垃圾回收线程。</p><h4 id="线程有哪些状态？"><a href="#线程有哪些状态？" class="headerlink" title="线程有哪些状态？"></a>线程有哪些状态？</h4><p>答：在 JDK 8 中，线程的状态有以下六种。</p><ul><li>NEW：尚未启动</li><li>RUNNABLE：正在执行中</li><li>BLOCKED：阻塞（被同步锁或者 IO 锁阻塞）</li><li>WAITING：永久等待状态</li><li>TIMED_WAITING：等待指定的时间重新被唤醒的状态</li><li>TERMINATED：执行完成</li></ul><p>题目分析：JDK 8 线程状态的源码如下图所示：<br><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/bfa90b90-d2d3-11e9-9a2b-37838cbf8b11"></p><h4 id="线程中的-start-和-run-有那些区别？"><a href="#线程中的-start-和-run-有那些区别？" class="headerlink" title="线程中的 start() 和 run() 有那些区别？"></a>线程中的 start() 和 run() 有那些区别？</h4><p>答：start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p><h4 id="产生死锁需要具备哪些条件？"><a href="#产生死锁需要具备哪些条件？" class="headerlink" title="产生死锁需要具备哪些条件？"></a>产生死锁需要具备哪些条件？</h4><p>答：产生死锁的四个必要条件：</p><ul><li>互斥条件：一个资源每次只能被一个线程使用；</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；</li><li>不剥夺条件：线程已获得的资源，在末使用完之前，不能强行剥夺；</li><li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系；</li></ul><p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p><h4 id="如何预防死锁？"><a href="#如何预防死锁？" class="headerlink" title="如何预防死锁？"></a>如何预防死锁？</h4><p>答：预防死锁的方法如下：</p><ul><li>尽量使用 tryLock(long timeout, TimeUnit unit) 的方法 (ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁；</li><li>尽量使用 Java. util. concurrent 并发类代替自己手写锁；</li><li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁；</li><li>尽量减少同步的代码块。</li></ul><h4 id="thread-wait-和-thread-wait-0-有什么区别？代表什么含义？"><a href="#thread-wait-和-thread-wait-0-有什么区别？代表什么含义？" class="headerlink" title="thread.wait() 和 thread.wait(0) 有什么区别？代表什么含义？"></a>thread.wait() 和 thread.wait(0) 有什么区别？代表什么含义？</h4><p>答：thread.wait() 和 thread.wait(0) 是相同的，使用 thread.wait() 内部其实是调用的 thread.wait(0)，源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wait() 表示进入等待状态，释放当前的锁让出 CPU 资源，并且只能等程序执行 notify()/notifyAll() 方法才会被重写唤醒。</p><h4 id="如何让两个程序依次输出-11-22-33-等数字，请写出实现代码？"><a href="#如何让两个程序依次输出-11-22-33-等数字，请写出实现代码？" class="headerlink" title="如何让两个程序依次输出 11/22/33 等数字，请写出实现代码？"></a>如何让两个程序依次输出 11/22/33 等数字，请写出实现代码？</h4><p>答：使用思路是在每个线程输出信息之后，让当前线程等待一会再执行下一次操作，具体实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程一：&quot;</span> + i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程二：&quot;</span> + i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>程序执行结果如下：</p><blockquote><p>线程一：1</p><p>线程二：1</p><p>线程二：2</p><p>线程一：2</p><p>线程二：3</p><p>线程一：3</p></blockquote><h4 id="说一下线程的调度策略？"><a href="#说一下线程的调度策略？" class="headerlink" title="说一下线程的调度策略？"></a>说一下线程的调度策略？</h4><p>答：线程调度器选择优先级最高的线程运行，但是如果发生以下情况，就会终止线程的运行：</p><ul><li>线程体中调用了 yield() 方法，让出了对 CPU 的占用权；</li><li>线程体中调用了 sleep() 方法，使线程进入睡眠状态；</li><li>线程由于 I/O 操作而受阻塞；</li><li>另一个更高优先级的线程出现；</li><li>在支持时间片的系统中，该线程的时间片用完。</li></ul><h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>程序的运行依靠的是进程，而进程的执行依靠的是多个线程，多线程之间可以共享一块内存和一组系统资源，而多进程间通常是相互独立的。线程的创建有三种方式：继承 Thread 重写 run 方法，实现 Runnable 或 Callable 接口，其中 Callable 可以允许线程的执行有返回值，JDK 8 中也可以使用 Lambda 来更加方便的使用线程，线程是有优先级的，优先级从 1-10 ，数字越大优先级越高，也越早被执行。如果两个线程各自拥有一把锁的同时，又同时等待获取对方的锁，就会造成死锁。可以降低锁的粒度或减少同步代码块的范围或使用 Java 提供的安全类，来防止死锁的产生。</p><h2 id="线程池之-ThreadPoolExecutor-面试题"><a href="#线程池之-ThreadPoolExecutor-面试题" class="headerlink" title="线程池之 ThreadPoolExecutor + 面试题"></a>线程池之 ThreadPoolExecutor + 面试题</h2><h3 id="线程池介绍"><a href="#线程池介绍" class="headerlink" title="线程池介绍"></a>线程池介绍</h3><p>线程池（Thread Pool）：把一个或多个线程通过统一的方式进行调度和重复使用的技术，避免了因为线程过多而带来使用上的开销。</p><h4 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h4><ul><li>可重复使用已有线程，避免对象创建、消亡和过度切换的性能开销。</li><li>避免创建大量同类线程所导致的资源过度竞争和内存溢出的问题。</li><li>支持更多功能，比如延迟任务线程池（newScheduledThreadPool）和缓存线程池（newCachedThreadPool）等。</li></ul><h3 id="线程池使用"><a href="#线程池使用" class="headerlink" title="线程池使用"></a>线程池使用</h3><p>创建线程池有两种方式：ThreadPoolExecutor 和 Executors，其中 Executors 又可以创建 6 种不同的线程池类型，会在下节讲，本节重点来看看 ThreadPoolExecutor 的使用。</p><h4 id="ThreadPoolExecutor-的使用"><a href="#ThreadPoolExecutor-的使用" class="headerlink" title="ThreadPoolExecutor 的使用"></a>ThreadPoolExecutor 的使用</h4><p>线程池使用代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">10</span>, <span class="number">10L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行线程池</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, Java.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>Hello, Java.</p></blockquote><h4 id="ThreadPoolExecutor-参数说明"><a href="#ThreadPoolExecutor-参数说明" class="headerlink" title="ThreadPoolExecutor 参数说明"></a>ThreadPoolExecutor 参数说明</h4><p>ThreadPoolExecutor 构造方法有以下四个，如下图所示：</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/ce89fc40-d2d4-11e9-b6c4-07be7ef1cd0f"></p><p>其中最后一个构造方法有 7 个构造参数，包含了前三个方法的构造参数，这 7 个参数名称如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其代表的含义如下：</p><h5 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h5><p>线程池中的核心线程数，默认情况下核心线程一直存活在线程池中，如果将 ThreadPoolExecutor 的 allowCoreThreadTimeOut 属性设为 true，如果线程池一直闲置并超过了 keepAliveTime 所指定的时间，核心线程就会被终止。</p><h5 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h5><p>线程池中最大线程数，如果活动的线程达到这个数值以后，后续的新任务将会被阻塞（放入任务队列）。</p><h5 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h5><p>线程池的闲置超时时间，默认情况下对非核心线程生效，如果闲置时间超过这个时间，非核心线程就会被回收。如果 ThreadPoolExecutor 的 allowCoreThreadTimeOut 设为 true 的时候，核心线程如果超过闲置时长也会被回收。</p><h5 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h5><p>配合 keepAliveTime 使用，用来标识 keepAliveTime 的时间单位。</p><h5 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h5><p>线程池中的任务队列，使用 execute() 或 submit() 方法提交的任务都会存储在此队列中。</p><h5 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h5><p>为线程池提供创建新线程的线程工厂。</p><h5 id="rejectedExecutionHandler"><a href="#rejectedExecutionHandler" class="headerlink" title="rejectedExecutionHandler"></a>rejectedExecutionHandler</h5><p>线程池任务队列超过最大值之后的拒绝策略，RejectedExecutionHandler 是一个接口，里面只有一个 rejectedExecution 方法，可在此方法内添加任务超出最大值的事件处理。ThreadPoolExecutor 也提供了 4 种默认的拒绝策略：</p><ul><li>new ThreadPoolExecutor.DiscardPolicy()：丢弃掉该任务，不进行处理</li><li>new ThreadPoolExecutor.DiscardOldestPolicy()：丢弃队列里最近的一个任务，并执行当前任务</li><li>new ThreadPoolExecutor.AbortPolicy()：直接抛出 RejectedExecutionException 异常</li><li>new ThreadPoolExecutor.CallerRunsPolicy()：既不抛弃任务也不抛出异常，直接使用主线程来执行此任务</li></ul><p>包含所有参数的 ThreadPoolExecutor 使用代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                <span class="number">10L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">2</span>),</span><br><span class="line">                <span class="keyword">new</span> MyThreadFactory(), <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        threadPool.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        String threadName = <span class="string">&quot;MyThread&quot;</span> + count.addAndGet(<span class="number">1</span>);</span><br><span class="line">        t.setName(threadName);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程池执行方法-execute-VS-submit"><a href="#线程池执行方法-execute-VS-submit" class="headerlink" title="线程池执行方法 execute() VS submit()"></a>线程池执行方法 execute() VS submit()</h4><p>execute() 和 submit() 都是用来执行线程池的，区别在于 submit() 方法可以接收线程池执行的返回值。</p><p>下面分别来看两个方法的具体使用和区别：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">10</span>, <span class="number">10L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">100</span>));</span><br><span class="line"><span class="comment">// execute 使用</span></span><br><span class="line">threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, Java.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// submit 使用</span></span><br><span class="line">Future&lt;String&gt; future = threadPoolExecutor.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, 老王.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>Hello, Java.</p><p>Hello, 老王.</p><p>Success</p></blockquote><h4 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h4><p>线程池关闭，可以使用 shutdown() 或 shutdownNow() 方法，它们的区别是：</p><ul><li>shutdown()：不会立即终止线程池，而是要等所有任务队列中的任务都执行完后才会终止。执行完 shutdown 方法之后，线程池就不会再接受新任务了。</li><li>shutdownNow()：执行该方法，线程池的状态立刻变成 STOP 状态，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，执行此方法会返回未执行的任务。</li></ul><p>下面用代码来模拟 shutdown() 之后，给线程池添加任务，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m &quot;</span> + i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">threadPoolExecutor.shutdown();</span><br><span class="line">threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;I&#x27;m Java.&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>I’m 0</p><p>Exception in thread “main” java.util.concurrent.RejectedExecutionException: Task com.interview.chapter5.Section2<code>$$Lambda$2</code>/1828972342@568db2f2 rejected from java.util.concurrent.ThreadPoolExecutor@378bf509[Shutting down, pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 0]</p><p>I’m 1</p></blockquote><p>可以看出，shutdown() 之后就不会再接受新的任务了，不过之前的任务会被执行完成。</p><h3 id="相关面试题-18"><a href="#相关面试题-18" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="ThreadPoolExecutor-有哪些常用的方法？"><a href="#ThreadPoolExecutor-有哪些常用的方法？" class="headerlink" title="ThreadPoolExecutor 有哪些常用的方法？"></a>ThreadPoolExecutor 有哪些常用的方法？</h4><p>答：常用方法如下所示：</p><ul><li>submit()/execute()：执行线程池</li><li>shutdown()/shutdownNow()：终止线程池</li><li>isShutdown()：判断线程是否终止</li><li>getActiveCount()：正在运行的线程数</li><li>getCorePoolSize()：获取核心线程数</li><li>getMaximumPoolSize()：获取最大线程数</li><li>getQueue()：获取线程池中的任务队列</li><li>allowCoreThreadTimeOut(boolean)：设置空闲时是否回收核心线程</li></ul><h4 id="以下程序执行的结果是什么？-2"><a href="#以下程序执行的结果是什么？-2" class="headerlink" title="以下程序执行的结果是什么？"></a>以下程序执行的结果是什么？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">10</span>, <span class="number">10L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue());</span><br><span class="line">threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I：&quot;</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">threadPoolExecutor.shutdownNow();</span><br><span class="line">System.out.println(<span class="string">&quot;Java&quot;</span>);</span><br></pre></td></tr></table></figure><p>答：程序执行的结果是：</p><blockquote><p>I：0</p><p>Java</p><p>java.lang.InterruptedException: sleep interrupted（报错信息）</p><p>I：1</p></blockquote><p>题目解析：因为程序中使用了 <code>shutdownNow()</code> 会导致程序执行一次之后报错，抛出 <code>sleep interrupted</code> 异常，又因为本身有 try/catch，所以程序会继续执行打印 <code>I：1</code> 。</p><h4 id="在-ThreadPool-中-submit-和-execute-有什么区别？"><a href="#在-ThreadPool-中-submit-和-execute-有什么区别？" class="headerlink" title="在 ThreadPool 中 submit() 和 execute() 有什么区别？"></a>在 ThreadPool 中 submit() 和 execute() 有什么区别？</h4><p>答：submit() 和 execute() 都是用来执行线程池的，只不过使用 execute() 执行线程池不能有返回方法，而使用 submit() 可以使用 Future 接收线程池执行的返回值。</p><p>submit() 方法源码（JDK 8）如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>execute() 源码（JDK 8）如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//..... 其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="说一下-ThreadPoolExecutor-都需要哪些参数？"><a href="#说一下-ThreadPoolExecutor-都需要哪些参数？" class="headerlink" title="说一下 ThreadPoolExecutor 都需要哪些参数？"></a>说一下 ThreadPoolExecutor 都需要哪些参数？</h4><p>答：ThreadPoolExecutor 最多包含以下七个参数：</p><ul><li>corePoolSize：线程池中的核心线程数</li><li>maximumPoolSize：线程池中最大线程数</li><li>keepAliveTime：闲置超时时间</li><li>unit：keepAliveTime 超时时间的单位（时/分/秒等）</li><li>workQueue：线程池中的任务队列</li><li>threadFactory：为线程池提供创建新线程的线程工厂</li><li>rejectedExecutionHandler：线程池任务队列超过最大值之后的拒绝策略</li></ul><p>更多详细介绍，请见正文。</p><h4 id="在线程池中-shutdownNow-和-shutdown-有什么区别？"><a href="#在线程池中-shutdownNow-和-shutdown-有什么区别？" class="headerlink" title="在线程池中 shutdownNow() 和 shutdown() 有什么区别？"></a>在线程池中 shutdownNow() 和 shutdown() 有什么区别？</h4><p>答：shutdownNow() 和 shutdown() 都是用来终止线程池的，它们的区别是，使用 shutdown() 程序不会报错，也不会立即终止线程，它会等待线程池中的缓存任务执行完之后再退出，执行了 shutdown() 之后就不能给线程池添加新任务了；shutdownNow() 会试图立马停止任务，如果线程池中还有缓存任务正在执行，则会抛出 java.lang.InterruptedException: sleep interrupted 异常。</p><h4 id="说一说线程池的工作原理？"><a href="#说一说线程池的工作原理？" class="headerlink" title="说一说线程池的工作原理？"></a>说一说线程池的工作原理？</h4><p>答：当线程池中有任务需要执行时，线程池会判断如果线程数量没有超过核心数量就会新建线程池进行任务执行，如果线程池中的线程数量已经超过核心线程数，这时候任务就会被放入任务队列中排队等待执行；如果任务队列超过最大队列数，并且线程池没有达到最大线程数，就会新建线程来执行任务；如果超过了最大线程数，就会执行拒绝执行策略。</p><h4 id="以下线程名称被打印了几次？"><a href="#以下线程名称被打印了几次？" class="headerlink" title="以下线程名称被打印了几次？"></a>以下线程名称被打印了几次？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                <span class="number">10L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">2</span>),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line">threadPool.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 打印线程名称</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>答：线程名被打印了 3 次。<br>题目解析：线程池第 1 次执行任务时，会新创建任务并执行；第 2 次执行任务时，因为没有空闲线程所以会把任务放入队列；第 3 次同样把任务放入队列，因为队列最多可以放两条数据，所以第 4 次之后的执行都会被舍弃（没有定义拒绝策略），于是就打印了 3 次线程名称。</p><h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>ThreadPoolExecutor 是创建线程池最传统和最推荐使用的方式，创建时要设置线程池的核心线程数和最大线程数还有任务队列集合，如果任务量大于队列的最大长度，线程池会先判断当前线程数量是否已经到达最大线程数，如果没有达到最大线程数就新建线程来执行任务，如果已经达到最大线程数，就会执行拒绝策略（拒绝策略可自行定义）。线程池可通过 submit() 来调用执行，从而获得线程执行的结果，也可以通过 shutdown() 来终止线程池。</p><h2 id="线程池之-Executors-面试题"><a href="#线程池之-Executors-面试题" class="headerlink" title="线程池之 Executors + 面试题"></a>线程池之 Executors + 面试题</h2><p>线程池的创建分为两种方式：ThreadPoolExecutor 和 Executors，上一节学习了 ThreadPoolExecutor 的使用方式，本节重点来看 Executors 是如何创建线程池的。<br>Executors 可以创建以下六种线程池。</p><ul><li>FixedThreadPool(n)：创建一个数量固定的线程池，超出的任务会在队列中等待空闲的线程，可用于控制程序的最大并发数。</li><li>CachedThreadPool()：短时间内处理大量工作的线程池，会根据任务数量产生对应的线程，并试图缓存线程以便重复使用，如果限制 60 秒没被使用，则会被移除缓存。</li><li>SingleThreadExecutor()：创建一个单线程线程池。</li><li>ScheduledThreadPool(n)：创建一个数量固定的线程池，支持执行定时性或周期性任务。</li><li>SingleThreadScheduledExecutor()：此线程池就是单线程的 newScheduledThreadPool。</li><li>WorkStealingPool(n)：Java 8 新增创建线程池的方法，创建时如果不设置任何参数，则以当前机器处理器个数作为线程个数，此线程池会并行处理任务，不能保证执行顺序。</li></ul><p>下面分别来看以上六种线程池的具体代码使用。</p><h3 id="FixedThreadPool-使用"><a href="#FixedThreadPool-使用" class="headerlink" title="FixedThreadPool 使用"></a>FixedThreadPool 使用</h3><p>创建固定个数的线程池，具体示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    fixedThreadPool.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CurrentTime - &quot;</span> + LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>CurrentTime - 2019-06-27 20:58:58</p><p>CurrentTime - 2019-06-27 20:58:58</p><p>CurrentTime - 2019-06-27 20:58:59</p></blockquote><p>根据执行结果可以看出，newFixedThreadPool(2) 确实是创建了两个线程，在执行了一轮（2 次）之后，停了一秒，有了空闲线程，才执行第三次。</p><h3 id="CachedThreadPool-使用"><a href="#CachedThreadPool-使用" class="headerlink" title="CachedThreadPool 使用"></a>CachedThreadPool 使用</h3><p>根据实际需要自动创建带缓存功能的线程池，具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    cachedThreadPool.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CurrentTime - &quot;</span> +</span><br><span class="line">                           LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>CurrentTime - 2019-06-27 21:24:46</p><p>CurrentTime - 2019-06-27 21:24:46</p><p>CurrentTime - 2019-06-27 21:24:46</p><p>CurrentTime - 2019-06-27 21:24:46</p><p>CurrentTime - 2019-06-27 21:24:46</p><p>CurrentTime - 2019-06-27 21:24:46</p><p>CurrentTime - 2019-06-27 21:24:46</p><p>CurrentTime - 2019-06-27 21:24:46</p><p>CurrentTime - 2019-06-27 21:24:46</p><p>CurrentTime - 2019-06-27 21:24:46</p></blockquote><p>根据执行结果可以看出，newCachedThreadPool 在短时间内会创建多个线程来处理对应的任务，并试图把它们进行缓存以便重复使用。</p><h3 id="SingleThreadExecutor-使用"><a href="#SingleThreadExecutor-使用" class="headerlink" title="SingleThreadExecutor 使用"></a>SingleThreadExecutor 使用</h3><p>创建单个线程的线程池，具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    singleThreadExecutor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CurrentTime - &quot;</span> +</span><br><span class="line">                           LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>CurrentTime - 2019-06-27 21:43:34</p><p>CurrentTime - 2019-06-27 21:43:35</p><p>CurrentTime - 2019-06-27 21:43:36</p></blockquote><h3 id="ScheduledThreadPool-使用"><a href="#ScheduledThreadPool-使用" class="headerlink" title="ScheduledThreadPool 使用"></a>ScheduledThreadPool 使用</h3><p>创建一个可以执行周期性任务的线程池，具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">scheduledThreadPool.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ThreadPool：&quot;</span> + LocalDateTime.now());</span><br><span class="line">&#125;, <span class="number">1L</span>, TimeUnit.SECONDS);</span><br><span class="line">System.out.println(<span class="string">&quot;CurrentTime：&quot;</span> + LocalDateTime.now());</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>CurrentTime：2019-06-27T21:54:21.881</p><p>ThreadPool：2019-06-27T21:54:22.845</p></blockquote><p>根据执行结果可以看出，我们设置的 1 秒后执行的任务生效了。</p><h3 id="SingleThreadScheduledExecutor-使用"><a href="#SingleThreadScheduledExecutor-使用" class="headerlink" title="SingleThreadScheduledExecutor 使用"></a>SingleThreadScheduledExecutor 使用</h3><p>创建一个可以执行周期性任务的单线程池，具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService singleThreadScheduledExecutor = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">singleThreadScheduledExecutor.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ThreadPool：&quot;</span> + LocalDateTime.now());</span><br><span class="line">&#125;, <span class="number">1L</span>, TimeUnit.SECONDS);</span><br><span class="line">System.out.println(<span class="string">&quot;CurrentTime：&quot;</span> + LocalDateTime.now());</span><br></pre></td></tr></table></figure><h3 id="WorkStealingPool-使用"><a href="#WorkStealingPool-使用" class="headerlink" title="WorkStealingPool 使用"></a>WorkStealingPool 使用</h3><p>Java 8 新增的创建线程池的方式，可根据当前电脑 CPU 处理器数量生成相应个数的线程池，使用代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService workStealingPool = Executors.newWorkStealingPool();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalNumber = i;</span><br><span class="line">    workStealingPool.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I：&quot;</span> + finalNumber);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>I：0</p><p>I：3</p><p>I：2</p><p>I：1</p><p>I：4</p></blockquote><p>根据执行结果可以看出，newWorkStealingPool 是并行处理任务的，并不能保证执行顺序。</p><h3 id="ThreadPoolExecutor-VS-Executors"><a href="#ThreadPoolExecutor-VS-Executors" class="headerlink" title="ThreadPoolExecutor VS Executors"></a>ThreadPoolExecutor VS Executors</h3><p>ThreadPoolExecutor 和 Executors 都是用来创建线程池的，其中 ThreadPoolExecutor 创建线程池的方式相对传统，而 Executors 提供了更多的线程池类型（6 种），但很不幸的消息是在实际开发中并不推荐使用 Executors 的方式来创建线程池。</p><p>无独有偶《阿里巴巴 Java 开发手册》中对于线程池的创建也是这样规定的，内容如下：</p><blockquote><p>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的读者更加明确线程池的运行规则，规避资源耗尽的风险。</p><p>说明：Executors 返回的线程池对象的弊端如下：</p><p>1）FixedThreadPool 和 SingleThreadPool:</p><p>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</p><p>2）CachedThreadPool 和 ScheduledThreadPool:</p><p>允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p></blockquote><p>OOM 是 OutOfMemoryError 的缩写，指内存溢出的意思。</p><h4 id="为什么不允许使用-Executors？"><a href="#为什么不允许使用-Executors？" class="headerlink" title="为什么不允许使用 Executors？"></a>为什么不允许使用 Executors？</h4><p>我们先来看一个简单的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService maxFixedThreadPool =  Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">    maxFixedThreadPool.execute(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后设置 JVM（Java 虚拟机）的启动参数： <code>-Xmx10m -Xms10m</code> （设置 JVM 最大运行内存等于 10M）运行程序，会抛出 OOM 异常，信息如下：</p><blockquote><p>Exception in thread “main” java.lang.OutOfMemoryError: GC overhead limit exceeded</p><p>at java.util.concurrent.LinkedBlockingQueue.offer(LinkedBlockingQueue.java:416)</p><p>at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1371)</p><p>at xxx.main(xxx.java:127)</p></blockquote><h4 id="为什么-Executors-会存在-OOM-的缺陷？"><a href="#为什么-Executors-会存在-OOM-的缺陷？" class="headerlink" title="为什么 Executors 会存在 OOM 的缺陷？"></a>为什么 Executors 会存在 OOM 的缺陷？</h4><p>通过以上代码，找到了 FixedThreadPool 的源码，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到创建 FixedThreadPool 使用了 LinkedBlockingQueue 作为任务队列，继续查看 LinkedBlockingQueue 的源码就会发现问题的根源，源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用 LinkedBlockingQueue 并没有给它指定长度的时候，默认长度为 Integer.MAX_VALUE，这样就会导致程序会给线程池队列添加超多个任务，因为任务量太大就有造成 OOM 的风险。</p><h3 id="相关面试题-19"><a href="#相关面试题-19" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="以下程序会输出什么结果？-1"><a href="#以下程序会输出什么结果？-1" class="headerlink" title="以下程序会输出什么结果？"></a>以下程序会输出什么结果？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService workStealingPool = Executors.newWorkStealingPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> finalNumber = i;</span><br><span class="line">        workStealingPool.execute(() -&gt; &#123;</span><br><span class="line">            System.out.print(finalNumber);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：不输出任何结果<br>B：输出 0 到 9 有序数字<br>C：输出 0 到 9 无需数字<br>D：以上全对</p><p>答：A<br>题目解析：newWorkStealingPool 内部实现是 ForkJoinPool，它会随着主程序的退出而退出，因为主程序没有任何休眠和等待操作，程序会一闪而过，不会执行任何信息，所以也就不会输出任何结果。</p><h4 id="Executors-能创建单线程的线程池吗？怎么创建？"><a href="#Executors-能创建单线程的线程池吗？怎么创建？" class="headerlink" title="Executors 能创建单线程的线程池吗？怎么创建？"></a>Executors 能创建单线程的线程池吗？怎么创建？</h4><p>答：Executors 可以创建单线程线程池，创建分为两种方式：</p><ul><li>Executors.newSingleThreadExecutor()：创建一个单线程线程池。</li><li>Executors.newSingleThreadScheduledExecutor()：创建一个可以执行周期性任务的单线程池。</li></ul><h4 id="Executors-中哪个线程适合执行短时间内大量任务？"><a href="#Executors-中哪个线程适合执行短时间内大量任务？" class="headerlink" title="Executors 中哪个线程适合执行短时间内大量任务？"></a>Executors 中哪个线程适合执行短时间内大量任务？</h4><p>答：newCachedThreadPool() 适合处理大量短时间工作任务。它会试图缓存线程并重用，如果没有缓存任务就会新创建任务，如果线程的限制时间超过六十秒，则会被移除线程池，因此它比较适合短时间内处理大量任务。</p><h4 id="可以执行周期性任务的线程池都有哪些？"><a href="#可以执行周期性任务的线程池都有哪些？" class="headerlink" title="可以执行周期性任务的线程池都有哪些？"></a>可以执行周期性任务的线程池都有哪些？</h4><p>答：可执行周期性任务的线程池有两个，分别是：newScheduledThreadPool() 和 newSingleThreadScheduledExecutor()，其中 newSingleThreadScheduledExecutor() 是 newScheduledThreadPool() 的单线程版本。</p><h4 id="JDK-8-新增了什么线程池？有什么特点？"><a href="#JDK-8-新增了什么线程池？有什么特点？" class="headerlink" title="JDK 8 新增了什么线程池？有什么特点？"></a>JDK 8 新增了什么线程池？有什么特点？</h4><p>答：JDK 8 新增的线程池是 newWorkStealingPool(n)，如果不指定并发数（也就是不指定 n），newWorkStealingPool() 会根据当前 CPU 处理器数量生成相应个数的线程池。它的特点是并行处理任务的，不能保证任务的执行顺序。</p><h4 id="newFixedThreadPool-和-ThreadPoolExecutor-有什么关系？"><a href="#newFixedThreadPool-和-ThreadPoolExecutor-有什么关系？" class="headerlink" title="newFixedThreadPool 和 ThreadPoolExecutor 有什么关系？"></a>newFixedThreadPool 和 ThreadPoolExecutor 有什么关系？</h4><p>答：newFixedThreadPool 是 ThreadPoolExecutor 包装，newFixedThreadPool 底层也是通过 ThreadPoolExecutor 实现的。</p><p>newFixedThreadPool 的实现源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单线程的线程池存在的意义是什么？"><a href="#单线程的线程池存在的意义是什么？" class="headerlink" title="单线程的线程池存在的意义是什么？"></a>单线程的线程池存在的意义是什么？</h4><p>答：单线程线程池提供了队列功能，如果有多个任务会排队执行，可以保证任务执行的顺序性。单线程线程池也可以重复利用已有线程，减低系统创建和销毁线程的性能开销。</p><h4 id="线程池为什么建议使用-ThreadPoolExecutor-创建，而非-Executors？"><a href="#线程池为什么建议使用-ThreadPoolExecutor-创建，而非-Executors？" class="headerlink" title="线程池为什么建议使用 ThreadPoolExecutor 创建，而非 Executors？"></a>线程池为什么建议使用 ThreadPoolExecutor 创建，而非 Executors？</h4><p>答：使用 ThreadPoolExecutor 能让开发者更加明确线程池的运行规则，避免资源耗尽的风险。</p><p>Executors 返回线程池的缺点如下：</p><ul><li>FixedThreadPool 和 SingleThreadPool 允许请求队列长度为 Integer.MAX_VALUE，可能会堆积大量请求，可能会导致内存溢出；</li><li>CachedThreadPool 和 ScheduledThreadPool 允许创建线程数量为 Integer.MAX_VALUE，创建大量线程，可能会导致内存溢出。</li></ul><h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p>Executors 可以创建 6 种不同类型的线程池，其中 newFixedThreadPool() 适合执行单位时间内固定的任务数，newCachedThreadPool() 适合短时间内处理大量任务，newSingleThreadExecutor() 和 newSingleThreadScheduledExecutor() 为单线程线程池，而 newSingleThreadScheduledExecutor() 可以执行周期性的任务，是 newScheduledThreadPool(n) 的单线程版本，而 newWorkStealingPool() 为 JDK 8 新增的并发线程池，可以根据当前电脑的 CPU 处理数量生成对比数量的线程池，但它的执行为并发执行不能保证任务的执行顺序。</p><h2 id="ThreadLocal-有什么用-面试题"><a href="#ThreadLocal-有什么用-面试题" class="headerlink" title="ThreadLocal 有什么用 + 面试题"></a>ThreadLocal 有什么用 + 面试题</h2><p><strong>什么是 ThreadLocal？</strong><br>ThreadLocal 诞生于 JDK 1.2，用于解决多线程间的数据隔离问题。也就是说 ThreadLocal 会为每一个线程创建一个单独的变量副本。</p><p><strong>ThreadLocal 有什么用？</strong></p><p>ThreadLocal 最典型的使用场景有两个：</p><ul><li>ThreadLocal 可以用来管理 Session，因为每个人的信息都是不一样的，所以就很适合用 ThreadLocal 来管理；</li><li>数据库连接，为每一个线程分配一个独立的资源，也适合用 ThreadLocal 来实现。</li></ul><p>其中，ThreadLocal 也被用在很多大型开源框架中，比如 Spring 的事务管理器，还有 Hibernate 的 Session 管理等，既然 ThreadLocal 用途如此广泛，那接下来就让我们共同看看 ThreadLocal 要怎么用？ThreadLocal 使用中要注意什么？以及 ThreadLocal 的存储原理等，一起来看吧。</p><h3 id="ThreadLocal-基础使用"><a href="#ThreadLocal-基础使用" class="headerlink" title="ThreadLocal 基础使用"></a>ThreadLocal 基础使用</h3><p>ThreadLocal 常用方法有 set(T)、get()、remove() 等，具体使用请参考以下代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"><span class="comment">// 存值</span></span><br><span class="line">threadLocal.set(Arrays.asList(<span class="string">&quot;老王&quot;</span>, <span class="string">&quot;Java 面试题&quot;</span>));</span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line">List list = (List) threadLocal.get();</span><br><span class="line">System.out.println(list.size());</span><br><span class="line">System.out.println(threadLocal.get());</span><br><span class="line"><span class="comment">//删除值</span></span><br><span class="line">threadLocal.remove();</span><br><span class="line">System.out.println(threadLocal.get());</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>2</p><p>[老王, Java 面试题]</p><p>null</p></blockquote><p>ThreadLocal 所有方法，如下图所示：</p><p><img src="/" alt="img" class="lazyload" data-src="https://images.gitbook.cn/78d17530-d43c-11e9-b555-8d750b738917"></p><h3 id="ThreadLocal-数据共享"><a href="#ThreadLocal-数据共享" class="headerlink" title="ThreadLocal 数据共享"></a>ThreadLocal 数据共享</h3><p>既然 ThreadLocal 设计的初衷是解决线程间信息隔离的，那 ThreadLocal 能不能实现线程间信息共享呢？<br>答案是肯定的，只需要使用 ThreadLocal 的子类 InheritableThreadLocal 就可以轻松实现，来看具体实现代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal inheritableThreadLocal = <span class="keyword">new</span> InheritableThreadLocal();</span><br><span class="line">inheritableThreadLocal.set(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(inheritableThreadLocal.get())).start();</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>老王</p></blockquote><p>从以上代码可以看出，主线程和新创建的线程之间实现了信息共享。</p><h3 id="ThreadLocal-高级用法"><a href="#ThreadLocal-高级用法" class="headerlink" title="ThreadLocal 高级用法"></a>ThreadLocal 高级用法</h3><h4 id="内存溢出代码演示"><a href="#内存溢出代码演示" class="headerlink" title="内存溢出代码演示"></a>内存溢出代码演示</h4><p>下面我们用代码实现 ThreadLocal 内存溢出的情况，请参考以下代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">    <span class="keyword">static</span> Integer MOCK_MAX = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">static</span> Integer THREAD_MAX = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(THREAD_MAX);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_MAX; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                threadLocal.set(<span class="keyword">new</span> ThreadLocalTest().getList());</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">List <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MOCK_MAX; i++) &#123;</span><br><span class="line">            list.add(<span class="string">&quot;Version：JDK 8&quot;</span>);</span><br><span class="line">            list.add(<span class="string">&quot;ThreadLocal&quot;</span>);</span><br><span class="line">            list.add(<span class="string">&quot;Author：老王&quot;</span>);</span><br><span class="line">            list.add(<span class="string">&quot;DateTime：&quot;</span> + LocalDateTime.now());</span><br><span class="line">            list.add(<span class="string">&quot;Test：ThreadLocal OOM&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置 JVM（Java 虚拟机）启动参数 <code>-Xmx=100m</code> （最大运行内存 100 M），运行程序不久后就会出现如下异常：</p><p><img src="/" alt="img" class="lazyload" data-src="https://images.gitbook.cn/8d5895b0-d43c-11e9-b555-8d750b738917"></p><p>此时我们用 VisualVM 观察到程序运行的内存使用情况，发现内存一直在缓慢地上升直到内存超出最大值，从而发生内存溢出的情况。</p><p>内存使用情况，如下图所示：</p><p><img src="/" alt="img" class="lazyload" data-src="https://images.gitbook.cn/9eacecd0-d43c-11e9-b555-8d750b738917"></p><h4 id="内存溢出原理分析"><a href="#内存溢出原理分析" class="headerlink" title="内存溢出原理分析"></a>内存溢出原理分析</h4><p>在开始之前，先来看下 ThreadLocal 是如何存储数据的。<br>首先，找到 ThreadLocal.set() 的源码，代码如下（此源码基于 JDK 8）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 ThreadLocal 首先获取到 ThreadLocalMap 对象，然后再执行 ThreadLocalMap.set() 方法，进而打开此方法的源码，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从整个代码可以看出，首先 ThreadLocal 并不存储数据，而是依靠 ThreadLocalMap 来存储数据，ThreadLocalMap 中有一个 Entry 数组，每个 Entry 对象是以 K/V 的形式对数据进行存储的，其中 K 就是 ThreadLocal 本身，而 V 就是要存储的值，如下图所示：</p><p><img src="/" alt="img" class="lazyload" data-src="https://images.gitbook.cn/b2f02680-d43c-11e9-a4b6-d1d2b628f523"></p><p>可以看出：一个 Thread 中只有一个 ThreadLocalMap，每个 ThreadLocalMap 中存有多个 ThreadLocal，ThreadLocal 引用关系如下：</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/8cb725e0-d7bb-11e9-b208-c16ced46e7a1"></p><p>其中：实线代表强引用，虚线代表弱引用（弱引用具有更短暂的生命周期，在执行垃圾回收时，一旦发现只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存）。</p><p>看到这里我们就理解了 ThreadLocal 造成内存溢出的原因：如果 ThreadLocal 没有被直接引用（外部强引用），在 GC（垃圾回收）时，由于 ThreadLocalMap 中的 key 是弱引用，所以一定就会被回收，这样一来 ThreadLocalMap 中就会出现 key 为 null 的 Entry，并且没有办法访问这些数据，如果当前线程再迟迟不结束的话，这些 key 为 null 的 Entry 的 value 就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value 并且永远无法回收，从而造成内存泄漏。</p><h4 id="ThreadLocal-的正确使用方法"><a href="#ThreadLocal-的正确使用方法" class="headerlink" title="ThreadLocal 的正确使用方法"></a>ThreadLocal 的正确使用方法</h4><p>既然已经知道了 ThreadLocal 内存溢出的原因，那解决办法就很清晰了，只需要在使用完 ThreadLocal 之后，调用remove() 方法，清除掉 ThreadLocalMap 中的无用数据就可以了。<br>正确使用的完整示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">    <span class="keyword">static</span> Integer MOCK_MAX = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">static</span> Integer THREAD_MAX = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(THREAD_MAX);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_MAX; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                threadLocal.set(<span class="keyword">new</span> ThreadLocalTest().getList());</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">// 移除对象</span></span><br><span class="line">                threadLocal.remove(); </span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">List <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MOCK_MAX; i++) &#123;</span><br><span class="line">            list.add(<span class="string">&quot;Version：JDK 8&quot;</span>);</span><br><span class="line">            list.add(<span class="string">&quot;ThreadLocal&quot;</span>);</span><br><span class="line">            list.add(<span class="string">&quot;Author：老王&quot;</span>);</span><br><span class="line">            list.add(<span class="string">&quot;DateTime：&quot;</span> + LocalDateTime.now());</span><br><span class="line">            list.add(<span class="string">&quot;Test：ThreadLocal OOM&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出核心代码，我们添加了一句 <code>threadLocal.remove()</code> 命令就解决了内存溢出的问题，这个时候运行代码观察，发现内存的值一直在一个固定的范围内，如下图所示：</p><p><img src="/" alt="img" class="lazyload" data-src="https://images.gitbook.cn/c64f41c0-d43c-11e9-8095-7d08c9f27dca"></p><p>这样就解决了 ThreadLocal 内存溢出的问题了。</p><h3 id="相关面试题-20"><a href="#相关面试题-20" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="ThreadLocal-为什么是线程安全的？"><a href="#ThreadLocal-为什么是线程安全的？" class="headerlink" title="ThreadLocal 为什么是线程安全的？"></a>ThreadLocal 为什么是线程安全的？</h4><p>答：ThreadLocal 为每一个线程维护变量的副本，把共享数据的可见范围限制在同一个线程之内，因此 ThreadLocal 是线程安全的，每个线程都有属于自己的变量。</p><h4 id="ThreadLocal-如何共享数据？"><a href="#ThreadLocal-如何共享数据？" class="headerlink" title="ThreadLocal 如何共享数据？"></a>ThreadLocal 如何共享数据？</h4><p>答：通过 ThreadLocal 的子类 InheritableThreadLocal 可以天然的支持多线程间的信息共享。</p><h4 id="以下程序打印的结果是-true-还是-false？"><a href="#以下程序打印的结果是-true-还是-false？" class="headerlink" title="以下程序打印的结果是 true 还是 false？"></a>以下程序打印的结果是 true 还是 false？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal threadLocal = <span class="keyword">new</span> InheritableThreadLocal();</span><br><span class="line">threadLocal.set(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">ThreadLocal threadLocal2 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">threadLocal2.set(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(threadLocal.get().equals(threadLocal2.get()));</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>答：false。<br>题目分析：因为 threadLocal 使用的是 InheritableThreadLocal（共享本地线程），所以 threadLocal.get() 结果为 <code>老王</code> ，而 threadLocal2 使用的是 ThreadLocal，因此在新线程中 threadLocal2.get() 的结果为 <code>null</code> ，因而它们比较的最终结果为 false。</p><h4 id="ThreadLocal-为什么会发生内存溢出？"><a href="#ThreadLocal-为什么会发生内存溢出？" class="headerlink" title="ThreadLocal 为什么会发生内存溢出？"></a>ThreadLocal 为什么会发生内存溢出？</h4><p>答：ThreadLocal 造成内存溢出的原因：如果 ThreadLocal 没有被直接引用（外部强引用），在 GC（垃圾回收）时，由于 ThreadLocalMap 中的 key 是弱引用，所以一定就会被回收，这样一来 ThreadLocalMap 中就会出现 key 为 null 的 Entry，并且没有办法访问这些数据，如果当前线程再迟迟不结束的话，这些 key 为 null 的 Entry 的 value 就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value 并且永远无法回收，从而造成内存泄漏。</p><h4 id="解决-ThreadLocal-内存溢出的关键代码是什么？"><a href="#解决-ThreadLocal-内存溢出的关键代码是什么？" class="headerlink" title="解决 ThreadLocal 内存溢出的关键代码是什么？"></a>解决 ThreadLocal 内存溢出的关键代码是什么？</h4><p>答：关键代码为 <code>threadLocal.remove()</code> ，使用完 ThreadLocal 之后，调用remove() 方法，清除掉 ThreadLocalMap 中的无用数据就可以避免内存溢出了。</p><h4 id="ThreadLocal-和-Synchonized-有什么区别？"><a href="#ThreadLocal-和-Synchonized-有什么区别？" class="headerlink" title="ThreadLocal 和 Synchonized 有什么区别？"></a>ThreadLocal 和 Synchonized 有什么区别？</h4><p>答：ThreadLocal 和 Synchonized 都用于解决多线程并发访问，防止任务在共享资源上产生冲突，但是 ThreadLocal 与 Synchronized 有本质的区别，Synchronized 用于实现同步机制，是利用锁的机制使变量或代码块在某一时刻只能被一个线程访问，是一种 “以时间换空间” 的方式；而 ThreadLocal 为每一个线程提供了独立的变量副本，这样每个线程的（变量）操作都是相互隔离的，这是一种 “以空间换时间” 的方式。</p><h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p>ThreadLocal 的主要方法是 set(T) 和 get()，用于多线程间的数据隔离，ThreadLocal 也提供了 InheritableThreadLocal 子类，用于实现多线程间的数据共享。但使用 ThreadLocal 一定要注意用完之后使用 remove() 清空 ThreadLocal，不然会操作内存溢出的问题。</p><h2 id="线程安全之-synchronized-和-ReentrantLock-面试题"><a href="#线程安全之-synchronized-和-ReentrantLock-面试题" class="headerlink" title="线程安全之 synchronized 和 ReentrantLock + 面试题"></a>线程安全之 synchronized 和 ReentrantLock + 面试题</h2><p>前面我们介绍了很多关于多线程的内容，在多线程中有一个很重要的课题需要我们攻克，那就是线程安全问题。线程安全问题指的是在多线程中，各线程之间因为同时操作所产生的数据污染或其他非预期的程序运行结果。</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="非线程安全事例"><a href="#非线程安全事例" class="headerlink" title="非线程安全事例"></a>非线程安全事例</h4><p>比如 A 和 B 同时给 C 转账的问题，假设 C 原本余额有 100 元，A 给 C 转账 100 元，正在转的途中，此时 B 也给 C 转了 100 元，这个时候 A 先给 C 转账成功，余额变成了 200 元，但 B 事先查询 C 的余额是 100 元，转账成功之后也是 200 元。当 A 和 B 都给 C 转账完成之后，余额还是 200 元，而非预期的 300 元，这就是典型的线程安全的问题。</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/fa62f4a0-d506-11e9-b16d-918a441334dc"></p><h4 id="非线程安全代码示例"><a href="#非线程安全代码示例" class="headerlink" title="非线程安全代码示例"></a>非线程安全代码示例</h4><p>上面的内容没看明白没关系，下面来看非线程安全的具体代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; addNumber());</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; addNumber());</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;number：&quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            ++number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>number：12085</p></blockquote><p>每次执行的结果可能略有差异，不过几乎不会等于（正确的）累计之和 20000。</p><h4 id="线程安全的解决方案"><a href="#线程安全的解决方案" class="headerlink" title="线程安全的解决方案"></a>线程安全的解决方案</h4><p>线程安全的解决方案有以下几个维度：</p><ul><li>数据不共享，单线程可见，比如 ThreadLocal 就是单线程可见的；</li><li>使用线程安全类，比如 StringBuffer 和 JUC（java.util.concurrent）下的安全类（后面文章会专门介绍）；</li><li>使用同步代码或者锁。</li></ul><h3 id="线程同步和锁"><a href="#线程同步和锁" class="headerlink" title="线程同步和锁"></a>线程同步和锁</h3><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><h5 id="synchronized-介绍"><a href="#synchronized-介绍" class="headerlink" title="synchronized 介绍"></a><strong>synchronized 介绍</strong></h5><p>synchronized 是 Java 提供的同步机制，当一个线程正在操作同步代码块（synchronized 修饰的代码）时，其他线程只能阻塞等待原有线程执行完再执行。</p><h5 id="synchronized-使用"><a href="#synchronized-使用" class="headerlink" title="synchronized 使用"></a><strong>synchronized 使用</strong></h5><p>synchronized 可以修饰代码块或者方法，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修饰代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修饰方法</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 synchronized 完善本文开头的非线程安全的代码。</p><p><strong>方法一：使用 synchronized 修饰代码块</strong>，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread sThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 同步代码</span></span><br><span class="line">            <span class="keyword">synchronized</span> (ThreadSafeTest.class) &#123;</span><br><span class="line">                addNumber();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread sThread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 同步代码</span></span><br><span class="line">            <span class="keyword">synchronized</span> (ThreadSafeTest.class) &#123;</span><br><span class="line">                addNumber();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        sThread.start();</span><br><span class="line">        sThread2.start();</span><br><span class="line">        sThread.join();</span><br><span class="line">        sThread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;number：&quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            ++number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>number：20000</p></blockquote><p><strong>方法二：使用 synchronized 修饰方法</strong>，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread sThread = <span class="keyword">new</span> Thread(() -&gt; addNumber());</span><br><span class="line">        Thread sThread2 = <span class="keyword">new</span> Thread(() -&gt; addNumber());</span><br><span class="line">        sThread.start();</span><br><span class="line">        sThread2.start();</span><br><span class="line">        sThread.join();</span><br><span class="line">        sThread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;number：&quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            ++number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>number：20000</p></blockquote><h5 id="synchronized-实现原理"><a href="#synchronized-实现原理" class="headerlink" title="synchronized 实现原理"></a><strong>synchronized 实现原理</strong></h5><p>synchronized 本质是通过进入和退出的 Monitor 对象来实现线程安全的。<br>以下面代码为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedTest.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们使用 javap 编译之后，生成的字节码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;SynchronizedTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">interview</span>.<span class="title">other</span>.<span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.interview.other.SynchronizedTest();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2                  // class com/interview/other/SynchronizedTest</span><br><span class="line">       <span class="number">2</span>: dup</span><br><span class="line">       <span class="number">3</span>: astore_1</span><br><span class="line">       <span class="number">4</span>: monitorenter</span><br><span class="line">       5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       8: ldc           #4                  // String Java</span><br><span class="line">      10: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">13</span>: aload_1</span><br><span class="line">      <span class="number">14</span>: monitorexit</span><br><span class="line">      <span class="number">15</span>: goto          <span class="number">23</span></span><br><span class="line">      <span class="number">18</span>: astore_2</span><br><span class="line">      <span class="number">19</span>: aload_1</span><br><span class="line">      <span class="number">20</span>: monitorexit</span><br><span class="line">      <span class="number">21</span>: aload_2</span><br><span class="line">      <span class="number">22</span>: athrow</span><br><span class="line">      <span class="number">23</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">5</span>    <span class="number">15</span>    <span class="number">18</span>   any</span><br><span class="line">          <span class="number">18</span>    <span class="number">21</span>    <span class="number">18</span>   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 JVM（Java 虚拟机）是采用 monitorenter 和 monitorexit 两个指令来实现同步的，monitorenter 指令相当于加锁，monitorexit 相当于释放锁。而 monitorenter 和 monitorexit 就是基于 Monitor 实现的。</p><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><h5 id="ReentrantLock-介绍"><a href="#ReentrantLock-介绍" class="headerlink" title="ReentrantLock 介绍"></a><strong>ReentrantLock 介绍</strong></h5><p>ReentrantLock（再入锁）是 Java 5 提供的锁实现，它的功能和 synchronized 基本相同。再入锁通过调用 lock() 方法来获取锁，通过调用 unlock() 来释放锁。</p><h5 id="ReentrantLock-使用"><a href="#ReentrantLock-使用" class="headerlink" title="ReentrantLock 使用"></a><strong>ReentrantLock 使用</strong></h5><p><strong>ReentrantLock 基础使用</strong>，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();    <span class="comment">// 加锁</span></span><br><span class="line"><span class="comment">// 业务代码...</span></span><br><span class="line">lock.unlock();    <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure><p>使用 ReentrantLock 完善本文开头的非线程安全代码，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// ReentrantLock 使用</span></span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                addNumber();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                addNumber();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;number：&quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            ++number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>尝试获取锁</strong></p><p>ReentrantLock 可以无阻塞尝试访问锁，使用 tryLock() 方法，具体使用如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 线程一</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        Thread.sleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="comment">// 线程二</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1</span> * <span class="number">1000</span>);</span><br><span class="line">        System.out.println(reentrantLock.tryLock());</span><br><span class="line">        Thread.sleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">        System.out.println(reentrantLock.tryLock());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>以上代码执行结果如下：</p><blockquote><p>false</p><p>true</p></blockquote><p><strong>尝试一段时间内获取锁</strong></p><p>tryLock() 有一个扩展方法 tryLock(long timeout, TimeUnit unit) 用于尝试一段时间内获取锁，具体实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 线程一</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        Thread.sleep(<span class="number">2</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="comment">// 线程二</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1</span> * <span class="number">1000</span>);</span><br><span class="line">        System.out.println(reentrantLock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS));</span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>以上代码执行结果如下：</p><blockquote><p>2019-07-05 19:53:51</p><p>true</p><p>2019-07-05 19:53:53</p></blockquote><p>可以看出锁在休眠了 2 秒之后，就被线程二直接获取到了，所以说 tryLock(long timeout, TimeUnit unit) 方法内的 timeout 参数指的是获取锁的最大等待时间。</p><h5 id="ReentrantLock-注意事项"><a href="#ReentrantLock-注意事项" class="headerlink" title="ReentrantLock 注意事项"></a>ReentrantLock 注意事项</h5><p>使用 ReentrantLock 一定要记得释放锁，否则该锁会被永久占用。</p><h3 id="相关面试题-21"><a href="#相关面试题-21" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="ReentrantLock-常用的方法有哪些？"><a href="#ReentrantLock-常用的方法有哪些？" class="headerlink" title="ReentrantLock 常用的方法有哪些？"></a>ReentrantLock 常用的方法有哪些？</h4><p>答：ReentrantLock 常见方法如下：</p><ul><li>lock()：用于获取锁</li><li>unlock()：用于释放锁</li><li>tryLock()：尝试获取锁</li><li>getHoldCount()：查询当前线程执行 lock() 方法的次数</li><li>getQueueLength()：返回正在排队等待获取此锁的线程数</li><li>isFair()：该锁是否为公平锁</li></ul><h4 id="ReentrantLock-有哪些优势？"><a href="#ReentrantLock-有哪些优势？" class="headerlink" title="ReentrantLock 有哪些优势？"></a>ReentrantLock 有哪些优势？</h4><p>答：ReentrantLock 具备非阻塞方式获取锁的特性，使用 tryLock() 方法。ReentrantLock 可以中断获得的锁，使用 lockInterruptibly() 方法当获取锁之后，如果所在的线程被中断，则会抛出异常并释放当前获得的锁。ReentrantLock 可以在指定时间范围内获取锁，使用 tryLock(long timeout,TimeUnit unit) 方法。</p><h4 id="ReentrantLock-怎么创建公平锁？"><a href="#ReentrantLock-怎么创建公平锁？" class="headerlink" title="ReentrantLock 怎么创建公平锁？"></a>ReentrantLock 怎么创建公平锁？</h4><p>答：new ReentrantLock() 默认创建的为非公平锁，如果要创建公平锁可以使用 new ReentrantLock(true)。</p><h4 id="公平锁和非公平锁有哪些区别？"><a href="#公平锁和非公平锁有哪些区别？" class="headerlink" title="公平锁和非公平锁有哪些区别？"></a>公平锁和非公平锁有哪些区别？</h4><p>答：公平锁指的是线程获取锁的顺序是按照加锁顺序来的，而非公平锁指的是抢锁机制，先 lock() 的线程不一定先获得锁。</p><h4 id="ReentrantLock-中-lock-和-lockInterruptibly-有什么区别？"><a href="#ReentrantLock-中-lock-和-lockInterruptibly-有什么区别？" class="headerlink" title="ReentrantLock 中 lock() 和 lockInterruptibly() 有什么区别？"></a>ReentrantLock 中 lock() 和 lockInterruptibly() 有什么区别？</h4><p>答：lock() 和 lockInterruptibly() 的区别在于获取线程的途中如果所在的线程中断，lock() 会忽略异常继续等待获取线程，而 lockInterruptibly() 则会抛出 InterruptedException 异常。<br>题目解析：执行以下代码，在线程中分别使用 lock() 和 lockInterruptibly() 查看运行结果，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Lock interruptLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">interruptLock.lock();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            interruptLock.lock();</span><br><span class="line">            <span class="comment">//interruptLock.lockInterruptibly();  // java.lang.InterruptedException</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">thread.interrupt();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Over&quot;</span>);</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>执行以下代码会发现使用 lock() 时程序不会报错，运行完成直接退出；而使用 lockInterruptibly() 则会抛出异常 java.lang.InterruptedException，这就说明：在获取线程的途中如果所在的线程中断，lock() 会忽略异常继续等待获取线程，而 lockInterruptibly() 则会抛出 InterruptedException 异常。</p><h4 id="synchronized-和-ReentrantLock-有什么区别？"><a href="#synchronized-和-ReentrantLock-有什么区别？" class="headerlink" title="synchronized 和 ReentrantLock 有什么区别？"></a>synchronized 和 ReentrantLock 有什么区别？</h4><p>答：synchronized 和 ReentrantLock 都是保证线程安全的，它们的区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等；</li><li>ReentrantLock 性能略高于 synchronized。</li></ul><h4 id="ReentrantLock-的-tryLock-3-TimeUnit-SECONDS-表示等待-3-秒后再去获取锁，这种说法对吗？为什么？"><a href="#ReentrantLock-的-tryLock-3-TimeUnit-SECONDS-表示等待-3-秒后再去获取锁，这种说法对吗？为什么？" class="headerlink" title="ReentrantLock 的 tryLock(3, TimeUnit.SECONDS) 表示等待 3 秒后再去获取锁，这种说法对吗？为什么？"></a>ReentrantLock 的 tryLock(3, TimeUnit.SECONDS) 表示等待 3 秒后再去获取锁，这种说法对吗？为什么？</h4><p>答：不对，tryLock(3, TimeUnit.SECONDS) 表示获取锁的最大等待时间为 3 秒，期间会一直尝试获取，而不是等待 3 秒之后再去获取锁。</p><h4 id="synchronized-是如何实现锁升级的？"><a href="#synchronized-是如何实现锁升级的？" class="headerlink" title="synchronized 是如何实现锁升级的？"></a>synchronized 是如何实现锁升级的？</h4><p>答：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，JVM（Java 虚拟机）让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否尤其线程 id 一致，如果一致则可以直接使用，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，不会阻塞，执行一定次数之后就会升级为重量级锁，进入阻塞，整个过程就是锁升级的过程。</p><h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了线程同步的两种方式 synchronized 和 ReentrantLock，其中 ReentrantLock 使用更加灵活，效率也率高，不过 ReentrantLock 只能修饰代码块，使用 ReentrantLock 需要开发者手动释放锁，如果忘记释放则该锁会一直被占用。synchronized 使用场景更广，可以修饰普通方法、静态方法和代码块等。</p><h2 id="Java-并发包中的高级同步工具-面试题"><a href="#Java-并发包中的高级同步工具-面试题" class="headerlink" title="Java 并发包中的高级同步工具 + 面试题"></a>Java 并发包中的高级同步工具 + 面试题</h2><p>Java 中的并发包指的是 java.util.concurrent（简称 JUC）包和其子包下的类和接口，它为 Java 的并发提供了各种功能支持，比如：</p><ul><li>提供了线程池的创建类 ThreadPoolExecutor、Executors 等；</li><li>提供了各种锁，如 Lock、ReentrantLock 等；</li><li>提供了各种线程安全的数据结构，如 ConcurrentHashMap、LinkedBlockingQueue、DelayQueue 等；</li><li>提供了更加高级的线程同步结构，如 CountDownLatch、CyclicBarrier、Semaphore 等。</li></ul><p>在前面的章节中我们已经详细地介绍了线程池的使用、线程安全的数据结构等，本文我们就重点学习一下 Java 并发包中更高级的线程同步类：CountDownLatch、CyclicBarrier、Semaphore 和 Phaser 等。</p><h3 id="CountDownLatch-介绍和使用"><a href="#CountDownLatch-介绍和使用" class="headerlink" title="CountDownLatch 介绍和使用"></a>CountDownLatch 介绍和使用</h3><p>CountDownLatch（闭锁）可以看作一个只能做减法的计数器，可以让一个或多个线程等待执行。<br>CountDownLatch 有两个重要的方法：</p><ul><li>countDown()：使计数器减 1；</li><li>await()：当计数器不为 0 时，则调用该方法的线程阻塞，当计数器为 0 时，可以唤醒等待的一个或者全部线程。</li></ul><p>CountDownLatch 使用场景：<br>以生活中的情景为例，比如去医院体检，通常人们会提前去医院排队，但只有等到医生开始上班，才能正式开始体检，医生也要给所有人体检完才能下班，这种情况就要使用 CountDownLatch，流程为：患者排队 → 医生上班 → 体检完成 → 医生下班。</p><p>CountDownLatch 示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 医院闭锁</span></span><br><span class="line">CountDownLatch hospitalLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 患者闭锁</span></span><br><span class="line">CountDownLatch patientLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;患者排队&quot;</span>);</span><br><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> j = i;</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hospitalLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;体检：&quot;</span> + j);</span><br><span class="line">        patientLatch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;医生上班&quot;</span>);</span><br><span class="line">hospitalLatch.countDown();</span><br><span class="line">patientLatch.await();</span><br><span class="line">System.out.println(<span class="string">&quot;医生下班&quot;</span>);</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>患者排队</p><p>医生上班</p><p>体检：4</p><p>体检：0</p><p>体检：1</p><p>体检：3</p><p>体检：2</p><p>医生下班</p></blockquote><p>执行流程如下图：</p><p><img src="/" alt="img" class="lazyload" data-src="https://images.gitbook.cn/88078680-d508-11e9-9900-9395ea23d3a7"></p><h3 id="CyclicBarrier-介绍和使用"><a href="#CyclicBarrier-介绍和使用" class="headerlink" title="CyclicBarrier 介绍和使用"></a>CyclicBarrier 介绍和使用</h3><p>CyclicBarrier（循环屏障）通过它可以实现让一组线程等待满足某个条件后同时执行。</p><p>CyclicBarrier 经典使用场景是公交发车，为了简化理解我们这里定义，每辆公交车只要上满 4 个人就发车，后面来的人都会排队依次遵循相应的标准。</p><p>它的构造方法为 <code>CyclicBarrier(int parties,Runnable barrierAction)</code> 其中，parties 表示有几个线程来参与等待，barrierAction 表示满足条件之后触发的方法。CyclicBarrier 使用 await() 方法来标识当前线程已到达屏障点，然后被阻塞。</p><p>CyclicBarrier 示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;发车了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CyclicWorker(cyclicBarrier)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        CyclicWorker(CyclicBarrier cyclicBarrier) &#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;乘客：&quot;</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>乘客：0</p><p>乘客：0</p><p>乘客：0</p><p>乘客：0</p><p>发车了</p><p>乘客：1</p><p>乘客：1</p><p>乘客：1</p><p>乘客：1</p><p>发车了</p></blockquote><p>执行流程如下图：</p><p><img src="/" alt="img" class="lazyload" data-src="https://images.gitbook.cn/9fa38820-d508-11e9-85b2-cd48fc6b5862"></p><h3 id="Semaphore-介绍和使用"><a href="#Semaphore-介绍和使用" class="headerlink" title="Semaphore 介绍和使用"></a>Semaphore 介绍和使用</h3><p>Semaphore（信号量）用于管理多线程中控制资源的访问与使用。Semaphore 就好比停车场的门卫，可以控制车位的使用资源。比如来了 5 辆车，只有 2 个车位，门卫可以先放两辆车进去，等有车出来之后，再让后面的车进入。</p><p>Semaphore 示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line">ThreadPoolExecutor semaphoreThread = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">50</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    semaphoreThread.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 堵塞获取许可</span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="comment">// 释放许可</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>Thread：pool-1-thread-1 时间：2019-07-10 21:18:42</p><p>Thread：pool-1-thread-2 时间：2019-07-10 21:18:42</p><p>Thread：pool-1-thread-3 时间：2019-07-10 21:18:44</p><p>Thread：pool-1-thread-4 时间：2019-07-10 21:18:44</p><p>Thread：pool-1-thread-5 时间：2019-07-10 21:18:46</p></blockquote><p>执行流程如下图：</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/b2050980-d508-11e9-85b2-cd48fc6b5862"></p><h3 id="Phaser-介绍和使用"><a href="#Phaser-介绍和使用" class="headerlink" title="Phaser 介绍和使用"></a>Phaser 介绍和使用</h3><p>Phaser（移相器）是 JDK 7 提供的，它的功能是等待所有线程到达之后，才继续或者开始进行新的一组任务。</p><p>比如有一个旅行团，我们规定所有成员必须都到达指定地点之后，才能发车去往景点一，到达景点之后可以各自游玩，之后必须全部到达指定地点之后，才能继续发车去往下一个景点，类似这种场景就非常适合使用 Phaser。</p><p>Phaser 示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lesson5_6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phaser phaser = <span class="keyword">new</span> MyPhaser();</span><br><span class="line">        PhaserWorker[] phaserWorkers = <span class="keyword">new</span> PhaserWorker[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; phaserWorkers.length; i++) &#123;</span><br><span class="line">            phaserWorkers[i] = <span class="keyword">new</span> PhaserWorker(phaser);</span><br><span class="line">            <span class="comment">// 注册 Phaser 等待的线程数，执行一次等待线程数 +1</span></span><br><span class="line">            phaser.register();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; phaserWorkers.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> PhaserWorker(phaser)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PhaserWorker</span><span class="params">(Phaser phaser)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; | 到达&quot;</span> );</span><br><span class="line">            phaser.arriveAndAwaitAdvance(); <span class="comment">// 集合完毕发车</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>) * <span class="number">1000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; | 到达&quot;</span> );</span><br><span class="line">                phaser.arriveAndAwaitAdvance(); <span class="comment">// 景点 1 集合完毕发车</span></span><br><span class="line">                Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>) * <span class="number">1000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; | 到达&quot;</span> );</span><br><span class="line">                phaser.arriveAndAwaitAdvance(); <span class="comment">// 景点 2 集合完毕发车</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Phaser 每个阶段完成之后的事件通知</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPhaser</span> <span class="keyword">extends</span>  <span class="title">Phaser</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123; <span class="comment">// 每个阶段执行完之后的回调</span></span><br><span class="line">            <span class="keyword">switch</span> (phase) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;==== 集合完毕发车 ====&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;==== 景点1集合完毕，发车去下一个景点 ====&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;==== 景点2集合完毕，发车回家 ====&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>Thread-0 | 到达</p><p>Thread-4 | 到达</p><p>Thread-3 | 到达</p><p>Thread-1 | 到达</p><p>Thread-2 | 到达</p><p>==== 集合完毕发车 ====</p><p>Thread-0 | 到达</p><p>Thread-4 | 到达</p><p>Thread-1 | 到达</p><p>Thread-3 | 到达</p><p>Thread-2 | 到达</p><p>==== 景点1集合完毕，发车去下一个景点 ====</p><p>Thread-4 | 到达</p><p>Thread-3 | 到达</p><p>Thread-2 | 到达</p><p>Thread-1 | 到达</p><p>Thread-0 | 到达</p><p>==== 景点2集合完毕，发车回家 ====</p></blockquote><p>执行流程如下图：</p><p><img src="/" alt="enter image description here" class="lazyload" data-src="https://images.gitbook.cn/d07c4310-d508-11e9-9900-9395ea23d3a7"></p><h3 id="相关面试题-22"><a href="#相关面试题-22" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="以下哪个类用于控制某组资源的访问权限？"><a href="#以下哪个类用于控制某组资源的访问权限？" class="headerlink" title="以下哪个类用于控制某组资源的访问权限？"></a>以下哪个类用于控制某组资源的访问权限？</h4><p>A：Phaser<br>B：Semaphore<br>C：CountDownLatch<br>D：CyclicBarrier</p><p>答：B</p><h4 id="以下哪个类不能被重用？"><a href="#以下哪个类不能被重用？" class="headerlink" title="以下哪个类不能被重用？"></a>以下哪个类不能被重用？</h4><p>A：Phaser<br>B：Semaphore<br>C：CountDownLatch<br>D：CyclicBarrier</p><p>答：C</p><h4 id="以下哪个方法不属于-CountDownLatch-类？"><a href="#以下哪个方法不属于-CountDownLatch-类？" class="headerlink" title="以下哪个方法不属于 CountDownLatch 类？"></a>以下哪个方法不属于 CountDownLatch 类？</h4><p>A：await()<br>B：countDown()<br>C：getCount()<br>D：release()</p><p>答：D<br>题目解析：release() 是 Semaphore 的释放许可的方法，CountDownLatch 类并不包含此方法。</p><h4 id="CyclicBarrier-与-CountDownLatch-有什么区别？"><a href="#CyclicBarrier-与-CountDownLatch-有什么区别？" class="headerlink" title="CyclicBarrier 与 CountDownLatch 有什么区别？"></a>CyclicBarrier 与 CountDownLatch 有什么区别？</h4><p>答：CyclicBarrier 与 CountDownLatch 本质上都是依赖 volatile 和 CAS 实现的，它们区别如下：</p><ul><li>CountDownLatch 只能使用一次，而 CyclicBarrier 可以使用多次。</li><li>CountDownLatch 是手动指定等待一个或多个线程执行完成再执行，而 CyclicBarrier 是 n 个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。</li></ul><h4 id="以下哪个类不包含-await-方法？"><a href="#以下哪个类不包含-await-方法？" class="headerlink" title="以下哪个类不包含 await() 方法？"></a>以下哪个类不包含 await() 方法？</h4><p>A：Semaphore<br>B：CountDownLatch<br>C：CyclicBarrier</p><p>答：A</p><h4 id="以下程序执行花费了多长时间？"><a href="#以下程序执行花费了多长时间？" class="headerlink" title="以下程序执行花费了多长时间？"></a>以下程序执行花费了多长时间？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line">ThreadPoolExecutor semaphoreThread = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">50</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    semaphoreThread.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：1s 以内<br>B：2s 以上</p><p>答：A<br>题目解析：循环先执行了 release() 也就是释放许可的方法，因此程序可以一次性执行 3 个线程，同时会在 1s 以内执行完。</p><h4 id="Semaphore-有哪些常用的方法？"><a href="#Semaphore-有哪些常用的方法？" class="headerlink" title="Semaphore 有哪些常用的方法？"></a>Semaphore 有哪些常用的方法？</h4><p>答：常用方法如下：</p><ul><li>acquire()：获取一个许可。</li><li>release()：释放一个许可。</li><li>availablePermits()：当前可用的许可数。</li><li>acquire(int n)：获取并使用 n 个许可。</li><li>release(int n)：释放 n 个许可。</li></ul><h4 id="Phaser-常用方法有哪些？"><a href="#Phaser-常用方法有哪些？" class="headerlink" title="Phaser 常用方法有哪些？"></a>Phaser 常用方法有哪些？</h4><p>答：常用方法如下：</p><ul><li>register()：注册新的参与者到 Phaser</li><li>arriveAndAwaitAdvance()：等待其他线程执行</li><li>arriveAndDeregister()：注销此线程</li><li>forceTermination()：强制 Phaser 进入终止态</li><li>isTerminated()：判断 Phaser 是否终止</li></ul><h4 id="以下程序是否可以正常执行？“发车了”打印了多少次？"><a href="#以下程序是否可以正常执行？“发车了”打印了多少次？" class="headerlink" title="以下程序是否可以正常执行？“发车了”打印了多少次？"></a>以下程序是否可以正常执行？“发车了”打印了多少次？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;发车了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> CyclicWorker(cyclicBarrier)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        CyclicWorker(CyclicBarrier cyclicBarrier) &#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;乘客：&quot;</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(<span class="string">&quot;乘客 II：&quot;</span> + i);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：可以正常执行，因为执行了两次 await()，所以“发车了”打印了 4 次。</p><h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p>本文我们介绍了四种比 synchronized 更高级的线程同步类，其中 CountDownLatch、CyclicBarrier、Phaser 功能比较类似都是实现线程间的等待，只是它们的侧重点有所不同，其中 CountDownLatch 一般用于等待一个或多个线程执行完，才执行当前线程，并且 CountDownLatch 不能重复使用；CyclicBarrier 用于等待一组线程资源都进入屏障点再共同执行；Phaser 是 JDK 7 提供的功能更加强大和更加灵活的线程辅助工具，等待所有线程达到之后，继续或开始新的一组任务，Phaser 提供了动态增加和消除线程同步个数功能。而 Semaphore 提供的功能更像锁，用于控制一组资源的访问权限。</p><h2 id="Java-中的各种锁和-CAS-面试题"><a href="#Java-中的各种锁和-CAS-面试题" class="headerlink" title="Java 中的各种锁和 CAS + 面试题"></a>Java 中的各种锁和 CAS + 面试题</h2><p>如果说快速理解多线程有什么捷径的话，那本文介绍的各种锁无疑是其中之一，它不但为我们开发多线程程序提供理论支持，还是面试中经常被问到的核心面试题之一。因此下面就让我们一起深入地学习一下这些锁吧。</p><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>悲观锁和乐观锁并不是某个具体的“锁”而是一种并发编程的基本概念。乐观锁和悲观锁最早出现在数据库的设计当中，后来逐渐被 Java 的并发包所引入。</p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观地认为，不加锁的并发操作一定会出问题。</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁正好和悲观锁相反，它获取数据的时候，并不担心数据被修改，每次获取数据的时候也不会加锁，只是在更新数据的时候，通过判断现有的数据是否和原数据一致来判断数据是否被其他线程操作，如果没被其他线程修改则进行数据更新，如果被其他线程修改则不进行数据更新。</p><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p>根据线程获取锁的抢占机制，锁又可以分为公平锁和非公平锁。</p><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>公平锁是指多个线程按照申请锁的顺序来获取锁。</p><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。<br>ReentrantLock 提供了公平锁和非公平锁的实现。</p><ul><li>公平锁：new ReentrantLock(true)</li><li>非公平锁：new ReentrantLock(false)</li></ul><p>如果构造函数不传任何参数的时候，默认提供的是非公平锁。</p><h3 id="独占锁和共享锁"><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h3><p>根据锁能否被多个线程持有，可以把锁分为独占锁和共享锁。</p><h4 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h4><p>独占锁是指任何时候都只有一个线程能执行资源操作。</p><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><p>共享锁指定是可以同时被多个线程读取，但只能被一个线程修改。比如 Java 中的 ReentrantReadWriteLock 就是共享锁的实现方式，它允许一个线程进行写操作，允许多个线程读操作。</p><p>ReentrantReadWriteLock 共享锁演示代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MyReadWriteLock rwLock = <span class="keyword">new</span> MyReadWriteLock();</span><br><span class="line">        <span class="comment">// 创建读锁 r1 和 r2</span></span><br><span class="line">        Thread r1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                rwLock.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;r1&quot;</span>);</span><br><span class="line">        Thread r2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                rwLock.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;r2&quot;</span>);</span><br><span class="line">        r1.start();</span><br><span class="line">        r2.start();</span><br><span class="line">        <span class="comment">// 等待同时读取线程执行完成</span></span><br><span class="line">        r1.join();</span><br><span class="line">        r2.join();</span><br><span class="line">        <span class="comment">// 开启写锁的操作</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                rwLock.write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;w1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                rwLock.write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;w2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReadWriteLock</span> </span>&#123;</span><br><span class="line">        ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.readLock().lock();</span><br><span class="line">                System.out.println(<span class="string">&quot;读操作，进入 | 线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;读操作，退出 | 线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.readLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.writeLock().lock();</span><br><span class="line">                System.out.println(<span class="string">&quot;写操作，进入 | 线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;写操作，退出 | 线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>读操作，进入 | 线程：r1</p><p>读操作，进入 | 线程：r2</p><p>读操作，退出 | 线程：r1</p><p>读操作，退出 | 线程：r2</p><p>写操作，进入 | 线程：w1</p><p>写操作，退出 | 线程：w1</p><p>写操作，进入 | 线程：w2</p><p>写操作，退出 | 线程：w2</p></blockquote><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>可重入锁指的是该线程获取了该锁之后，可以无限次的进入该锁锁住的代码。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗 CPU。</p><h3 id="CAS-与-ABA"><a href="#CAS-与-ABA" class="headerlink" title="CAS 与 ABA"></a>CAS 与 ABA</h3><p>CAS（Compare and Swap）比较并交换，是一种乐观锁的实现，是用非阻塞算法来代替锁定，其中 java.util.concurrent 包下的 AtomicInteger 就是借助 CAS 来实现的。<br>但 CAS 也不是没有任何副作用，比如著名的 ABA 问题就是 CAS 引起的。</p><h4 id="ABA-问题描述"><a href="#ABA-问题描述" class="headerlink" title="ABA 问题描述"></a>ABA 问题描述</h4><p>老王去银行取钱，余额有 200 元，老王取 100 元，但因为程序的问题，启动了两个线程，线程一和线程二进行比对扣款，线程一获取原本有 200 元，扣除 100 元，余额等于 100 元，此时阿里给老王转账 100 元，于是启动了线程三抢先在线程二之前执行了转账操作，把 100 元又变成了 200 元，而此时线程二对比自己事先拿到的 200 元和此时经过改动的 200 元值一样，就进行了减法操作，把余额又变成了 100 元。这显然不是我们要的正确结果，我们想要的结果是余额减少了 100 元，又增加了 100 元，余额还是 200 元，而此时余额变成了 100 元，显然有悖常理，这就是著名的 ABA 的问题。</p><p>执行流程如下。</p><ul><li>线程一：取款，获取原值 200 元，与 200 元比对成功，减去 100 元，修改结果为 100 元。</li><li>线程二：取款，获取原值 200 元，阻塞等待修改。</li><li>线程三：转账，获取原值 100 元，与 100 元比对成功，加上 100 元，修改结果为 200 元。</li><li>线程二：取款，恢复执行，原值为 200 元，与 200 元对比成功，减去 100 元，修改结果为 100 元。</li></ul><p>最终的结果是 100 元。</p><h4 id="ABA-问题的解决"><a href="#ABA-问题的解决" class="headerlink" title="ABA 问题的解决"></a>ABA 问题的解决</h4><p>常见解决 ABA 问题的方案加版本号，来区分值是否有变动。以老王取钱的例子为例，如果加上版本号，执行流程如下。</p><ul><li>线程一：取款，获取原值 200_V1，与 200_V1 比对成功，减去 100 元，修改结果为 100_V2。</li><li>线程二：取款，获取原值 200_V1 阻塞等待修改。</li><li>线程三：转账，获取原值 100_V2，与 100_V2 对比成功，加 100 元，修改结果为 200_V3。</li><li>线程二：取款，恢复执行，原值 200_V1 与现值 200_V3 对比不相等，退出修改。</li></ul><p>最终的结果为 200 元，这显然是我们需要的结果。<br>在程序中，要怎么解决 ABA 的问题呢？<br>在 JDK 1.5 的时候，Java 提供了一个 AtomicStampedReference 原子引用变量，通过添加版本号来解决 ABA 的问题，具体使用示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">String newName = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">AtomicStampedReference&lt;String&gt; as = <span class="keyword">new</span> AtomicStampedReference&lt;String&gt;(name, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;值：&quot;</span> + as.getReference() + <span class="string">&quot; | Stamp：&quot;</span> + as.getStamp());</span><br><span class="line">as.compareAndSet(name, newName, as.getStamp(), as.getStamp() + <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;值：&quot;</span> + as.getReference() + <span class="string">&quot; | Stamp：&quot;</span> + as.getStamp());</span><br></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>值：老王 | Stamp：1</p><p>值：Java | Stamp：2</p></blockquote><h3 id="相关面试题-23"><a href="#相关面试题-23" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="synchronized-是哪种锁的实现？为什么？"><a href="#synchronized-是哪种锁的实现？为什么？" class="headerlink" title="synchronized 是哪种锁的实现？为什么？"></a>synchronized 是哪种锁的实现？为什么？</h4><p>答：synchronized 是悲观锁的实现，因为 synchronized 修饰的代码，每次执行时会进行加锁操作，同时只允许一个线程进行操作，所以它是悲观锁的实现。</p><h4 id="new-ReentrantLock-创建的是公平锁还是非公平锁？"><a href="#new-ReentrantLock-创建的是公平锁还是非公平锁？" class="headerlink" title="new ReentrantLock() 创建的是公平锁还是非公平锁？"></a>new ReentrantLock() 创建的是公平锁还是非公平锁？</h4><p>答：非公平锁，查看 ReentrantLock 的实现源码可知。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="synchronized-使用的是公平锁还是非公平锁？"><a href="#synchronized-使用的是公平锁还是非公平锁？" class="headerlink" title="synchronized 使用的是公平锁还是非公平锁？"></a>synchronized 使用的是公平锁还是非公平锁？</h4><p>答：synchronized 使用的是非公平锁，并且是不可设置的。这是因为非公平锁的吞吐量大于公平锁，并且是主流操作系统线程调度的基本选择，所以这也是 synchronized 使用非公平锁原由。</p><h4 id="为什么非公平锁吞吐量大于公平锁？"><a href="#为什么非公平锁吞吐量大于公平锁？" class="headerlink" title="为什么非公平锁吞吐量大于公平锁？"></a>为什么非公平锁吞吐量大于公平锁？</h4><p>答：比如 A 占用锁的时候，B 请求获取锁，发现被 A 占用之后，堵塞等待被唤醒，这个时候 C 同时来获取 A 占用的锁，如果是公平锁 C 后来者发现不可用之后一定排在 B 之后等待被唤醒，而非公平锁则可以让 C 先用，在 B 被唤醒之前 C 已经使用完成，从而节省了 C 等待和唤醒之间的性能消耗，这就是非公平锁比公平锁吞吐量大的原因。</p><h4 id="volatile-的作用是什么？"><a href="#volatile-的作用是什么？" class="headerlink" title="volatile 的作用是什么？"></a>volatile 的作用是什么？</h4><p>答：volatile 是 Java 虚拟机提供的最轻量级的同步机制。<br>当变量被定义成 volatile 之后，具备两种特性：</p><ul><li>保证此变量对所有线程的可见性，当一条线程修改了这个变量的值，修改的新值对于其他线程是可见的（可以立即得知的）；</li><li>禁止指令重排序优化，普通变量仅仅能保证在该方法执行过程中，得到正确结果，但是不保证程序代码的执行顺序。</li></ul><h4 id="volatile-对比-synchronized-有什么区别？"><a href="#volatile-对比-synchronized-有什么区别？" class="headerlink" title="volatile 对比 synchronized 有什么区别？"></a>volatile 对比 synchronized 有什么区别？</h4><p>答：synchronized 既能保证可见性，又能保证原子性，而 volatile 只能保证可见性，无法保证原子性。比如，i++ 如果使用 synchronized 修饰是线程安全的，而 volatile 会有线程安全的问题。</p><h4 id="CAS-是如何实现的？"><a href="#CAS-是如何实现的？" class="headerlink" title="CAS 是如何实现的？"></a>CAS 是如何实现的？</h4><p>答： CAS（Compare and Swap）比较并交换，CAS 是通过调用 JNI（Java Native Interface）的代码实现的，比如，在 Windows 系统 CAS 就是借助 C 语言来调用 CPU 底层指令实现的。</p><h4 id="CAS-会产生什么问题？应该怎么解决？"><a href="#CAS-会产生什么问题？应该怎么解决？" class="headerlink" title="CAS 会产生什么问题？应该怎么解决？"></a>CAS 会产生什么问题？应该怎么解决？</h4><p>答：CAS 是标准的乐观锁的实现，会产生 ABA 的问题（详见正文）。<br>ABA 通常的解决办法是添加版本号，每次修改操作时版本号加一，这样数据对比的时候就不会出现 ABA 的问题了。</p><h4 id="以下说法错误的是？-2"><a href="#以下说法错误的是？-2" class="headerlink" title="以下说法错误的是？"></a>以下说法错误的是？</h4><p>A：独占锁是指任何时候都只有一个线程能执行资源操作<br>B：共享锁指定是可以同时被多个线程读取和修改<br>C：公平锁是指多个线程按照申请锁的顺序来获取锁<br>D：非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁<br>答：B<br>题目解析：共享锁指定是可以同时被多个线程读取，但只能被一个线程修改。</p><h3 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了 Java 中各种锁，明白了 Java 程序中比较常用的为非公平锁而非公平锁，原因在于非公平锁的吞吐量要更大，并且发生线程“饥饿”的情况很少，是风险远小于收益的事所以可以广而用之。又重点介绍了 CAS 和著名的 ABA 的问题，以及解决 ABA 的常见手段：添加版本号，可以通过 Java 自身提供的 AtomicStampedReference（原子引用变量）来解决 ABA 的问题，至此我们对 Java 多线程的了解又向前迈了一大步。</p><h2 id="Spring-核心功能演示-面试题"><a href="#Spring-核心功能演示-面试题" class="headerlink" title="Spring 核心功能演示 + 面试题"></a>Spring 核心功能演示 + 面试题</h2><p>Spring Framework 简称 Spring，是 Java 开发中最常用的框架，地位仅次于 Java API，就连近几年比较流行的微服务框架 SpringBoot，也是基于 Spring 实现的，SpringBoot 的诞生是为了让开发者更方便地使用 Spring，因此 Spring 在 Java 体系中的地位可谓首屈一指。<br>当然，如果想要把 Spring 所有功能都讲的一清二楚，远远不是一两篇文章能够做到的，但幸运的是，Spring 的基础资料可以很轻易的搜索到，那么我们本讲主要的目的就是把 Spring 中的核心知识点和常见面试题分享给大家，希望对大家能有所帮助。</p><h3 id="Spring-介绍"><a href="#Spring-介绍" class="headerlink" title="Spring 介绍"></a>Spring 介绍</h3><p>Spring 是一个开源框架，为了解决企业应用程序开发复杂性而创建的，Spring 的概念诞生于 2002 年，于 2003 年正式发布第一个版本 Spring Framework 0.9。下面一起来看 Spring 各个版本的更新特性和它的发展变化吧。</p><h4 id="Spring-1-x"><a href="#Spring-1-x" class="headerlink" title="Spring 1.x"></a>Spring 1.x</h4><p>此版本主要是为了解决企业应用程序开发复杂性而创建的，当时 J2EE 应用的经典架构是分层架构：表现层、业务层、持久层，最流行的组合就是 SSH（Struts、Spring、Hibernate）。<br>Spring 1.x 仅支持基于 XML 的配置，确保用户代码不依赖 Spring，它主要包含了以下功能模块：aop、beans、ejb、jdbc、jndi、orm、transation、validation、web 等。</p><h4 id="Spring-2-x"><a href="#Spring-2-x" class="headerlink" title="Spring 2.x"></a>Spring 2.x</h4><p>Spring 2.x 的改动并不是很大，主要是在 Spring 1.x 的基础上增加了几个新模块，如 ehcache、jms、jmx、scripting、stereotype 等。</p><h4 id="Spring-3-x"><a href="#Spring-3-x" class="headerlink" title="Spring 3.x"></a>Spring 3.x</h4><p>Spring 3.x 开始不止支持 XML 的配置，还扩展了基于 Java 类的配置，还增加了 Expression、Instructment、Tomcat、oxm 等组件，同时将原来的 Web 细分为：Portlet、Servlet。</p><h4 id="Spring-4-x"><a href="#Spring-4-x" class="headerlink" title="Spring 4.x"></a>Spring 4.x</h4><p>Spring 4.x 扩充了 Groovy、Messaging、WebMvc、Tiles2、WebSocket 等功能组件，同时 Spring 还适配了 Java 版本，全面支持 Java 8.0、Lambda 表达式等。随着 RESTful 架构风格被越来越多的用户所采用，Spring 4.x 也提供了 RestController 等注解新特性。</p><h4 id="Spring-5-x"><a href="#Spring-5-x" class="headerlink" title="Spring 5.x"></a>Spring 5.x</h4><p>Spring 5.x 紧跟 Java 相关技术的更新迭代，不断适配 Java 的新版本，同时不断重构优化自身核心框架代码，支持函数式、响应式编程模型等。</p><h3 id="Spring-核心"><a href="#Spring-核心" class="headerlink" title="Spring 核心"></a>Spring 核心</h3><p>Spring 核心包括以下三个方面：</p><ul><li>控制反转（Ioc）</li><li>依赖注入（DI）</li><li>面向切面编程（AOP）</li></ul><p>下面分别来看它的这些特性。</p><h4 id="控制反转（IoC）"><a href="#控制反转（IoC）" class="headerlink" title="控制反转（IoC）"></a>控制反转（IoC）</h4><p>控制反转（Inversion of Control，IoC），顾名思义所谓的控制反转就是把创建对象的权利交给框架去控制，而不需要人为地去创建，这样就实现了可插拔式的接口编程，有效地降低代码的耦合度，降低了扩展和维护的成本。<br>比如，你去某地旅游不再用自己亲自为订购 A 酒店还是 B 酒店而发愁了，只需要把住店的需求告诉给某个托管平台，这个托管平台就会帮你订购一个既便宜又舒适的酒店，而这个帮你订购酒店的行为就可以称之为控制反转。</p><h4 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h4><p>依赖注入（Dependency Injection，DI），是组件之间依赖关系由容器在运行期决定，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><h5 id="IoC-和-DI-的关系"><a href="#IoC-和-DI-的关系" class="headerlink" title="IoC 和 DI 的关系"></a>IoC 和 DI 的关系</h5><p>IoC 是 Spring 中一个极为重要的概念，而 DI 则是实现 IoC 的方法和手段。<br>接下来，我们来看依赖注入的常见实现方式有哪些？<br>依赖注入的常见实现方式如下：</p><ol><li>setter 注入</li><li>构造方法注入</li><li>注解注入</li></ol><h5 id="setter-注入"><a href="#setter-注入" class="headerlink" title="setter 注入"></a>setter 注入</h5><p>Java 代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注入 UserService 对象</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserService</span><span class="params">(UserService userService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML 配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;userController&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.learning.controller.UserController&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 依赖注入 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.learning.dao.impl.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Bean 标签的常用属性说明：</strong></p><ul><li>id：为实例化对象起名称，根据 id 值可以得到我们配置的实例化对象，id 属性的名称原则上可以任意命名，但是能包含任何特殊符号；</li><li>class：创建对象所在类的全路径；</li><li>name：功能和 id 属性一样，但是现在一般不用；与 id 的区别在于：name 属性值里可以包含特殊符号，但是 id 不可以；</li><li>scope：一般最常用的有两个值： Singleton：单例模式，整个应用程序，只创建 bean 的一个实例；Prototype：原型模式，每次注入都会创建一个新的 bean 实例，Spring 默认的是单例模式。</li></ul><h5 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a>构造方法注入</h5><p>Java 代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserController</span><span class="params">(UserService userService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML 配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;userController&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.learning.controller.UserController&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 依赖注入 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;userService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.learning.dao.impl.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br></pre></td></tr></table></figure><h5 id="注解注入"><a href="#注解注入" class="headerlink" title="注解注入"></a>注解注入</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用注解自动注入</span></span><br><span class="line">    <span class="meta">@Autowired()</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建依赖对象</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">   <span class="comment">// do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建依赖对象的常见注解：@Component、@Controller、@Service、@Repository。</p><p><strong>总结</strong>：可以看出注解的方式要比传统的 XML（setter 和构造器注入）实现注入更为方便，同时注解方式也是官方力推的依赖注入最佳使用方式。</p><h4 id="面向切面编程（AOP）"><a href="#面向切面编程（AOP）" class="headerlink" title="面向切面编程（AOP）"></a>面向切面编程（AOP）</h4><p>面向切面编程（Aspect Oriented Programming，AOP），它就好比将系统按照功能分类，每一个类别就是一个“切面”，我们再针对不同的切面制定相应的规则，类似开发模式被称为面向切面编程。</p><h5 id="AOP-使用场景"><a href="#AOP-使用场景" class="headerlink" title="AOP 使用场景"></a>AOP 使用场景</h5><ul><li>日志系统</li><li>安全统一效验</li></ul><h5 id="AOP-优点"><a href="#AOP-优点" class="headerlink" title="AOP 优点"></a>AOP 优点</h5><ul><li>集中处理某一类问题，方便维护</li><li>逻辑更加清晰</li><li>降低模块间的耦合度</li></ul><h5 id="AOP-相关概念"><a href="#AOP-相关概念" class="headerlink" title="AOP 相关概念"></a>AOP 相关概念</h5><ul><li>Join point：连接点，程序执行期间的某一个点，例如执行方法或处理异常时候的点，在 Spring AOP 中，连接点总是表示方法的执行。</li><li>Advice：通知，通知分为方法执行前通知，方法执行后通知、环绕通知等。许多 AOP 框架（包括 Spring）都将通知建模为拦截器，在连接点周围维护一系列拦截器（形成拦截器链），对连接点的方法进行增强。</li><li>Pointcut：切点，匹配连接点（Join point）的表达式，是 AOP 的核心，并且 Spring 默认使用 AspectJ 作为切入点表达式语言。</li><li>Aspect：切面，是一个跨越多个类的模块化的关注点，它是通知（Advice）和切点（Pointcut）合起来的抽象，它定义了一个切点（Pointcut）用来匹配连接点（Join point），也就是需要对需要拦截的那些方法进行定义。</li><li>Target object：目标对象，被一个或者多个切面（Aspect）通知的对象，也就是需要被 AOP 进行拦截对方法进行增强（使用通知）的对象，也称为被通知的对象。由于在 AOP 里面使用运行时代理，因而目标对象一直是被代理的对象。</li><li>AOP proxy：AOP 代理，为了实现切面（Aspect）功能使用 AOP 框架创建一个对象，在 Spring 框架里面一个 AOP 代理指的是 JDK 自身的动态代理或 CGLIB 实现的动态代理。</li><li>Weaving：把切面加入到对象，并创建出代理对象的过程。</li><li>Advisor：一个 Advisor 相当于一个小型的切面，不同的是它只有一个通知（Advice），Advisor 在事务管理里面会经常遇到。</li></ul><h5 id="AOP-代码实现"><a href="#AOP-代码实现" class="headerlink" title="AOP 代码实现"></a>AOP 代码实现</h5><p>AOP 的示例我们就以开车为例，开车的完成流程是这样的：巡视车体及周围情况 → 发动 → 开车 → 熄火 → 锁车。</p><p>当然我们的主要目的是“开车”，但在开车之前和开完车之后，我们要做一些其他的工作，这些“其他”的工作，可以理解为 AOP 编程。</p><h5 id="创建类和方法"><a href="#创建类和方法" class="headerlink" title="创建类和方法"></a>创建类和方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learning.aop;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建-AOP-拦截"><a href="#创建-AOP-拦截" class="headerlink" title="创建 AOP 拦截"></a>创建 AOP 拦截</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learning.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarAop</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.learning.aop.Person.drive())&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;巡视车体及周围情况&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;发动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.learning.aop.Person.drive())&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;熄火&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;锁车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="XML-配置注入扫描包路径"><a href="#XML-配置注入扫描包路径" class="headerlink" title="XML 配置注入扫描包路径"></a>XML 配置注入扫描包路径</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.learning&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="创建测试类"><a href="#创建测试类" class="headerlink" title="创建测试类"></a>创建测试类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learning.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        Person landlord = context.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">        landlord.drive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试代码，执行结果如下：</p><blockquote><p>巡视车体及周围情况</p><p>发动</p><p>开车</p><p>熄火</p><p>锁车</p></blockquote><h5 id="AspectJ-注解说明："><a href="#AspectJ-注解说明：" class="headerlink" title="AspectJ 注解说明："></a>AspectJ 注解说明：</h5><ul><li>@Before — 前置通知，在连接点方法前调用；</li><li>@Around — 环绕通知，它将覆盖原有方法，但是允许你通过反射调用原有方法；</li><li>@After — 后置通知，在连接点方法后调用；</li><li>@AfterReturning — 返回通知，在连接点方法执行并正常返回后调用，要求连接点方法在执行过程中没有发生异常；</li><li>@AfterThrowing — 异常通知，当连接点方法异常时调用。</li></ul><h3 id="相关面试题-24"><a href="#相关面试题-24" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="Value-注解的作用是什么？"><a href="#Value-注解的作用是什么？" class="headerlink" title="@Value 注解的作用是什么？"></a>@Value 注解的作用是什么？</h4><p>答：基于 @Value 的注解可以读取 properties 配置文件，使用如下:</p><blockquote><p>@Value(“#{configProperties[‘jdbc.username’]}”)</p><p>private String userName;</p></blockquote><p>以上为读取 configProperties 下的 jdbc.username 配置。</p><h4 id="Spring-通知类型有哪些？"><a href="#Spring-通知类型有哪些？" class="headerlink" title="Spring 通知类型有哪些？"></a>Spring 通知类型有哪些？</h4><p>答：Spring 通知类型总共有 5 种：前置通知、环绕通知、后置通知、异常通知、最终通知。</p><ul><li>前置通知（Before advice）：在目标方法执行之前执行的通知。在某连接点（ join point ）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</li><li>环绕通知（Around Advice）：在目标方法执行之前和之后都可以执行额外代码的通知，也可以选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。</li><li>后置通知（After (finally) advice）：目标方法执行之后（某连接点退出的时候）执行的通知（不论是正常返回还是异常退出）。</li><li>异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。</li><li>最终通知（After returning advice）：在某连接点（join point）正常完成后执行的通知，例如，一个方法没有抛出任何异常，正常返回。</li></ul><h4 id="怎么理解-Spring-中的-IOC-容器？"><a href="#怎么理解-Spring-中的-IOC-容器？" class="headerlink" title="怎么理解 Spring 中的 IOC 容器？"></a>怎么理解 Spring 中的 IOC 容器？</h4><p>答：Spring IOC 就是把创建对象的权利交给框架去控制，而不需要人为的去创建，这样就实现了可插拔式的接口编程，有效地降低代码的耦合度，降低了扩展和维护的成本。</p><p>比如，去某地旅游不再用自己亲自为订购 A 酒店还是 B 酒店而发愁了，只需要把住店的需求告诉给某个托管平台，这个托管平台就会帮你订购一个既便宜又舒适的酒店，而这个帮你订购酒店的行为就可以称之为控制反转。</p><h4 id="怎么理解-Spring-中的依赖注入？"><a href="#怎么理解-Spring-中的依赖注入？" class="headerlink" title="怎么理解 Spring 中的依赖注入？"></a>怎么理解 Spring 中的依赖注入？</h4><p>答：依赖注入是指组件之间的依赖关系由容器在运行期决定，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><h4 id="IoC-和-DI-有什么关系？"><a href="#IoC-和-DI-有什么关系？" class="headerlink" title="IoC 和 DI 有什么关系？"></a>IoC 和 DI 有什么关系？</h4><p>答：IoC 是 Spring 中一个极为重要的概念，提供了对象管理的功能，从而省去了人为创建麻烦，而 DI 正是实现 IoC 的方法和手段。</p><h4 id="Component-和-Bean-有什么区别？"><a href="#Component-和-Bean-有什么区别？" class="headerlink" title="@Component 和 @Bean 有什么区别？"></a>@Component 和 @Bean 有什么区别？</h4><p>答：它们的作用对象不同：@Component 作用于类，而 @Bean 注解作用于方法。</p><p>@Component 通常是通过类路径扫描来自动侦测和装配对象到 Spring 容器中，比如 @ComponentScan 注解就是定义扫描路径中的类装配到 Spring 的 Bean 容器中；@Bean 注解是告诉 Spring 这是某个类的实例，当我需要用它的时把它给我，@Bean 注解比 @Component 注解自定义性更强，很多地方我们只能通过 @Bean 注解来注册 Bean，比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean 来实现，比如以下示例，只能通过 @Bean 注解来实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WireThirdLibClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThirdLibClass <span class="title">getThirdLibClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThirdLibClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spring-中-bean-的作用域有几种类型？"><a href="#Spring-中-bean-的作用域有几种类型？" class="headerlink" title="Spring 中 bean 的作用域有几种类型？"></a>Spring 中 bean 的作用域有几种类型？</h4><p>答：Spring 中 bean 的作用域有四种类型，如下列表：</p><ul><li>单例（Singleton）：整个应用程序，只创建 bean 的一个实例；</li><li>原型（Prototype）：每次注入都会创建一个新的 bean 实例；</li><li>会话（Session）：每个会话创建一个 bean 实例，只在 Web 系统中有效；</li><li>请求（Request）：每个请求创建一个 bean 实例，只在 Web 系统中有效。</li></ul><p>Spring 默认的是单例模式。</p><h4 id="什么是-Spring-的内部-bean？"><a href="#什么是-Spring-的内部-bean？" class="headerlink" title="什么是 Spring 的内部 bean？"></a>什么是 Spring 的内部 bean？</h4><p>答：当一个 bean 仅被用作另一个 bean 的属性时，它能被声明为一个内部 bean，为了定义 inner Bean，在 Spring 的基于 XML 的配置元数据中，可以在 <code>&lt;property/&gt;</code> 或 <code>&lt;constructor-arg/&gt;</code> 元素内使用 <code>&lt;bean/&gt;</code> 元素，内部 bean 通常是匿名的，它们的 Scope 一般是 prototype。</p><h4 id="Spring-注入方式有哪些？"><a href="#Spring-注入方式有哪些？" class="headerlink" title="Spring 注入方式有哪些？"></a>Spring 注入方式有哪些？</h4><p>答：Spring 的注入方式包含以下五种：</p><ul><li>setter 注入</li><li>构造方法注入</li><li>注解注入</li><li>静态工厂注入</li><li>实例工厂注入</li></ul><p>其中最常用的是前三种，官方推荐使用的是注解注入，相对使用更简单，维护成本更低，更直观。</p><h4 id="在-Spring-中如何操作数据库？"><a href="#在-Spring-中如何操作数据库？" class="headerlink" title="在 Spring 中如何操作数据库？"></a>在 Spring 中如何操作数据库？</h4><p>答：在 Spring 中操作数据库，可以使用 Spring 提供的 JdbcTemplate 对象，JdbcTemplate 类提供了很多便利的方法，比如把数据库数据转变成基本数据类型或对象，执行自定义的 SQL 语句，提供了自定义的数据错误处理等，JdbcTemplate 使用示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"><span class="comment">// 新增</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;save&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;INSERT INTO USER (USER_NAME,PASS_WORD) VALUES (&#x27;laowang&#x27;,&#x27;123&#x27;)&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> rows = jdbcTemplate.update(sql);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;执行成功，影响&quot;</span> + rows + <span class="string">&quot;行&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;del&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">del</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows= jdbcTemplate.update(<span class="string">&quot;DELETE FROM  USER  WHERE ID = ?&quot;</span>,id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;执行成功，影响&quot;</span> + rows + <span class="string">&quot;行&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;getMapById&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map <span class="title">getMapById</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;SELECT * FROM USER WHERE ID = ?&quot;</span>;</span><br><span class="line">    Map map= jdbcTemplate.queryForMap(sql,id);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spring-的-JdbcTemplate-对象和-JDBC-有什么区别？"><a href="#Spring-的-JdbcTemplate-对象和-JDBC-有什么区别？" class="headerlink" title="Spring 的 JdbcTemplate 对象和 JDBC 有什么区别？"></a>Spring 的 JdbcTemplate 对象和 JDBC 有什么区别？</h4><p>答：Spring 的 JdbcTemplate 是对 JDBC API 的封装，提供更多的功能和更便利的操作，比如 JdbcTemplate 拥有：</p><ul><li>JdbcTemplate 是线程安全的；</li><li>实例化操作比较简单，仅需要传递 DataSource；</li><li>自动完成资源的创建和释放工作；</li><li>创建一次 JdbcTemplate，到处可用，避免重复开发。</li></ul><h4 id="Spring-有几种实现事务的方式？"><a href="#Spring-有几种实现事务的方式？" class="headerlink" title="Spring 有几种实现事务的方式？"></a>Spring 有几种实现事务的方式？</h4><p>答：Spring 实现事务有两种方式：编程式事务和声明式事务。<br>编程式事务，使用 TransactionTemplate 或 PlatformTransactionManager 实现，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// Spring编码式事务，回调机制</span></span><br><span class="line">    transactionTemplate.execute(<span class="keyword">new</span> TransactionCallback&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doInTransaction</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                userMapper.insertSelective(user);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 异常，设置为回滚</span></span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有异常，调用 status.setRollbackOnly() 回滚事务，否则正常执行 doInTransaction() 方法，正常提交事务。<br>如果事务控制的方法不需要返回值，就可以使用 TransactionCallbackWithoutResult（TransactionCallback 接口的抽象实现类）示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Spring编码式事务，回调机制</span></span><br><span class="line">    transactionTemplate.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                userMapper.insertSelective(user);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 异常，设置为回滚</span></span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明式事务，底层是建立在 Spring AOP 的基础上，在方式执行前后进行拦截，并在目标方法开始执行前创建新事务或加入一个已存在事务，最后在目标方法执行完后根据情况提交或者回滚事务。<br>声明式事务的优点：不需要编程，减少了代码的耦合，在配置文件中配置并在目标方法上添加 @Transactional 注解来实现，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">&quot;laowang&quot;</span>);</span><br><span class="line">    userMapper.insertSelective(user);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抛出异常，事务会自动回滚，如果方法正常执行，则会自动提交事务。</p><h4 id="Spring-事务隔离级别有哪些？"><a href="#Spring-事务隔离级别有哪些？" class="headerlink" title="Spring 事务隔离级别有哪些？"></a>Spring 事务隔离级别有哪些？</h4><p>答：Spring 的注入方式包含以下五种：</p><ul><li>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</li><li>ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</li><li>ISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</li><li>ISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</li><li>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li></ul><p>默认值为 ISOLATION_DEFAULT 遵循数据库的事务隔离级别设置。</p><h4 id="Spring-声明式事务无效可能的原因有哪些？"><a href="#Spring-声明式事务无效可能的原因有哪些？" class="headerlink" title="Spring 声明式事务无效可能的原因有哪些？"></a>Spring 声明式事务无效可能的原因有哪些？</h4><p>答：可能的原因如下：</p><ul><li>MySQL 使用的是 MyISAM 引擎，而 MyISAM 是不支持事务的；</li><li>@Transactional 使用在非 public 方法上，@Transactional 注解只能支持 public 级别，其他类型声明的事务不会生效；</li><li>@Transactional 在同一个类中无事务方法 A() 内部调用有事务方法 B()，那么此时 B() 事物不会生效。Spring 中的 AOP 的底层实现原理是什么？</li></ul><p>答：Spring AOP 的底层实现原理就是动态代理。Spring AOP 的动态代理有两种实现方式，对于接口使用的是 JDK 自带的动态代理来实现的，而对比非接口使用的是 CGLib 来实现的，关于动态代理的详细内容，可参考前面【反射和动态代理】的那篇文章。</p><h4 id="Spring-中的-Bean-是线程安全的吗？"><a href="#Spring-中的-Bean-是线程安全的吗？" class="headerlink" title="Spring 中的 Bean 是线程安全的吗？"></a>Spring 中的 Bean 是线程安全的吗？</h4><p>答：Spring 中的 Bean 默认是单例模式，Spring 框架并没有对单例 Bean 进行多线程的封装处理，因此默认的情况 Bean 并非是安全的，最简单保证 Bean 安全的举措就是设置 Bean 的作用域为 Prototype（原型）模式，这样每次请求都会新建一个 Bean。</p><h4 id="说一下-Spring-中-Bean-的生命周期？"><a href="#说一下-Spring-中-Bean-的生命周期？" class="headerlink" title="说一下 Spring 中 Bean 的生命周期？"></a>说一下 Spring 中 Bean 的生命周期？</h4><p>答：Spring 中 Bean 的生命周期如下：</p><ul><li>① 实例化 Bean：对于 BeanFactory 容器，当客户向容器请求一个尚未初始化的 Bean 时，或初始化 Bean 的时候需要注入另一个尚未初始化的依赖时，容器就会调用 createBean 进行实例化。对于 ApplicationContext 容器，当容器启动结束后，通过获取 BeanDefinition 对象中的信息，实例化所有的 Bean；</li><li>② 设置对象属性（依赖注入）：实例化后的对象被封装在 BeanWrapper 对象中，紧接着 Spring 根据 BeanDefinition 中的信息以及通过 BeanWrapper 提供的设置属性的接口完成依赖注入；</li><li>③ 处理 Aware 接口：Spring 会检测该对象是否实现了 xxxAware 接口，并将相关的 xxxAware 实例注入给 Bean：</li><li>如果这个 Bean 已经实现了 BeanNameAware 接口，会调用它实现的 setBeanName(String BeanId) 方法，此处传递的就是 Spring 配置文件中 Bean 的 id 值；</li><li>如果这个 Bean 已经实现了 BeanFactoryAware 接口，会调用它实现的 setBeanFactory() 方法，传递的是 Spring 工厂自身；</li><li>如果这个 Bean 已经实现了 ApplicationContextAware 接口，会调用 setApplicationContext(ApplicationContext) 方法，传入 Spring 上下文；</li><li>④ BeanPostProcessor：如果想对 Bean 进行一些自定义的处理，那么可以让 Bean 实现了 BeanPostProcessor 接口，那将会调用 postProcessBeforeInitialization(Object obj, String s) 方法；</li><li>⑤ InitializingBean 与 init-method：如果 Bean 在 Spring 配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法；</li><li>⑥ 如果这个 Bean 实现了 BeanPostProcessor 接口，将会调用 postProcessAfterInitialization(Object obj, String s) 方法；由于这个方法是在 Bean 初始化结束时调用的，因而可以被应用于内存或缓存技术；</li></ul><p>以上几个步骤完成后，Bean 就已经被正确创建了，之后就可以使用这个 Bean 了。</p><ul><li>⑦ DisposableBean：当 Bean 不再需要时，会经过清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调用其实现的 destroy() 方法；</li><li>⑧ destroy-method：最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的销毁方法。</li></ul><h4 id="Spring-有哪些优点"><a href="#Spring-有哪些优点" class="headerlink" title="Spring 有哪些优点?"></a>Spring 有哪些优点?</h4><p>答：Spring 优点如下：</p><ul><li>开源免费的热门框架，稳定性高、解决问题成本低；</li><li>方便集成各种优秀的框架；</li><li>降低了代码耦合性，通过 Spring 提供的 IoC 容器，我们可以将对象之间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度程序耦合；</li><li>方便程序测试，在 Spring 里，测试变得非常简单，例如：Spring 对 Junit 的支持，可以通过注解方便的测试 Spring 程序；</li><li>降低 Java EE API 的使用难度，Spring 对很多难用的 Java EE API（如 JDBC、JavaMail、远程调用等）提供了一层封装，通过 Spring 的简易封装，让这些 Java EE API 的使用难度大为降低。</li></ul><h4 id="Spring-和-Struts-的区别？"><a href="#Spring-和-Struts-的区别？" class="headerlink" title="Spring 和 Struts 的区别？"></a>Spring 和 Struts 的区别？</h4><p>答：Spring 和 Struts 区别如下：<br>Spring 特性如下：</p><ul><li>具备 IOC/DI、AOP 等通用能力，提高研发效率</li><li>除了支持 Web 层建设以外，还提供了 J2EE 整体服务</li><li>方便与其他不同技术结合使用，如 Hibernate、MyBatis 等</li><li>Spring 拦截机制是方法级别</li></ul><p>Struts 特性如下：</p><ul><li>是一个基于 MVC 模式的一个 Web 层的处理</li><li>Struts 拦截机制是类级别</li></ul><h4 id="Spring、SpringBoot、SpringCloud-的区别是什么？"><a href="#Spring、SpringBoot、SpringCloud-的区别是什么？" class="headerlink" title="Spring、SpringBoot、SpringCloud 的区别是什么？"></a>Spring、SpringBoot、SpringCloud 的区别是什么？</h4><p>答：它们的区别如下：</p><ul><li>Spring Framework 简称 Spring，是整个 Spring 生态的基础。</li><li>Spring Boot 是一个快速开发框架，让开发者可以迅速搭建一套基于 Spring 的应用程序，并且将常用的 Spring 模块以及第三方模块，如 MyBatis、Hibernate 等都做了很好的集成，只需要简单的配置即可使用，不需要任何的 XML 配置文件，真正做到了开箱即用，同时默认支持 JSON 格式的数据，使用 Spring Boot 进行前后端分离开发也非常便捷。</li><li>Spring Cloud 是一套整合了分布式应用常用模块的框架，使得开发者可以快速实现微服务应用。作为目前非常热门的技术，有关微服务的话题总是在各种场景下被大家讨论，企业的招聘信息中也越来越多地出现对于微服务架构能力的要求。</li></ul><h4 id="Spring-中都是用了哪些设计模式？"><a href="#Spring-中都是用了哪些设计模式？" class="headerlink" title="Spring 中都是用了哪些设计模式？"></a>Spring 中都是用了哪些设计模式？</h4><p>答：Spring 中使用的设计模式如下：</p><ul><li>工厂模式：通过 BeanFactory、ApplicationContext 来创建 bean 都是属于工厂模式；</li><li>单例、原型模式：创建 bean 对象设置作用域时，就可以声明 Singleton（单例模式）、Prototype（原型模式）；</li><li>察者模式：Spring 可以定义一下监听，如 ApplicationListener 当某个动作触发时就会发出通知；</li><li>责任链模式：AOP 拦截器的执行；</li><li>策略模式：在创建代理类时，如果代理的是接口使用的是 JDK 自身的动态代理，如果不是接口使用的是 CGLIB 实现动态代理。</li></ul><h3 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h3><p>通过本节内容我们充分的了解了 Spring 的核心：IoC、DI、AOP，也是用代码演示了 Spring 核心功能的示例，其中可以发现的是 Spring 正在从之前的 XML 配置编程变为 Java 注解编程，注解编程让 Spring 更加轻量化简单化了，这一点在我们后面介绍 SpringBoot 的时候，会让你更加感同身受。对于开发者来说，只有真正掌握了 Spring，才能称得上是一名合格的 Java 工程师。当然，学习的目的是为了更好的应用，因此现在就一起动手实践起来吧。</p><h2 id="Spring-MVC-核心组件-面试题"><a href="#Spring-MVC-核心组件-面试题" class="headerlink" title="Spring MVC 核心组件 + 面试题"></a>Spring MVC 核心组件 + 面试题</h2><h3 id="Spring-MVC-介绍"><a href="#Spring-MVC-介绍" class="headerlink" title="Spring MVC 介绍"></a>Spring MVC 介绍</h3><p>Spring MVC（Spring Web MVC）是 Spring Framework 提供的 Web 组件，它的实现基于 MVC 的设计模式：Controller（控制层）、Model（模型层）、View（视图层），提供了前端路由映射、视图解析等功能，让 Java Web 开发变得更加简单，也属于 Java 开发中必须要掌握的热门框架。</p><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>Spring MVC 的执行流程如下：</p><ol><li>客户端发送请求至前端控制器（DispatcherServlet）</li><li>前端控制器根据请求路径，进入对应的处理器</li><li>处理器调用相应的业务方法</li><li>处理器获取到相应的业务数据</li><li>处理器把组装好的数据交还给前端控制器</li><li>前端控制器将获取的 ModelAndView 对象传给视图解析器（ViewResolver）</li><li>前端控制器获取到解析好的页面数据</li><li>前端控制器将解析好的页面返回给客户端</li></ol><p>流程如下图所示：</p><p><img src="/" alt="1" class="lazyload" data-src="https://images.gitbook.cn/b12460c0-d9da-11e9-970d-b51140896651"></p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><p>Spring MVC 的核心组件如下列表所示：</p><ol><li><strong>DispatcherServlet</strong>：核心处理器（也叫前端控制器），负责调度其他组件的执行，可降低不同组件之间的耦合性，是整个 Spring MVC 的核心模块。</li><li><strong>Handler</strong>：处理器，完成具体业务逻辑，相当于 Servlet 或 Action。</li><li><strong>HandlerMapping</strong>：DispatcherServlet 是通过 HandlerMapping 将请求映射到不同的 Handler。</li><li><strong>HandlerInterceptor</strong>：处理器拦截器，是一个接口，如果我们需要做一些拦截处理，可以来实现这个接口。</li><li><strong>HandlerExecutionChain</strong>：处理器执行链，包括两部分内容，即 Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外拦截处理，可以添加拦截器设置）。</li><li><strong>HandlerAdapter</strong>：处理器适配器，Handler 执行业务方法之前，需要进行一系列的操作包括表单数据的验证、数据类型的转换、将表单数据封装到 POJO 等，这一系列的操作，都是由 HandlerAdapter 来完成，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。</li><li><strong>ModelAndView</strong>：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。</li><li><strong>ViewResolver</strong>：视图解析器，DispatcherServlet 通过它将逻辑视图解析成物理视图，最终将渲染结果响应给客户端。</li></ol><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>自动类型转换指的是，Spring MVC 可以将表单中的字段，自动映射到实体类的对应属性上，请参考以下示例。</p><h4 id="JSP-页面代码"><a href="#JSP-页面代码" class="headerlink" title="JSP 页面代码"></a>JSP 页面代码</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> <span class="attr">language</span>=<span class="string">&quot;java&quot;</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;add&quot;</span>&gt;</span></span><br><span class="line">    名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot; 提交 &quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="编写实体类"><a href="#编写实体类" class="headerlink" title="编写实体类"></a>编写实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写控制器"><a href="#编写控制器" class="headerlink" title="编写控制器"></a>编写控制器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/add&quot;, produces = &quot;text/plain;charset=utf-8&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(PersonVO person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.getName() + <span class="string">&quot;:&quot;</span> + person.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p>执行结果如下图所示：</p><p><img src="/" alt="2" class="lazyload" data-src="https://images.gitbook.cn/dd1a0a40-d9da-11e9-970d-b51140896651"></p><h4 id="中文乱码处理"><a href="#中文乱码处理" class="headerlink" title="中文乱码处理"></a>中文乱码处理</h4><p>业务的操作过程中可能会出现中文乱码的情况，以下是处理中文乱码的解决方案。<br>第一步，在 web.xml 添加编码过滤器，配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步，设置 RequestMapping 的 produces 属性，指定返回值类型和编码，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value  = &quot;/add&quot;, produces = &quot;text/plain;charset=utf-8&quot;)</span></span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>在 Spring MVC 中可以通过配置和实现 HandlerInterceptor 接口，来实现自己的拦截器。</p><h4 id="配置全局拦截器"><a href="#配置全局拦截器" class="headerlink" title="配置全局拦截器"></a>配置全局拦截器</h4><p>在 Spring MVC 的配置文件中，添加如下配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.learning.core.MyInteceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="添加拦截器实现代码"><a href="#添加拦截器实现代码" class="headerlink" title="添加拦截器实现代码"></a>添加拦截器实现代码</h4><p>拦截器的实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截器</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInteceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在业务处理器处理请求之前被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在业务处理器处理请求完成之后，生成视图之前执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在 DispatcherServlet 完全处理完请求之后被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数验证"><a href="#参数验证" class="headerlink" title="参数验证"></a>参数验证</h3><h4 id="pom-xml-添加验证依赖包"><a href="#pom-xml-添加验证依赖包" class="headerlink" title="pom.xml 添加验证依赖包"></a>pom.xml 添加验证依赖包</h4><p>配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Hibernate 参数验证包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.17.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="开启注解验证"><a href="#开启注解验证" class="headerlink" title="开启注解验证"></a>开启注解验证</h4><p>在 Spring MVC 的配置文件中，添加如下配置信息：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="编写控制器-1"><a href="#编写控制器-1" class="headerlink" title="编写控制器"></a>编写控制器</h4><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.JsonObject;</span><br><span class="line"><span class="keyword">import</span> com.learning.pojo.PersonDTO;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.BindingResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.ObjectError;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.annotation.Validated;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/check&quot;, produces = &quot;text/plain;charset=utf-8&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">check</span><span class="params">(<span class="meta">@Validated</span> PersonDTO person, BindingResult bindResult)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要 import com.google.gson.Gson</span></span><br><span class="line">        JsonObject result = <span class="keyword">new</span> JsonObject();</span><br><span class="line">        StringBuilder errmsg = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (bindResult.hasErrors()) &#123;</span><br><span class="line">            List&lt;ObjectError&gt; errors = bindResult.getAllErrors();</span><br><span class="line">            <span class="keyword">for</span> (ObjectError error : errors) &#123;</span><br><span class="line">                errmsg.append(error.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            result.addProperty(<span class="string">&quot;status&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.addProperty(<span class="string">&quot;status&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result.addProperty(<span class="string">&quot;errmsg&quot;</span>, errmsg.toString());</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写实体类-1"><a href="#编写实体类-1" class="headerlink" title="编写实体类"></a>编写实体类</h4><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.constraints.Min;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDTO</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;姓名不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Min(value = 18,message = &quot;年龄不能低于18岁&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多验证注解，如下所示：</p><table><thead><tr><th align="left">注解</th><th align="left">运行时检查</th></tr></thead><tbody><tr><td align="left">@AssertFalse</td><td align="left">被注解的元素必须为 false</td></tr><tr><td align="left">@AssertTrue</td><td align="left">被注解的元素必须为 true</td></tr><tr><td align="left">@DecimalMax(value)</td><td align="left">被注解的元素必须为一个数字，其值必须小于等于指定的最大值</td></tr><tr><td align="left">@DecimalMin(Value)</td><td align="left">被注解的元素必须为一个数字，其值必须大于等于指定的最小值</td></tr><tr><td align="left">@Digits(integer=, fraction=)</td><td align="left">被注解的元素必须为一个数字，其值必须在可接受的范围内</td></tr><tr><td align="left">@Future</td><td align="left">被注解的元素必须是日期，检查给定的日期是否比现在晚</td></tr><tr><td align="left">@Max(value)</td><td align="left">被注解的元素必须为一个数字，其值必须小于等于指定的最大值</td></tr><tr><td align="left">@Min(value)</td><td align="left">被注解的元素必须为一个数字，其值必须大于等于指定的最小值</td></tr><tr><td align="left">@NotNull</td><td align="left">被注解的元素必须不为 null</td></tr><tr><td align="left">@Null</td><td align="left">被注解的元素必须为 null</td></tr><tr><td align="left">@Past(java.util.Date/Calendar)</td><td align="left">被注解的元素必须过去的日期，检查标注对象中的值表示的日期比当前早</td></tr><tr><td align="left">@Pattern(regex=, flag=)</td><td align="left">被注解的元素必须符合正则表达式，检查该字符串是否能够在 match 指定的情况下被 regex 定义的正则表达式匹配</td></tr><tr><td align="left">@Size(min=, max=)</td><td align="left">被注解的元素必须在制定的范围（数据类型：String、Collection、Map、Array）</td></tr><tr><td align="left">@Valid</td><td align="left">递归的对关联对象进行校验, 如果关联对象是个集合或者数组，那么对其中的元素进行递归校验，如果是一个 map，则对其中的值部分进行校验</td></tr><tr><td align="left">@CreditCardNumber</td><td align="left">对信用卡号进行一个大致的验证</td></tr><tr><td align="left">@Email</td><td align="left">被注释的元素必须是电子邮箱地址</td></tr><tr><td align="left">@Length(min=, max=)</td><td align="left">被注解的对象必须是字符串的大小必须在制定的范围内</td></tr><tr><td align="left">@NotBlank</td><td align="left">被注解的对象必须为字符串，不能为空，检查时会将空格忽略</td></tr><tr><td align="left">@NotEmpty</td><td align="left">被注释的对象必须不为空（数据：String、Collection、Map、Array）</td></tr><tr><td align="left">@Range(min=, max=)</td><td align="left">被注释的元素必须在合适的范围内（数据：BigDecimal、BigInteger、String、byte、short、int、long 和原始类型的包装类）</td></tr><tr><td align="left">@URL(protocol=, host=, port=, regexp=, flags=)</td><td align="left">被注解的对象必须是字符串，检查是否是一个有效的 URL，如果提供了 protocol、host 等，则该 URL 还需满足提供的条件</td></tr></tbody></table><h4 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h4><p>执行结果，如下图所示：</p><p><img src="/" alt="3" class="lazyload" data-src="https://images.gitbook.cn/f5b5c8a0-d9da-11e9-970d-b51140896651"></p><p>访问 Spring MVC 官方说明文档：<a href="http://1t.click/H7a">http://1t.click/H7a</a></p><h3 id="相关面试题-25"><a href="#相关面试题-25" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="简述一下-Spring-MVC-的执行流程？"><a href="#简述一下-Spring-MVC-的执行流程？" class="headerlink" title="简述一下 Spring MVC 的执行流程？"></a>简述一下 Spring MVC 的执行流程？</h4><p>答：前端控制器（DispatcherServlet） 接收请求，通过映射从 IoC 容器中获取对应的 Controller 对象和 Method 方法，在方法中进行业务逻辑处理组装数据，组装完数据把数据发给视图解析器，视图解析器根据数据和页面信息生成最终的页面，然后再返回给客户端。</p><h4 id="POJO-和-JavaBean-有什么区别？"><a href="#POJO-和-JavaBean-有什么区别？" class="headerlink" title="POJO 和 JavaBean 有什么区别？"></a>POJO 和 JavaBean 有什么区别？</h4><p>答：POJO 和 JavaBean 的区别如下：</p><ul><li>POJO（Plain Ordinary Java Object）普通 Java 类，具有 getter/setter 方法的普通类都就可以称作 POJO，它是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。</li><li>JavaBean 是 Java 语言中的一种可重用组件，JavaBean 的构造函数和行为必须符合特定的约定：这个类必须有一个公共的缺省构造函数；这个类的属性使用 getter/setter 来访问，其他方法遵从标准命名规范；这个类应是可序列化的。</li></ul><p>简而言之，当一个 POJO 可序列化，有一个无参的构造函数，它就是一个 JavaBean。</p><h4 id="如何实现跨域访问？"><a href="#如何实现跨域访问？" class="headerlink" title="如何实现跨域访问？"></a>如何实现跨域访问？</h4><p>答：常见的跨域的实现方式有两种：使用 JSONP 或者在服务器端设置运行跨域。服务器运行跨域的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">corsConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 设置允许跨域的请求规则</span></span><br><span class="line">                registry.addMapping(<span class="string">&quot;/api/**&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="以下代码描述正确的是？"><a href="#以下代码描述正确的是？" class="headerlink" title="以下代码描述正确的是？"></a>以下代码描述正确的是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/list&quot;,params=&#123;&quot;age=10&quot;&#125;</span></span><br><span class="line"><span class="meta">public String list()&#123;</span></span><br><span class="line"><span class="meta">   // do something</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>A：age 参数不传递的时候，默认值是 10<br>B：age 参数可以为空<br>C：age 参数不能为空<br>D：以上都不对</p><p>答：C<br>题目解析：params={“age=10”} 表示必须包含 age 参数，且值必须等于 10。</p><h4 id="RequestMapping-注解的常用属性有哪些？"><a href="#RequestMapping-注解的常用属性有哪些？" class="headerlink" title="@RequestMapping 注解的常用属性有哪些？"></a>@RequestMapping 注解的常用属性有哪些？</h4><p>答：@RequestMapping 常用属性如下：</p><ul><li>value：指定 URL 请求的实际地址，用法：@RequestMapping(value=”/index”)；</li><li>method：指定请求的 method 类型，如 GET/POST/PUT/DELETE 等，用法：@RequestMapping(value=”/list”,method=RequestMethod.POST)；</li><li>params：指定请求参数中必须包含的参数名称，如果不存在该名称，则无法调用此方法，用法：@RequestMapping(value=”/list”,params={“name”,”age”})。</li></ul><h4 id="访问以下接口不传递任何参数的情况下，执行的结果是？"><a href="#访问以下接口不传递任何参数的情况下，执行的结果是？" class="headerlink" title="访问以下接口不传递任何参数的情况下，执行的结果是？"></a>访问以下接口不传递任何参数的情况下，执行的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;id=&quot;</span>+id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：id=0<br>B：id=<br>C：页面报错 500<br>D：id=null</p><p>答：C<br>题目解析：页面报错会提示：可选的参数“id”不能转为 null，因为基本类型不能赋值 null，所以会报错。</p><h4 id="访问页面时显示-403-代表的含义是？"><a href="#访问页面时显示-403-代表的含义是？" class="headerlink" title="访问页面时显示 403 代表的含义是？"></a>访问页面时显示 403 代表的含义是？</h4><p>A：服务器繁忙<br>B：找不到该页面<br>C：禁止访问<br>D：服务器跳转中</p><p>答：C<br>题目解析：常用 HTTP 状态码及对应的含义：</p><ul><li>400：错误请求，服务器不理解请求的语法</li><li>401：未授权，请求要求身份验证</li><li>403：禁止访问，服务器拒绝请求</li><li>500：服务器内部错误，服务器遇到错误，无法完成请求</li><li>502：错误网关，服务器作为网关或代理，从上游服务器收到无效响应</li><li>504：网关超时，服务器作为网关或代理，但是没有及时从上游服务器收到请求</li></ul><h4 id="forward-和-redirect-有什么区别？"><a href="#forward-和-redirect-有什么区别？" class="headerlink" title="forward 和 redirect 有什么区别？"></a>forward 和 redirect 有什么区别？</h4><p>答：forward 和 redirect 区别如下：</p><ul><li>forward 表示请求转发，请求转发是服务器的行为；redirect 表示重定向，重定向是客户端行为；</li><li>forward 是服务器请求资源，服务器直接访问把请求的资源转发给浏览器，浏览器根本不知道服务器的内容是从哪来的，因此它的地址栏还是原来的地址；redirect 是服务端发送一个状态码告诉浏览器重新请求新的地址，因此地址栏显示的是新的 URL；</li><li>forward 转发页面和转发到的页面可以共享 request 里面的数据；redirect 不能共享数据；</li><li>从效率来说，forward 比 redirect 效率更高。</li></ul><h4 id="访问以下接口不传递任何参数的情况下，执行的结果是？-1"><a href="#访问以下接口不传递任何参数的情况下，执行的结果是？-1" class="headerlink" title="访问以下接口不传递任何参数的情况下，执行的结果是？"></a>访问以下接口不传递任何参数的情况下，执行的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;id=&quot;</span>+id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：id=0<br>B：id=<br>C：页面报错 500<br>D：id=null</p><p>答：D<br>题目解析：包装类可以赋值 null，不会报错。</p><h4 id="Spring-MVC-中如何在后端代码中实现页面跳转？"><a href="#Spring-MVC-中如何在后端代码中实现页面跳转？" class="headerlink" title="Spring MVC 中如何在后端代码中实现页面跳转？"></a>Spring MVC 中如何在后端代码中实现页面跳转？</h4><p>答：在后端代码中可以使用 forward:/index.jsp 或 redirect:/index.jsp 完成页面跳转，前者 URL 地址不会发生改变，或者 URL 地址会发生改变，完整跳转代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/redirect&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">redirectTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spring-MVC-的常用注解有哪些？"><a href="#Spring-MVC-的常用注解有哪些？" class="headerlink" title="Spring MVC 的常用注解有哪些？"></a>Spring MVC 的常用注解有哪些？</h4><p>答：Spring MVC 的常用注解如下：</p><ul><li>@Controller：用于标记某个类为控制器；</li><li>@ResponseBody ：标识返回的数据不是 html 标签的页面，而是某种格式的数据，如 JSON、XML 等；</li><li>@RestController：相当于 @Controller 加 @ResponseBody 的组合效果；</li><li>@Component：标识为 Spring 的组件；</li><li>@Configuration：用于定义配置类；</li><li>@RequestMapping：用于映射请求地址的注解；</li><li>@Autowired：自动装配对象；</li><li>@RequestHeader：可以把 Request 请求的 header 值绑定到方法的参数上。</li></ul><h4 id="拦截器的使用场景有哪些？"><a href="#拦截器的使用场景有哪些？" class="headerlink" title="拦截器的使用场景有哪些？"></a>拦截器的使用场景有哪些？</h4><p>答：拦截器的典型使用场景如下：</p><ul><li>日志记录：可用于记录请求日志，便于信息监控和信息统计；</li><li>权限检查：可用于用户登录状态的检查；</li><li>统一安全处理：可用于统一的安全效验或参数的加密 / 解密等。</li></ul><h4 id="Spring-MVC-如何排除拦截目录？"><a href="#Spring-MVC-如何排除拦截目录？" class="headerlink" title="Spring MVC 如何排除拦截目录？"></a>Spring MVC 如何排除拦截目录？</h4><p>答：在 Spring MVC 的配置文件中，添加 ，用于排除拦截目录，完整配置的示例代码如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 排除拦截地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/api/**&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.learning.core.MyInteceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Validated-和-Valid-有什么区别-？"><a href="#Validated-和-Valid-有什么区别-？" class="headerlink" title="@Validated 和 @Valid 有什么区别 ？"></a>@Validated 和 @Valid 有什么区别 ？</h4><p>答：@Validated 和 @Valid 都用于参数的效验，不同的是：</p><ul><li>@Valid 是 Hibernate 提供的效验机制，Java 的 JSR 303 声明了 @Valid 这个类接口，而 Hibernate-validator 对其进行了实现；@Validated 是 Spring 提供的效验机制，@Validation 是对 @Valid 进行了二次封装，提供了分组功能，可以在参数验证时，根据不同的分组采用不同的验证机制；</li><li>@Valid 可用在成员对象的属性字段验证上，而 @Validated 不能用在成员对象的属性字段验证上，也就是说 @Validated 无法提供嵌套验证。</li></ul><h4 id="Spring-MVC-有几种获取-request-的方式？"><a href="#Spring-MVC-有几种获取-request-的方式？" class="headerlink" title="Spring MVC 有几种获取 request 的方式？"></a>Spring MVC 有几种获取 request 的方式？</h4><p>答：Spring MVC 获取 request 有以下三种方式：</p><p>① 从请求参数中获取</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">　　<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法实现的原理是 Controller 开始处理请求时，Spring 会将 request 对象赋值到方法参数中。</p><p>② 通过 RequestContextHolder上下文获取 request 对象</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();</span><br><span class="line">    HttpServletRequest request = servletRequestAttributes.getRequest();</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ 通过自动注入的方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request; <span class="comment">// 自动注入 request 对象</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h3><p>本文我们了解了 Spring MVC 运行的 8 个步骤和它的 8 大核心组件，也尝试了 Spring MVC 方面的类型转换，可将表单自动转换为实体对象，也使用 Hibernate 的验证功能优雅地实现了参数的验证，还可以通过配置和实现 HandlerInterceptor 接口来自定义拦截器，相信有了这些知识，可以帮助我们更高效地开发 Web 和接口项目。</p><h2 id="Spring-Boot-的创建方式-面试题"><a href="#Spring-Boot-的创建方式-面试题" class="headerlink" title="Spring Boot 的创建方式 + 面试题"></a>Spring Boot 的创建方式 + 面试题</h2><h3 id="为什么要用-Spring-Boot？"><a href="#为什么要用-Spring-Boot？" class="headerlink" title="为什么要用 Spring Boot？"></a>为什么要用 Spring Boot？</h3><p>Spring Boot 来自于 Spring 大家族，是 Spring 官方团队（Pivotal 团队）提供的全新框架，它的诞生解决了 Spring 框架使用较为繁琐的问题。Spring Boot 的核心思想是约定优于配置，让开发人员不需要配置任何 XML 文件，就可以像 Maven 整合 Jar 包一样，整合并使用所有框架。</p><p><strong>Spring Boot 特性</strong></p><ul><li>秒级构建一个项目；</li><li>便捷的对外输出格式，如 REST API、WebSocket、Web 等；</li><li>简洁的安全集成策略；</li><li>内嵌容器运行，如 Tomcat、Jetty；</li><li>强大的开发包，支持热启动；</li><li>自动管理依赖；</li><li>自带应用监控。</li></ul><p><strong>Spring Boot 2 对系统环境的要求</strong></p><ul><li>Java 8+</li><li>Gradle 4+ or Maven 3.2+</li><li>Tomcat 8+</li></ul><h3 id="Spring-Boot-使用"><a href="#Spring-Boot-使用" class="headerlink" title="Spring Boot 使用"></a>Spring Boot 使用</h3><p>在开始之前，我们先来创建一个Spring Boot 项目。</p><p>Spring Boot 有两种快速创建的方式：Spring 官网在线网站创建和 IntelliJ IDEA 的 Spring Initializr 创建，下面分别来看。</p><h4 id="创建-Spring-Boot-项目"><a href="#创建-Spring-Boot-项目" class="headerlink" title="创建 Spring Boot 项目"></a>创建 Spring Boot 项目</h4><h5 id="在线网站创建"><a href="#在线网站创建" class="headerlink" title="在线网站创建"></a>在线网站创建</h5><p>在浏览器输入 <a href="https://start.spring.io/">https://start.spring.io</a>，页面打开如下图所示：</p><p><img src="/" alt="1" class="lazyload" data-src="https://images.gitbook.cn/edd49590-d9de-11e9-970d-b51140896651"></p><p>填写相应的项目信息，选择对应的 Spring Boot 和 Java 版本点击 “Generate the project”按钮下载项目压缩文件，解压后用 IDEA 打开即可。</p><p>其中 Group 和 Artifact 是 Maven 项目用来确认依赖项目的标识，比如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Group 对应的是配置文件的 groupId，相当于项目的包名；而 Artifact 对应的是配置文件的 artifactId，相当于项目名。</p><h5 id="使用-IntelliJ-IDEA-创建"><a href="#使用-IntelliJ-IDEA-创建" class="headerlink" title="使用 IntelliJ IDEA 创建"></a>使用 IntelliJ IDEA 创建</h5><p>① 新建项目 → 选择 Spring Initialzr，如下图所示：</p><p><img src="/" alt="2" class="lazyload" data-src="https://images.gitbook.cn/66e35660-d9df-11e9-970d-b51140896651"></p><p>② 点击 Next 按钮，填写对应的项目信息（和在线网站创建的字段基本相同），如下图所示：</p><p><img src="/" alt="3" class="lazyload" data-src="https://images.gitbook.cn/93a3c9f0-d9df-11e9-a4a6-41549f4e358a"></p><p>③ 点击 Next 按钮，选择相应的依赖信息，如下图所示：</p><p><img src="/" alt="4" class="lazyload" data-src="https://images.gitbook.cn/c2e4a6d0-d9df-11e9-b9ea-ef21e98d4482"></p><p>④ 点击 Next 按钮，选择项目保存的路径，点击 Finish 创建项目完成，如下图所示：</p><p><img src="/" alt="5" class="lazyload" data-src="https://images.gitbook.cn/db4ad640-d9df-11e9-a4a6-41549f4e358a"></p><h4 id="创建一个-Web-应用"><a href="#创建一个-Web-应用" class="headerlink" title="创建一个 Web 应用"></a>创建一个 Web 应用</h4><p>1）pom.xml 中添加 Web 模块的依赖，如下所示：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）创建后台代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）启动并访问项目</p><p>项目的启动类是标识了 @Spring BootApplication 的类，代码如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootlearningApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootlearningApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动并访问 <a href="http://localhost:8080/index?name=laowang">http://localhost:8080/index?name=laowang</a> 效果如下：</p><p><img src="/" alt="6" class="lazyload" data-src="https://images.gitbook.cn/f54c1810-d9df-11e9-b9ea-ef21e98d4482"></p><p>到目前为止 Spring Boot 的项目就创建并正常运行了。</p><h4 id="设置配置文件"><a href="#设置配置文件" class="headerlink" title="设置配置文件"></a>设置配置文件</h4><p>Spring Boot 的配置文件，是 resources 目录下 application.properties 文件，如下图所示：</p><p><img src="/" alt="7" class="lazyload" data-src="https://images.gitbook.cn/070f0f80-d9e0-11e9-a4a6-41549f4e358a"></p><p>可以在配置文件中设置很多关于 Spring 框架的配置，格式如下配置所示：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 项目运行端口</span><br><span class="line">server.port=8086</span><br><span class="line"># 请求编码格式</span><br><span class="line">server.tomcat.uri-encoding=UTF-8</span><br></pre></td></tr></table></figure><p>Spring Boot 的其他功能开发和 Spring 相同（Spring Boot 2 是基于 Spring Framework 5 构建的），本文就不过多的介绍了，<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/">感兴趣的朋友可以点击这里查看</a></p><h3 id="Spring-Boot-发布"><a href="#Spring-Boot-发布" class="headerlink" title="Spring Boot 发布"></a>Spring Boot 发布</h3><p>Spring Boot 项目的发布方式有两种：</p><ul><li>内置容器运行</li><li>外置容器（Tomcat）运行</li></ul><h4 id="内置容器运行"><a href="#内置容器运行" class="headerlink" title="内置容器运行"></a>内置容器运行</h4><h5 id="打包应用"><a href="#打包应用" class="headerlink" title="打包应用"></a>打包应用</h5><p>使用窗口命令，在 pom.xml 同级目录下：</p><blockquote><p>mvn clean package -Dmaven.test.skip=true</p></blockquote><p>Dmaven.test.skip=true 表示不执行测试用例，也不编译测试用例类。</p><h5 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h5><p>后台启动 Java 程序， 命令如下：</p><blockquote><p>nohup java -jar springbootlearning-0.0.1-SNAPSHOT.jar &amp;</p></blockquote><p><strong>停止程序</strong></p><p>首先查询 Java 程序的 pid</p><blockquote><p>ps -ef|grep java</p></blockquote><p>再停止程序</p><blockquote><p>kill -9 pid</p></blockquote><p>操作如下图所示：</p><p><img src="/" alt="8" class="lazyload" data-src="https://images.gitbook.cn/2fe74c60-d9e0-11e9-bef2-d97388d98f3f"></p><p><strong>扩展内容</strong></p><p>指定程序运行日志文件</p><blockquote><p>nohup java -jar springbootlearning-0.0.1-SNAPSHOT.jar 1&gt;&gt;logs 2&gt;&gt;errlog &amp;</p></blockquote><p>其中：</p><ul><li>1：表示普通日志</li><li>2：表示错误日志</li></ul><h4 id="外置容器（Tomcat）运行"><a href="#外置容器（Tomcat）运行" class="headerlink" title="外置容器（Tomcat）运行"></a>外置容器（Tomcat）运行</h4><h5 id="排除内置-Tomcat"><a href="#排除内置-Tomcat" class="headerlink" title="排除内置 Tomcat"></a>排除内置 Tomcat</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将 scope 属性设置为 provided，表示打包不会包含此依赖。</p><h5 id="配置启动类"><a href="#配置启动类" class="headerlink" title="配置启动类"></a>配置启动类</h5><p>在项目的启动类中继承 Spring BootServletInitializer 并重写 configure() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> application.sources(PackageApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PackageApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="打包应用-1"><a href="#打包应用-1" class="headerlink" title="打包应用"></a>打包应用</h5><p>使用窗口命令，在 pom.xml 同级目录下：</p><blockquote><p>mvn clean package -Dmaven.test.skip=true</p></blockquote><h5 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h5><p>打包完成会在 target 目录下生成：项目名 + 版本号.war 文件，复制到 Tomcat 的 webapps 目录下，运行 Tomcat 即可。</p><h3 id="相关面试题-26"><a href="#相关面试题-26" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="Spring-Boot-2-0-支持最低的-JDK-版本是？"><a href="#Spring-Boot-2-0-支持最低的-JDK-版本是？" class="headerlink" title="Spring Boot 2.0 支持最低的 JDK 版本是？"></a>Spring Boot 2.0 支持最低的 JDK 版本是？</h4><p>A：JDK 6<br>B：JDK 7<br>C：JDK 8<br>D：JDK 9</p><p>答：C</p><h4 id="Spring、Spring-Boot、Spring-Cloud-是什么关系？"><a href="#Spring、Spring-Boot、Spring-Cloud-是什么关系？" class="headerlink" title="Spring、Spring Boot、Spring Cloud 是什么关系？"></a>Spring、Spring Boot、Spring Cloud 是什么关系？</h4><p>答：它们都是来自于 Spring 大家庭，Spring Boot 是在 Spring 框架的基础上开发而来，让更加方便使用 Spring；Spring Cloud 是依赖于 Spring Boot 而构建的一套微服务治理框架。</p><h4 id="Spring-Boot-项目有哪些优势？"><a href="#Spring-Boot-项目有哪些优势？" class="headerlink" title="Spring Boot 项目有哪些优势？"></a>Spring Boot 项目有哪些优势？</h4><p>答：Spring Boot 项目优势如下：</p><ul><li>开发变得简单，提供了丰富的解决方案，快速集成各种解决方案提升开发效率；</li><li>配置变得简单，提供了丰富的 Starters，集成主流开源产品往往只需要简单的配置即可；</li><li>部署变得简单，其本身内嵌启动容器，仅仅需要一个命令即可启动项目，结合 Jenkins、Docker 自动化运维非常容易实现；</li><li>监控变得简单，自带监控组件，使用 Actuator 轻松监控服务各项状态。</li></ul><h4 id="如何将-Spring-Boot-项目打包成-war-包？"><a href="#如何将-Spring-Boot-项目打包成-war-包？" class="headerlink" title="如何将 Spring Boot 项目打包成 war 包？"></a>如何将 Spring Boot 项目打包成 war 包？</h4><p>答：在 pom.xml 里设置 <code>&lt;packaging&gt;war&lt;/packaging&gt;</code> 。</p><h4 id="在-Maven-项目中如何修改打包名称？"><a href="#在-Maven-项目中如何修改打包名称？" class="headerlink" title="在 Maven 项目中如何修改打包名称？"></a>在 Maven 项目中如何修改打包名称？</h4><p>答：在 pom.xml 文件的 build 节点中，添加 finalName 节点并设置为要的名称即可，配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>warName<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Ant、Maven、Gradle-有什么区别？"><a href="#Ant、Maven、Gradle-有什么区别？" class="headerlink" title="Ant、Maven、Gradle 有什么区别？"></a>Ant、Maven、Gradle 有什么区别？</h4><p>答：Ant、Maven、Gradle 是 Java 领域中主要有三大构建工具，它们的区别如下：</p><ul><li>Ant（AnotherNeatTool）诞生于 2000 年，是由 Java 编写，采用 XML 作为构建脚本，这样就允许你在任何环境下运行构建。Ant 是 Java 领域最早的构建工具，不过因为操作复杂，慢慢的已经被淘汰了；</li><li>Maven 诞生于 2004 年，目的是解决程序员使用 Ant 所带来的一些问题，它的好处在于可以将项目过程规范化、自动化、高效化以及强大的可扩展性；</li><li>Gradle 诞生于 2009 年，是一个基于 Apache Ant 和 Apache Maven 概念的项目自动化建构工具。它使用一种基于 Groovy 的特定领域语言来声明项目设置，而不是传统的 XML。结合了前两者的优点，在此基础之上做了很多改进，它具有 Ant 的强大和灵活，又有 Maven 的生命周期管理且易于使用。</li></ul><p>Spring Boot 官方支持 Maven 和 Gradle 作为项目构建工具。Gradle 虽然有更好的理念，但是相比 Maven 来讲其行业使用率偏低，并且 Spring Boot 官方默认使用 Maven。</p><h4 id="Maven-如何设置发布的包名？"><a href="#Maven-如何设置发布的包名？" class="headerlink" title="Maven 如何设置发布的包名？"></a>Maven 如何设置发布的包名？</h4><p>答：在 build 节点下设置 finalName 就是发布的包名，如下代码所示：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">     &lt;finalName&gt;biapi&lt;/finalName&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><h4 id="Spring-Boot-热部署有几种方式？"><a href="#Spring-Boot-热部署有几种方式？" class="headerlink" title="Spring Boot 热部署有几种方式？"></a>Spring Boot 热部署有几种方式？</h4><p>答：Spring Boot 热部署主要有两种方式：Spring Loaded、Spring-boot-devtools。</p><p>方式 1：Spring Loaded</p><p>在 pom.xml 文件中添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springloaded<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>此处为入口类<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式 2：Spring-boot-devtools</p><p>在 pom.xml 文件中添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Spring-Boot-2-0-可以在-Tomcat-7-运行吗？为什么？"><a href="#Spring-Boot-2-0-可以在-Tomcat-7-运行吗？为什么？" class="headerlink" title="Spring Boot 2.0 可以在 Tomcat 7 运行吗？为什么？"></a>Spring Boot 2.0 可以在 Tomcat 7 运行吗？为什么？</h4><p>答：Spring Boot 2.0 无法在 Tomcat 7 上运行。因为 Spring Boot 2.0 使用的是 Spring Framework 5，Spring Framework 5 使用的是 Servlet 3.1，而 Tomcat 7 最高支持到 Servlet 3.0，所以 Spring Boot 2.0 无法在 Tomcat 7 上运行。</p><h4 id="如何使用-Jetty-代替-Tomcat？"><a href="#如何使用-Jetty-代替-Tomcat？" class="headerlink" title="如何使用 Jetty 代替 Tomcat？"></a>如何使用 Jetty 代替 Tomcat？</h4><p>答：在 spring-boot-starter-web 移除现有的依赖项，添加 Jetty 依赖，配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Spring-Boot-不支持以下哪个内嵌容器？"><a href="#Spring-Boot-不支持以下哪个内嵌容器？" class="headerlink" title="Spring Boot 不支持以下哪个内嵌容器？"></a>Spring Boot 不支持以下哪个内嵌容器？</h4><p>A：Tomcat<br>B：Jetty<br>C：Undertow<br>D：Nginx</p><p>答：D</p><p>题目解析：Jetty 容器支持如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Undertow 容器支持如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Spring-Boot-中配置文件有几种格式？"><a href="#Spring-Boot-中配置文件有几种格式？" class="headerlink" title="Spring Boot 中配置文件有几种格式？"></a>Spring Boot 中配置文件有几种格式？</h4><p>答：Spring Boot 中有 .properties 和 .yml 两种配置文件格式，它们主要的区别是书写格式不同。</p><p>.properties 配置文件格式如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">app.user.name = hellojava</span><br></pre></td></tr></table></figure><p>.yml 配置文件格式如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">app:</span><br><span class="line">    user:</span><br><span class="line">        name: hellojava </span><br></pre></td></tr></table></figure><h4 id="项目中有两个配置-application-properties-和-application-yml，以下说法正确的是？"><a href="#项目中有两个配置-application-properties-和-application-yml，以下说法正确的是？" class="headerlink" title="项目中有两个配置 application.properties 和 application.yml，以下说法正确的是？"></a>项目中有两个配置 application.properties 和 application.yml，以下说法正确的是？</h4><p>A：application.properties 的内容会被忽略，只会识别 application.yml 的内容。<br>B：两个配置文件同时有效，有相同配置时，以 application.properties 文件为主。<br>C：application.yml 的内容会被忽略，只会识别 application.properties 的内容。<br>D：两个配置文件同时有效，有相同配置时，以 application.yml 文件为主。</p><p>答：B</p><h4 id="RequestMapping-和-GetMapping-有什么不同？"><a href="#RequestMapping-和-GetMapping-有什么不同？" class="headerlink" title="RequestMapping 和 GetMapping 有什么不同？"></a>RequestMapping 和 GetMapping 有什么不同？</h4><p>答：RequestMapping 和 GetMapping 区别如下：</p><ul><li>RequestMapping 可以支持 GET、POST、PUT 请求；</li><li>GetMapping 是一个组合注解，相当于 @RequestMapping(method = RequestMethod.GET)。</li></ul><h4 id="以下关于-RestController-和-Controller-说法正确的？"><a href="#以下关于-RestController-和-Controller-说法正确的？" class="headerlink" title="以下关于 @RestController 和 @Controller 说法正确的？"></a>以下关于 @RestController 和 @Controller 说法正确的？</h4><p>A：@Controller 返回 JSON 数据<br>B：@RestController 返回 JSON 数据<br>C：@APIController 返回 JSON 数据<br>D：以上都对</p><p>答：B</p><h4 id="Spring-Cache-常用的缓存注解有哪些？"><a href="#Spring-Cache-常用的缓存注解有哪些？" class="headerlink" title="Spring Cache 常用的缓存注解有哪些？"></a>Spring Cache 常用的缓存注解有哪些？</h4><p>答：Spring Cache 常用注解如下：</p><ul><li>@Cacheable：用来声明方法是可缓存，将结果存储到缓存中以便后续使用相同参数调用时不需执行实际的方法，直接从缓存中取值；</li><li>@CachePut：使用它标注的方法在执行前，不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中；</li><li>CacheEvict：是用来标注在需要清除缓存元素的方法或类上的，当标记在一个类上时表示其中所有方法的执行都会触发缓存的清除操作。</li></ul><h4 id="Spring-Boot-Admin-和-Spring-Boot-Actuator-的关系是什么？"><a href="#Spring-Boot-Admin-和-Spring-Boot-Actuator-的关系是什么？" class="headerlink" title="Spring Boot Admin 和 Spring Boot Actuator 的关系是什么？"></a>Spring Boot Admin 和 Spring Boot Actuator 的关系是什么？</h4><p>答：Spring Boot Admin 使用了 Spring Boot Actuator 接口进行 UI 美化封装的监控工具，它以图形化的方式查询单个应用的详细状态，也可以使用 Spring Boot Admin 来监控整个集群的状态。</p><h4 id="如何理解-Spring-Boot-中的-Stater？"><a href="#如何理解-Spring-Boot-中的-Stater？" class="headerlink" title="如何理解 Spring Boot 中的 Stater？"></a>如何理解 Spring Boot 中的 Stater？</h4><p>答：Stater 可以理解为启动器，它是方便开发者快速集成其他框架到 Spring 中的一种技术。比如，spring-boot-starter-data-jpa 就是把 JPA 快速集成到 Spring 中。</p><h4 id="常见的-starter-有哪些"><a href="#常见的-starter-有哪些" class="headerlink" title="常见的 starter 有哪些?"></a>常见的 starter 有哪些?</h4><p>答：常见的 starter 如下：</p><ul><li>spring-boot-starter-web：Web 开发支持</li><li>spring-boot-starter-data-jpa：JPA 操作数据库支持</li><li>spring-boot-starter-data-redis：Redis 操作支持</li><li>spring-boot-starter-data-solr：Solr 权限支持</li><li>mybatis-spring-boot-starter：MyBatis 框架支持</li></ul><h4 id="Spring-Boot-Starter-JDBC-和-Spring-JDBC-有什么关系？"><a href="#Spring-Boot-Starter-JDBC-和-Spring-JDBC-有什么关系？" class="headerlink" title="Spring Boot Starter JDBC 和 Spring JDBC 有什么关系？"></a>Spring Boot Starter JDBC 和 Spring JDBC 有什么关系？</h4><p>答：spring-boot-starter-jdbc 是 Spring Boot 针对 JDBC 的使用提供了对应的 Starter 包，在 Spring JDBC 上做了进一步的封装，方便在 Spring Boot 生态中更好的使用 JDBC。</p><h4 id="Spring-Boot-有哪几种读取配置的方式？"><a href="#Spring-Boot-有哪几种读取配置的方式？" class="headerlink" title="Spring Boot 有哪几种读取配置的方式？"></a>Spring Boot 有哪几种读取配置的方式？</h4><p>答：Spring Boot 可以通过 @Value、@Environment、@ConfigurationProperties 这三种方式来读取。</p><p>例如，配置文件内容如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">app.name=中文</span><br></pre></td></tr></table></figure><p><strong>① Value 方式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;app.name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String appName;</span><br></pre></td></tr></table></figure><p><strong>② Environment 方式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(String hiName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读取配置文件</span></span><br><span class="line">        String appName = environment.getProperty(<span class="string">&quot;app.name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + hiName + <span class="string">&quot; |@&quot;</span> + appName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>③ ConfigurationProperties 方式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取配置文件，必须有 setter 方法</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(String hiName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;appname:&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + hiName + <span class="string">&quot; |@&quot;</span> + appName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-Value-读取中文乱码是什么原因？如何处理？"><a href="#使用-Value-读取中文乱码是什么原因？如何处理？" class="headerlink" title="使用 @Value 读取中文乱码是什么原因？如何处理？"></a>使用 @Value 读取中文乱码是什么原因？如何处理？</h4><p>答：这是因为配置文件的编码格式导致的，需要把编码格式设置为 UTF-8，如下图所示：</p><p><img src="/" alt="9" class="lazyload" data-src="https://images.gitbook.cn/a286b670-d9e0-11e9-a4a6-41549f4e358a"></p><p>设置完成之后，重新启动 IDEA 就可以正常显示中文了。</p><h3 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h3><p>通过本文我们学习了 Spring Boot 的两种创建方式：在线网站创建和 IntelliJ IDEA 方式创建。知道了 Spring Boot 发布的两种方式：内置容器和外置 Tomcat，知道了 Spring Boot 项目特性，以及配置文件 .properties 和 .yml 的差异，掌握了读取配置文件的三种方式：@Value、@Environment、@ConfigurationProperties。</p><h2 id="MyBatis-核心组件-面试题"><a href="#MyBatis-核心组件-面试题" class="headerlink" title="MyBatis 核心组件 + 面试题"></a>MyBatis 核心组件 + 面试题</h2><h3 id="MyBatis-介绍"><a href="#MyBatis-介绍" class="headerlink" title="MyBatis 介绍"></a>MyBatis 介绍</h3><p>MyBatis 是一款优秀的 ORM（Object Relational Mapping，对象关系映射）框架，它可以通过对象和数据库之间的映射，将程序中的对象自动存储到数据库中。它是 Apache 提供的一个开源项目，之前的名字叫做 iBatis，2010 年迁移到了 Google Code，并且将名字改为我们现在所熟知的 MyBatis，又于 2013 年 11 月迁移到了 Github。</p><p>MyBatis 提供了普通 SQL 查询、事务、存储过程等功能，它的优缺点如下。</p><p><strong>优点</strong>：</p><ul><li>相比于 JDBC 需要编写的代码更少</li><li>使用灵活，支持动态 SQL</li><li>提供映射标签，支持对象与数据库的字段关系映射</li></ul><p><strong>缺点</strong>：</p><ul><li>SQL 语句依赖于数据库，数据库移植性差</li><li>SQL 语句编写工作量大，尤其在表、字段比较多的情况下</li></ul><p>总体来说，MyBatis 是一个非常优秀和灵活的数据持久化框架，适用于需求多变的互联网项目，也是当前主流的 ORM 框架。</p><h4 id="MyBatis-重要组件"><a href="#MyBatis-重要组件" class="headerlink" title="MyBatis 重要组件"></a>MyBatis 重要组件</h4><p>MyBatis 中的重要组件如下：</p><ul><li>Mapper 配置：用于组织具体的查询业务和映射数据库的字段关系，可以使用 XML 格式或 Java 注解格式来实现；</li><li>Mapper 接口：数据操作接口也就是通常说的 DAO 接口，要和 Mapper 配置文件中的方法一一对应；</li><li>Executor：MyBatis 中所有的 Mapper 语句的执行都是通过 Executor 执行的；</li><li>SqlSession：类似于 JDBC 中的 Connection，可以用 SqlSession 实例来直接执行被映射的 SQL 语句；</li><li>SqlSessionFactory：SqlSessionFactory 是创建 SqlSession 的工厂，可以通过 SqlSession openSession() 方法创建 SqlSession 对象。</li></ul><h4 id="MyBatis-执行流程"><a href="#MyBatis-执行流程" class="headerlink" title="MyBatis 执行流程"></a>MyBatis 执行流程</h4><p>MyBatis 完整执行流程如下图所示：</p><p><img src="/" alt="1" class="lazyload" data-src="https://images.gitbook.cn/4070e4c0-da75-11e9-b7a4-5f21fd84c626"></p><p>MyBatis 执行流程说明：</p><ol><li>首先加载 Mapper 配置的 SQL 映射文件，或者是注解的相关 SQL 内容。</li><li>创建会话工厂，MyBatis 通过读取配置文件的信息来构造出会话工厂（SqlSessionFactory）。</li><li>创建会话，根据会话工厂，MyBatis 就可以通过它来创建会话对象（SqlSession），会话对象是一个接口，该接口中包含了对数据库操作的增、删、改、查方法。</li><li>创建执行器，因为会话对象本身不能直接操作数据库，所以它使用了一个叫做数据库执行器（Executor）的接口来帮它执行操作。</li><li>封装 SQL 对象，在这一步，执行器将待处理的 SQL 信息封装到一个对象中（MappedStatement），该对象包括 SQL 语句、输入参数映射信息（Java 简单类型、HashMap 或 POJO）和输出结果映射信息（Java 简单类型、HashMap 或 POJO）。</li><li>操作数据库，拥有了执行器和 SQL 信息封装对象就使用它们访问数据库了，最后再返回操作结果，结束流程。</li></ol><h3 id="MyBatis-XML-版"><a href="#MyBatis-XML-版" class="headerlink" title="MyBatis XML 版"></a>MyBatis XML 版</h3><p>MyBatis 使用分为两个版本：XML 版和 Java 注解版。接下来我们使用 Spring Boot 结合 MyBatis 的 XML 版，来实现对数据库的基本操作，步骤如下。</p><h4 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> <span class="string">`t_user`</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`t_user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span> auto_increment <span class="keyword">comment</span> <span class="string">&#x27;主键id&#x27;</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  <span class="string">`nick_name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">  primary <span class="keyword">key</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span> auto_increment=<span class="number">1</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br></pre></td></tr></table></figure><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>在项目添加对 MyBatis 和 MySQL 支持的依赖包，在 pom.xml 文件中添加如下代码：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mybatis-spring-boot-starter 是 MyBatis 官方帮助我们快速集成 Spring Boot 提供的一个组件包，mybatis-spring-boot-starter 2.1.0 对应 MyBatis 的版本是 3.5.2。</p><h4 id="增加配置文件"><a href="#增加配置文件" class="headerlink" title="增加配置文件"></a>增加配置文件</h4><p>在 application.yml 文件中添加以下内容：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://localhost:3306/learndb?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">mybatis:</span><br><span class="line">  config-location: classpath:mybatis/mybatis-config.xml</span><br><span class="line">  mapper-locations: classpath:mybatis/mapper/*.xml</span><br><span class="line">  type-aliases-package: com.interview.mybatislearning.model</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>mybatis.config-location：配置 MyBatis 基础属性；</li><li>mybatis.mapper-locations：配置 Mapper 对应的 XML 文件路径；</li><li>mybatis.type-aliases-package：配置项目中实体类包路径。</li></ul><p>注：如果配置文件使用的是 application.properties，配置内容是相同的，只是内容格式不同。</p><h4 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserEntity</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5980266333958177104L</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String passWord;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserEntity</span><span class="params">(String userName, String passWord, String nickName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.passWord = passWord;</span><br><span class="line">        <span class="keyword">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> passWord;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassWord</span><span class="params">(String passWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNickName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nickName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNickName</span><span class="params">(String nickName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建-XML-文件"><a href="#创建-XML-文件" class="headerlink" title="创建 XML 文件"></a>创建 XML 文件</h4><p><strong>mybatis-config.xml</strong>（基础配置文件）：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Integer&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.Integer&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Long&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.Long&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;HashMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.util.HashMap&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;LinkedHashMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.util.LinkedHashMap&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;ArrayList&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.util.ArrayList&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;LinkedList&quot;</span> <span class="attr">type</span>=<span class="string">&quot;java.util.LinkedList&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mybatis-config.xml 主要是为常用的数据类型设置别名，用于减少类完全限定名的长度，比如：<code>resultType=&quot;Integer&quot;</code> 完整示例代码如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Integer&quot;</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">    count(*)</span><br><span class="line">    from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>UserMapper.xml</strong>（业务配置文件）：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.interview.mybatislearning.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.interview.mybatislearning.model.UserEntity&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;passWord&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;nick_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;nickName&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span> &gt;</span></span><br><span class="line">        id, username, password, nick_name</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Where_List&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName != null  and userName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            and userName = #&#123;userName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>  &gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span> /&gt;</span></span><br><span class="line">        FROM t_user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOne&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span> &gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span> /&gt;</span></span><br><span class="line">        FROM t_user</span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.interview.mybatislearning.model.UserEntity&quot;</span> &gt;</span></span><br><span class="line">       INSERT INTO</span><br><span class="line">               t_user</span><br><span class="line">               (username,password,nick_name)</span><br><span class="line">           VALUES</span><br><span class="line">               (#&#123;userName&#125;, #&#123;passWord&#125;, #&#123;nickName&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.interview.mybatislearning.model.UserEntity&quot;</span> &gt;</span></span><br><span class="line">        UPDATE</span><br><span class="line">        t_user</span><br><span class="line">        SET</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userName != null&quot;</span>&gt;</span>username = #&#123;userName&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;passWord != null&quot;</span>&gt;</span>password = #&#123;passWord&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        nick_name = #&#123;nickName&#125;</span><br><span class="line">        WHERE</span><br><span class="line">        id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Long&quot;</span> &gt;</span></span><br><span class="line">       DELETE FROM</span><br><span class="line">                t_user</span><br><span class="line">       WHERE</span><br><span class="line">                id =#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上配置我们增加了增删改查等基础方法。</p><h4 id="增加-Mapper-文件"><a href="#增加-Mapper-文件" class="headerlink" title="增加 Mapper 文件"></a>增加 Mapper 文件</h4><p>此步骤我们需要创建一个与 XML 对应的业务 Mapper 接口，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;UserEntity&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">UserEntity <span class="title">getOne</span><span class="params">(Long id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(UserEntity user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(UserEntity user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加-Mapper-包扫描"><a href="#添加-Mapper-包扫描" class="headerlink" title="添加 Mapper 包扫描"></a>添加 Mapper 包扫描</h4><p>在启动类中添加 @MapperScan，设置 Spring Boot 启动的时候会自动加载包路径下的 Mapper。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.interview.mybatislearning.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisLearningApplication</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       SpringApplication.run(MyBatisLearningApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h4><p>经过以上步骤之后，整个 MyBatis 的集成就算完成了。接下来我们写一个单元测试，验证一下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatislearningApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userMapper.insert(<span class="keyword">new</span> UserEntity(<span class="string">&quot;laowang&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;老王&quot;</span>));</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>, userMapper.getAll().size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h3><p>通过本文我们知道 MyBatis 是一个优秀和灵活的数据持久化框架，MyBatis 包含 Mapper 配置、Mapper 接口、Executor、SqlSession、SqlSessionFactory 等几个重要的组件，知道了 MyBatis 基本流程：MyBatis 首先加载 Mapper 配置和 SQL 映射文件，通过创建会话工厂得到 SqlSession 对象，再执行 SQL 语句并返回操作信息。我们也使用 XML 的方式，实现了 MyBatis 对数据库的基础操作。</p><h2 id="对数据库的基本操作步骤-面试题"><a href="#对数据库的基本操作步骤-面试题" class="headerlink" title="对数据库的基本操作步骤 + 面试题"></a>对数据库的基本操作步骤 + 面试题</h2><p>MyBatis 最初的设计是基于 XML 配置文件的，但随着 Java 的发展（Java 1.5 开始引入注解）和 MyBatis 自身的迭代升级，终于在 MyBatis 3 之后就开始支持基于注解的开发了。</p><p>下面我们使用 Spring Boot + MyBatis 注解的方式，来实现对数据库的基本操作，具体实现步骤如下。</p><h3 id="MyBatis-注解版"><a href="#MyBatis-注解版" class="headerlink" title="MyBatis 注解版"></a>MyBatis 注解版</h3><h4 id="创建数据表-1"><a href="#创建数据表-1" class="headerlink" title="创建数据表"></a>创建数据表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> <span class="string">`t_user`</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`t_user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span> auto_increment <span class="keyword">comment</span> <span class="string">&#x27;主键id&#x27;</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  <span class="string">`nick_name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">  primary <span class="keyword">key</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">innodb</span> auto_increment=<span class="number">1</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br></pre></td></tr></table></figure><h4 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="增加配置文件-1"><a href="#增加配置文件-1" class="headerlink" title="增加配置文件"></a>增加配置文件</h4><p>在 application.yml 文件中添加以下内容：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://localhost:3306/learndb?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">mybatis:</span><br><span class="line">  type-aliases-package: com.interview.model</span><br></pre></td></tr></table></figure><h4 id="创建实体类-1"><a href="#创建实体类-1" class="headerlink" title="创建实体类"></a>创建实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserEntity</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5980266333958177105L</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String passWord;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserEntity</span><span class="params">(String userName, String passWord, String nickName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.passWord = passWord;</span><br><span class="line">        <span class="keyword">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> passWord;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassWord</span><span class="params">(String passWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNickName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nickName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNickName</span><span class="params">(String nickName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="增加-Mapper-文件-1"><a href="#增加-Mapper-文件-1" class="headerlink" title="增加 Mapper 文件"></a>增加 Mapper 文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user&quot;)</span></span><br><span class="line">    <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">            @Result(property = &quot;nickName&quot;, column = &quot;nick_name&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function">List&lt;UserEntity&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">            @Result(property = &quot;nickName&quot;, column = &quot;nick_name&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function">UserEntity <span class="title">getOne</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into t_user(username,password,nick_name) values(#&#123;userName&#125;, #&#123;passWord&#125;, #&#123;nickName&#125;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(UserEntity user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update t_user set username=#&#123;userName&#125;,nick_name=#&#123;nickName&#125; where id =#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(UserEntity user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&#123;&quot;&lt;script&gt; &quot;,</span></span><br><span class="line"><span class="meta">            &quot;update t_user &quot;,</span></span><br><span class="line"><span class="meta">            &quot;&lt;set&gt;&quot;,</span></span><br><span class="line"><span class="meta">            &quot; &lt;if test=&#x27;userName != null&#x27;&gt;userName=#&#123;userName&#125;,&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta">            &quot; &lt;if test=&#x27;nickName != null&#x27;&gt;nick_name=#&#123;nickName&#125;,&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta">            &quot; &lt;/set&gt; &quot;,</span></span><br><span class="line"><span class="meta">            &quot;where id=#&#123;id&#125; &quot;,</span></span><br><span class="line"><span class="meta">            &quot;&lt;/script&gt;&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateUserEntity</span><span class="params">(UserEntity user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from t_user where id =#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 @Select、@Insert、@Update、@Delete、@Results、@Result 等注解来替代 XML 配置文件。</p><h4 id="添加-Mapper-包扫描-1"><a href="#添加-Mapper-包扫描-1" class="headerlink" title="添加 Mapper 包扫描"></a>添加 Mapper 包扫描</h4><p>在启动类中添加 @MapperScan，设置 Spring Boot 启动的时候会自动加载包路径下的 Mapper。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.interview.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MybatisApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写测试代码-1"><a href="#编写测试代码-1" class="headerlink" title="编写测试代码"></a>编写测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userMapper.insert(<span class="keyword">new</span> UserEntity(<span class="string">&quot;laowang&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;老王&quot;</span>));</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>, userMapper.getAll().size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关面试题-27"><a href="#相关面试题-27" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="MyBatis-有哪些优缺点？"><a href="#MyBatis-有哪些优缺点？" class="headerlink" title="MyBatis 有哪些优缺点？"></a>MyBatis 有哪些优缺点？</h4><p>答：MyBatis 优缺点如下：</p><p>优点：</p><ul><li>相比于 JDBC 需要编写的代码更少</li><li>使用灵活，支持动态 SQL</li><li>提供映射标签，支持对象与数据库的字段关系映射</li></ul><p>缺点：</p><ul><li>SQL 语句依赖于数据库，数据库移植性差</li><li>SQL 语句编写工作量大，尤其在表、字段比较多的情况下</li></ul><p>总体来说，MyBatis 是一个非常不错的持久层解决方案，它专注于 SQL 本身，非常灵活，适用于需求变化较多的互联网项目，也是当前国内主流的 ORM 框架。</p><h4 id="以下不属于-MyBatis-优点的是？"><a href="#以下不属于-MyBatis-优点的是？" class="headerlink" title="以下不属于 MyBatis 优点的是？"></a>以下不属于 MyBatis 优点的是？</h4><p>A：可以灵活的编辑 SQL 语句<br>B：很好的支持不同数据库之间的迁移<br>C：能够很好的和 Spring 框架集成<br>D：提供映射标签支持对象和数据库的字段映射</p><p>答：B</p><p>题目解析：因为 MyBatis 需要自己编写 SQL 语句，但每个数据库的 SQL 语句有略有差异，所以 MyBatis 不能很好的支持不同数据库之间的迁移。</p><h4 id="MyBatis-和-Hibernate-有哪些不同？"><a href="#MyBatis-和-Hibernate-有哪些不同？" class="headerlink" title="MyBatis 和 Hibernate 有哪些不同？"></a>MyBatis 和 Hibernate 有哪些不同？</h4><p>答：MyBatis 和 Hibernate 都是非常优秀的 ORM 框架，它们的区别如下：</p><ul><li>灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便；</li><li>可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差；</li><li>开发效率：Hibernate 对 SQL 语句做了封装，让开发者可以直接使用，因此开发效率更高；</li><li>学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。</li></ul><h4 id="“-”和“-”有什么区别？"><a href="#“-”和“-”有什么区别？" class="headerlink" title="“#”和“$”有什么区别？"></a>“#”和“<code>$</code>”有什么区别？</h4><p>答：“#”是预编译处理，“$”是字符替换。 在使用“#”时，MyBatis 会将 SQL 中的参数替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。</p><h4 id="5-在-MyBatis-中怎么解决实体类属性名和表字段名不一致的问题？"><a href="#5-在-MyBatis-中怎么解决实体类属性名和表字段名不一致的问题？" class="headerlink" title="5.在 MyBatis 中怎么解决实体类属性名和表字段名不一致的问题？"></a>5.在 MyBatis 中怎么解决实体类属性名和表字段名不一致的问题？</h4><p>答：通常的解决方案有以下两种方式。</p><p>① 在 SQL 语句中重命名为实体类的属性名，可参考以下配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectorder&quot;</span> <span class="attr">parametertype</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultetype</span>=<span class="string">&quot;com.interview.order&quot;</span>&gt;</span></span><br><span class="line">       select order_id id, order_no orderno form order where order_id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>② 通过 <code>&lt;resultMap&gt;</code> 映射对应关系，可参考以下配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.interview.mybatislearning.model.UserEntity&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;passWord&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;nick_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;nickName&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="在-MyBatis-中如何实现-like-查询？"><a href="#在-MyBatis-中如何实现-like-查询？" class="headerlink" title="在 MyBatis 中如何实现 like 查询？"></a>在 MyBatis 中如何实现 like 查询？</h4><p>答：可以在 Java 代码中添加 SQL 通配符来实现 like 查询，这样也可以有效的防治 SQL 注入，具体实现如下：</p><p>Java 代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = <span class="string">&quot;%wang%&quot;</span>:</span><br><span class="line">List&lt;User&gt; list = mapper.likeName(name);</span><br></pre></td></tr></table></figure><p>Mapper 配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;likeName&quot;</span>&gt;</span></span><br><span class="line">    select * form t_user where name like #&#123;name&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="MyBatis-有几种分页方式？"><a href="#MyBatis-有几种分页方式？" class="headerlink" title="MyBatis 有几种分页方式？"></a>MyBatis 有几种分页方式？</h4><p>答：MyBatis 的分页方式有以下两种：</p><ul><li>逻辑分页，使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索；</li><li>物理分页，自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据形式。</li></ul><h4 id="RowBounds-是一次性查询全部结果吗？为什么？"><a href="#RowBounds-是一次性查询全部结果吗？为什么？" class="headerlink" title="RowBounds 是一次性查询全部结果吗？为什么？"></a>RowBounds 是一次性查询全部结果吗？为什么？</h4><p>答：RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据。因为 MyBatis 是对 JDBC 的封装，在 JDBC 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在执行 next() 的时候，去查询更多的数据。 就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，要取 4 次才能把钱取完。对于 JDBC 来说也是一样，这样做的好处是可以有效的防止内存溢出。</p><h4 id="为什么阿里巴巴不允许使用-HashMap-或-Hashtable-作为查询结果集直接输出？"><a href="#为什么阿里巴巴不允许使用-HashMap-或-Hashtable-作为查询结果集直接输出？" class="headerlink" title="为什么阿里巴巴不允许使用 HashMap 或 Hashtable 作为查询结果集直接输出？"></a>为什么阿里巴巴不允许使用 HashMap 或 Hashtable 作为查询结果集直接输出？</h4><p>答：因为使用 HashMap 或 Hashtable 作为查询结果集直接输出，会导致值类型不可控，给调用人员造成困扰，给系统带来更多不稳定的因素。</p><h4 id="什么是动态-SQL？"><a href="#什么是动态-SQL？" class="headerlink" title="什么是动态 SQL？"></a>什么是动态 SQL？</h4><p>答：动态 SQL 是指可以根据不同的参数信息来动态拼接的不确定的 SQL 叫做动态 SQL，MyBatis 动态 SQL 的主要元素有：if、choose/when/otherwise、trim、where、set、foreach 等。 以 if 标签的使用为例：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;findUser&quot;</span> parameterType=<span class="string">&quot;com.interview.entity.User&quot;</span> resultType=<span class="string">&quot;com.interview.entity.User&quot;</span>&gt;</span><br><span class="line">      select * from t_user where</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">&quot;id!=null&quot;</span>&gt;</span><br><span class="line">        id = #&#123;id&#125;</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">&quot;username!=null&quot;</span>&gt;</span><br><span class="line">        and username = #&#123;username&#125;</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">&quot;password!=null&quot;</span>&gt;</span><br><span class="line">        and password = #&#123;password&#125;</span><br><span class="line">      &lt;/if&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h4 id="为什么不建议在程序中滥用事务？"><a href="#为什么不建议在程序中滥用事务？" class="headerlink" title="为什么不建议在程序中滥用事务？"></a>为什么不建议在程序中滥用事务？</h4><p>答：因为事务的滥用会影响数据的 QPS（每秒查询率），另外使用事务的地方还要考虑各方面回滚的方案，如缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p><h4 id="如何开启-MyBatis-的延迟加载？"><a href="#如何开启-MyBatis-的延迟加载？" class="headerlink" title="如何开启 MyBatis 的延迟加载？"></a>如何开启 MyBatis 的延迟加载？</h4><p>答：只需要在 mybatis-config.xml 设置 <code>&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</code> 即可打开延迟缓存功能，完整配置文件如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开启延迟加载 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="什么是-MyBatis-的一级缓存和二级缓存？"><a href="#什么是-MyBatis-的一级缓存和二级缓存？" class="headerlink" title="什么是 MyBatis 的一级缓存和二级缓存？"></a>什么是 MyBatis 的一级缓存和二级缓存？</h4><p>答：MyBatis 缓存如下：</p><ul><li>一级缓存是 SqlSession 级别的，是 MyBatis 自带的缓存功能，并且无法关闭，因此当有两个 SqlSession 访问相同的 SQL 时，一级缓存也不会生效，需要查询两次数据库；</li><li>二级缓存是 Mapper 级别的，只要是同一个 Mapper，无论使用多少个 SqlSession 来操作，数据都是共享的，多个不同的 SqlSession 可以共用二级缓存，MyBatis 二级缓存默认是关闭的，需要使用时可手动开启，二级缓存也可以使用第三方的缓存，比如，使用 Ehcache 作为二级缓存。</li></ul><p>手动开启二级缓存，配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开启二级缓存 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="如何设置-Ehcache-为-MyBatis-的二级缓存？"><a href="#如何设置-Ehcache-为-MyBatis-的二级缓存？" class="headerlink" title="如何设置 Ehcache 为 MyBatis 的二级缓存？"></a>如何设置 Ehcache 为 MyBatis 的二级缓存？</h4><p>答：可直接在 XML 中配置开启 EhcacheCache，代码如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.interview.repository.ClassesReposirory&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 开启二级缓存 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 缓存创建以后，最后一次访问缓存的时间至失效的时间间隔 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeToIdleSeconds&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3600&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 缓存自创建时间起至失效的时间间隔--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeToLiveSeconds&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3600&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 缓存回收策略，LRU 移除近期最少使用的对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;memoryStoreEvictionPolicy&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.interview.entity.Classes&quot;</span>&gt;</span></span><br><span class="line">        select * from classes where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="MyBatis-有哪些拦截器？如何实现拦截功能？"><a href="#MyBatis-有哪些拦截器？如何实现拦截功能？" class="headerlink" title="MyBatis 有哪些拦截器？如何实现拦截功能？"></a>MyBatis 有哪些拦截器？如何实现拦截功能？</h4><p>答：MyBatis 提供的连接器有以下 4 种。</p><ul><li>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作。</li><li>StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存。</li><li>ParameterHandler：拦截参数的处理。</li><li>ResultSetHandler：拦截结果集的处理。</li></ul><p>拦截功能具体实现如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;@Signature(type = Executor.class, method = &quot;query&quot;,</span></span><br><span class="line"><span class="meta">        args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">     Object target = invocation.getTarget(); <span class="comment">//被代理对象</span></span><br><span class="line">     Method method = invocation.getMethod(); <span class="comment">//代理方法</span></span><br><span class="line">     Object[] args = invocation.getArgs(); <span class="comment">//方法参数</span></span><br><span class="line">     <span class="comment">// 方法拦截前执行代码块</span></span><br><span class="line">     Object result = invocation.proceed();</span><br><span class="line">     <span class="comment">// 方法拦截后执行代码块</span></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-23"><a href="#总结-23" class="headerlink" title="总结"></a>总结</h3><p>通过本文可以看出 MyBatis 注解版和 XML 版的主要区别是 Mapper 中的代码，注解版把之前在 XML 的 SQL 实现，全部都提到 Mapper 中了，这样就省去了配置 XML 的麻烦。</p><h2 id="消息队列面试题汇总"><a href="#消息队列面试题汇总" class="headerlink" title="消息队列面试题汇总"></a>消息队列面试题汇总</h2><h4 id="消息队列的应用场景有哪些？"><a href="#消息队列的应用场景有哪些？" class="headerlink" title="消息队列的应用场景有哪些？"></a>消息队列的应用场景有哪些？</h4><p>答：消息队列的应用场景如下。</p><ul><li>应用解耦，比如，用户下单后，订单系统需要通知库存系统，假如库存系统无法访问，则订单减库存将失败，从而导致订单失败。订单系统与库存系统耦合，这个时候如果使用消息队列，可以返回给用户成功，先把消息持久化，等库存系统恢复后，就可以正常消费减去库存了。</li><li>削峰填谷，比如，秒杀活动，一般会因为流量过大，从而导致流量暴增，应用挂掉，这个时候加上消息队列，服务器接收到用户的请求后，首先写入消息队列，假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面。</li><li>日志系统，比如，客户端负责将日志采集，然后定时写入消息队列，消息队列再统一将日志数据存储和转发。</li></ul><h4 id="RabbitMQ-有哪些优点？"><a href="#RabbitMQ-有哪些优点？" class="headerlink" title="RabbitMQ 有哪些优点？"></a>RabbitMQ 有哪些优点？</h4><p>答：RabbitMQ 的优点如下：</p><ul><li>可靠性，RabbitMQ 的持久化支持，保证了消息的稳定性；</li><li>高并发，RabbitMQ 使用了 Erlang 开发语言，Erlang 是为电话交换机开发的语言，天生自带高并发光环和高可用特性；</li><li>集群部署简单，正是因为 Erlang 使得 RabbitMQ 集群部署变的非常简单；</li><li>社区活跃度高，因为 RabbitMQ 应用比较广泛，所以社区的活跃度也很高；</li><li>解决问题成本低，因为资料比较多，所以解决问题的成本也很低；</li><li>支持多种语言，主流的编程语言都支持，如 Java、.NET、PHP、Python、JavaScript、Ruby、Go 等；</li><li>插件多方便使用，如网页控制台消息管理插件、消息延迟插件等。</li></ul><h4 id="RabbitMQ-有哪些重要的角色？"><a href="#RabbitMQ-有哪些重要的角色？" class="headerlink" title="RabbitMQ 有哪些重要的角色？"></a>RabbitMQ 有哪些重要的角色？</h4><p>答：RabbitMQ 包含以下三个重要的角色：</p><ul><li>生产者：消息的创建者，负责创建和推送数据到消息服务器；</li><li>消费者：消息的接收方，用于处理数据和确认消息；</li><li>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li></ul><h4 id="RabbitMQ-有哪些重要的组件？它们有什么作用？"><a href="#RabbitMQ-有哪些重要的组件？它们有什么作用？" class="headerlink" title="RabbitMQ 有哪些重要的组件？它们有什么作用？"></a>RabbitMQ 有哪些重要的组件？它们有什么作用？</h4><p>答：RabbitMQ 包含的重要组件有：ConnectionFactory（连接管理器）、Channel（信道）、Exchange（交换器）、Queue（队列）、RoutingKey（路由键）、BindingKey（绑定键） 等重要的组件，它们的作用如下：</p><ul><li>ConnectionFactory（连接管理器）：应用程序与 RabbitMQ 之间建立连接的管理器，程序代码中使用；</li><li>Channel（信道）：消息推送使用的通道；</li><li>Exchange（交换器）：用于接受、分配消息；</li><li>Queue（队列）：用于存储生产者的消息；</li><li>RoutingKey（路由键）：用于把生成者的数据分配到交换器上；</li><li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</li></ul><p>运行流程，如下图所示：</p><p><img src="/" alt="1" class="lazyload" data-src="https://images.gitbook.cn/5a2e5b40-da7f-11e9-b65e-cd2fb825a32b"></p><h4 id="什么是消息持久化？"><a href="#什么是消息持久化？" class="headerlink" title="什么是消息持久化？"></a>什么是消息持久化？</h4><p>答：消息持久化是把消息保存到物理介质上，以防止消息的丢失。</p><h4 id="RabbitMQ-要实现消息持久化，需要满足哪些条件？"><a href="#RabbitMQ-要实现消息持久化，需要满足哪些条件？" class="headerlink" title="RabbitMQ 要实现消息持久化，需要满足哪些条件？"></a>RabbitMQ 要实现消息持久化，需要满足哪些条件？</h4><p>答：RabbitMQ 要实现消息持久化，必须满足以下 4 个条件：</p><ul><li>投递消息的时候 durable 设置为 true，消息持久化，代码：channel.queueDeclare(x, true, false, false, null)，参数 2 设置为 true 持久化；</li><li>设置投递模式 deliveryMode 设置为 2（持久），代码：channel.basicPublish(x, x, MessageProperties.PERSISTENT<em>TEXT</em>PLAIN,x)，参数 3 设置为存储纯文本到磁盘；</li><li>消息已经到达持久化交换器上；</li><li>消息已经到达持久化的队列。</li></ul><h4 id="消息持久化有哪些缺点？如何缓解？"><a href="#消息持久化有哪些缺点？如何缓解？" class="headerlink" title="消息持久化有哪些缺点？如何缓解？"></a>消息持久化有哪些缺点？如何缓解？</h4><p>答：消息持久化的缺点是很消耗性能，因为要写入硬盘要比写入内存性能较低很多，从而降低了服务器的吞吐量。可使用固态硬盘来提高读写速度，以达到缓解消息持久化的缺点。</p><h4 id="如何使用-Java-代码连接-RabbitMQ？"><a href="#如何使用-Java-代码连接-RabbitMQ？" class="headerlink" title="如何使用 Java 代码连接 RabbitMQ？"></a>如何使用 Java 代码连接 RabbitMQ？</h4><p>答：使用 Java 代码连接 RabbitMQ 有以下两种方式：</p><p>方式一：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">GetRabbitConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setUsername(Config.UserName);</span><br><span class="line">    factory.setPassword(Config.Password);</span><br><span class="line">    factory.setVirtualHost(Config.VHost);</span><br><span class="line">    factory.setHost(Config.Host);</span><br><span class="line">    factory.setPort(Config.Port);</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = factory.newConnection();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">GetRabbitConnection2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    <span class="comment">// 连接格式：amqp://userName:password@hostName:portNumber/virtualHost</span></span><br><span class="line">    String uri = String.format(<span class="string">&quot;amqp://%s:%s@%s:%d%s&quot;</span>, Config.UserName, Config.Password, Config.Host, Config.Port,</span><br><span class="line">            Config.VHost);</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        factory.setUri(uri);</span><br><span class="line">        factory.setVirtualHost(Config.VHost);</span><br><span class="line">        conn = factory.newConnection();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-Java-代码编写一个-RabbitMQ-消费和生产的示例？"><a href="#使用-Java-代码编写一个-RabbitMQ-消费和生产的示例？" class="headerlink" title="使用 Java 代码编写一个 RabbitMQ 消费和生产的示例？"></a>使用 Java 代码编写一个 RabbitMQ 消费和生产的示例？</h4><p>答：代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    publisher();     <span class="comment">// 生产消息</span></span><br><span class="line">    consumer();     <span class="comment">// 消费消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 推送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publisher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个连接</span></span><br><span class="line">    Connection conn = ConnectionFactoryUtil.GetRabbitConnection();</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建通道</span></span><br><span class="line">            Channel channel = conn.createChannel();</span><br><span class="line">            <span class="comment">// 声明队列【参数说明：参数一：队列名称，参数二：是否持久化；参数三：是否独占模式；参数四：消费者断开连接时是否删除队列；参数五：消息其他参数】</span></span><br><span class="line">            channel.queueDeclare(Config.QueueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            String content = String.format(<span class="string">&quot;当前时间：%s&quot;</span>, <span class="keyword">new</span> Date().getTime());</span><br><span class="line">            <span class="comment">// 发送内容【参数说明：参数一：交换机名称；参数二：队列名称，参数三：消息的其他属性-routing headers，此属性为MessageProperties.PERSISTENT_TEXT_PLAIN用于设置纯文本消息存储到硬盘；参数四：消息主体】</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, Config.QueueName, <span class="keyword">null</span>, content.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;已发送消息：&quot;</span> + content);</span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            channel.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个连接</span></span><br><span class="line">    Connection conn = ConnectionFactoryUtil.GetRabbitConnection();</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建通道</span></span><br><span class="line">            Channel channel = conn.createChannel();</span><br><span class="line">            <span class="comment">// 声明队列【参数说明：参数一：队列名称，参数二：是否持久化；参数三：是否独占模式；参数四：消费者断开连接时是否删除队列；参数五：消息其他参数】</span></span><br><span class="line">            channel.queueDeclare(Config.QueueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建订阅器，并接受消息</span></span><br><span class="line">            channel.basicConsume(Config.QueueName, <span class="keyword">false</span>, <span class="string">&quot;&quot;</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    String routingKey = envelope.getRoutingKey(); <span class="comment">// 队列名称</span></span><br><span class="line">                    String contentType = properties.getContentType(); <span class="comment">// 内容类型</span></span><br><span class="line">                    String content = <span class="keyword">new</span> String(body, <span class="string">&quot;utf-8&quot;</span>); <span class="comment">// 消息正文</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;消息正文：&quot;</span> + content);</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>); <span class="comment">// 手动确认消息【参数说明：参数一：该消息的index；参数二：是否批量应答，true批量确认小于index的消息】</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RabbitMQ-交换器类型有哪些？"><a href="#RabbitMQ-交换器类型有哪些？" class="headerlink" title="RabbitMQ 交换器类型有哪些？"></a>RabbitMQ 交换器类型有哪些？</h4><p>答：RabbitMQ 消费类型也就是交换器（Exchange）类型有以下四种：</p><ul><li>direct：轮询方式</li><li>headers：轮询方式，允许使用 header 而非路由键匹配消息，性能差，几乎不用</li><li>fanout：广播方式，发送给所有订阅者</li><li>topic：匹配模式，允许使用正则表达式匹配消息</li></ul><p>RabbitMQ 默认的是 direct 方式。</p><h4 id="RabbitMQ-如何确保每个消息能被消费？"><a href="#RabbitMQ-如何确保每个消息能被消费？" class="headerlink" title="RabbitMQ 如何确保每个消息能被消费？"></a>RabbitMQ 如何确保每个消息能被消费？</h4><p>答：RabbitMQ 使用 ack 消息确认的方式保证每个消息都能被消费，开发者可根据自己的实际业务，选择 channel.basicAck() 方法手动确认消息被消费。</p><h4 id="RabbitMQ-接收到消息之后必须消费吗？"><a href="#RabbitMQ-接收到消息之后必须消费吗？" class="headerlink" title="RabbitMQ 接收到消息之后必须消费吗？"></a>RabbitMQ 接收到消息之后必须消费吗？</h4><p>答：RabbitMQ 接收到消息之后可以不消费，在消息确认消费之前，可以做以下两件事：</p><ul><li>拒绝消息消费，使用 channel.basicReject(消息编号, true) 方法，消息会被分配给其他订阅者；</li><li>设置为死信队列，死信队列是用于专门存放被拒绝的消息队列。</li></ul><h4 id="topic-模式下发布了一个路由键为“com-mq-rabbit-error”的消息，请问以下不能接收到消息的是？"><a href="#topic-模式下发布了一个路由键为“com-mq-rabbit-error”的消息，请问以下不能接收到消息的是？" class="headerlink" title="topic 模式下发布了一个路由键为“com.mq.rabbit.error”的消息，请问以下不能接收到消息的是？"></a>topic 模式下发布了一个路由键为“com.mq.rabbit.error”的消息，请问以下不能接收到消息的是？</h4><p>A：cn.mq.rabbit.*<br>B：#.error<br>C：cn.mq.*<br>D：cn.mq.#</p><p>答：C</p><p>题目解析：“*”用于匹配一个分段（用“.”分割）的内容，“#”用于匹配 0 和多个字符。</p><h4 id="以下可以获取历史消息的是？"><a href="#以下可以获取历史消息的是？" class="headerlink" title="以下可以获取历史消息的是？"></a>以下可以获取历史消息的是？</h4><p>A：topic 交换器<br>B：fanout 交换器<br>C：direct 交换器<br>D：以上都不是</p><p>答：C</p><p>题目解析：fanout 和 topic 都是广播形式的，因此无法获取历史消息，而 direct 可以。</p><h4 id="RabbitMQ-包含事务功能吗？如何使用？"><a href="#RabbitMQ-包含事务功能吗？如何使用？" class="headerlink" title="RabbitMQ 包含事务功能吗？如何使用？"></a>RabbitMQ 包含事务功能吗？如何使用？</h4><p>答：RabbitMQ 包含事务功能，主要是对信道（Channel）的设置，主要方法有以下三个：</p><ul><li>channel.txSelect() 声明启动事务模式；</li><li>channel.txComment() 提交事务；</li><li>channel.txRollback() 回滚事务。</li></ul><h4 id="RabbitMQ-的事务在什么情况下是无效的？"><a href="#RabbitMQ-的事务在什么情况下是无效的？" class="headerlink" title="RabbitMQ 的事务在什么情况下是无效的？"></a>RabbitMQ 的事务在什么情况下是无效的？</h4><p>答：RabbitMQ 的事务在 autoAck=true 也就是自动消费确认的时候，事务是无效的。因为如果是自动消费确认，RabbitMQ 会直接把消息从队列中移除，即使后面事务回滚也不能起到任何作用。</p><h4 id="Kafka-可以脱离-ZooKeeper-单独使用吗？"><a href="#Kafka-可以脱离-ZooKeeper-单独使用吗？" class="headerlink" title="Kafka 可以脱离 ZooKeeper 单独使用吗？"></a>Kafka 可以脱离 ZooKeeper 单独使用吗？</h4><p>答：Kafka 不能脱离 ZooKeeper 单独使用，因为 Kafka 使用 ZooKeeper 管理和协调 Kafka 的节点服务器。</p><h4 id="Kafka-有几种数据保留的策略？"><a href="#Kafka-有几种数据保留的策略？" class="headerlink" title="Kafka 有几种数据保留的策略？"></a>Kafka 有几种数据保留的策略？</h4><p>答：Kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p><h4 id="Kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-Kafka-将如何处理？"><a href="#Kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-Kafka-将如何处理？" class="headerlink" title="Kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 Kafka 将如何处理？"></a>Kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 Kafka 将如何处理？</h4><p>答：这个时候 Kafka 会执行数据清除工作，时间和大小不论哪个满足条件，都会清空数据。</p><h4 id="什么情况会导致-Kafka-运行变慢？"><a href="#什么情况会导致-Kafka-运行变慢？" class="headerlink" title="什么情况会导致 Kafka 运行变慢？"></a>什么情况会导致 Kafka 运行变慢？</h4><p>答：以下情况可导致 Kafka 运行变慢：</p><ul><li>CPU 性能瓶颈</li><li>磁盘读写瓶颈</li><li>网络瓶颈</li></ul><h4 id="使用-Kafka-集群需要注意什么？"><a href="#使用-Kafka-集群需要注意什么？" class="headerlink" title="使用 Kafka 集群需要注意什么？"></a>使用 Kafka 集群需要注意什么？</h4><p>答：Kafka 集群使用需要注意以下事项：</p><ul><li>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低；</li><li>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</li></ul><h2 id="Java-分布式框架面试题合集"><a href="#Java-分布式框架面试题合集" class="headerlink" title="Java 分布式框架面试题合集"></a>Java 分布式框架面试题合集</h2><h4 id="什么是-ZooKeeper？"><a href="#什么是-ZooKeeper？" class="headerlink" title="什么是 ZooKeeper？"></a>什么是 ZooKeeper？</h4><p>答：ZooKeeper 是一个开源的分布式应用程序协调服务，是一个典型的分布式数据一致性解决方案。设计目的是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的系统，并以一系列简单易用的原子操作提供给用户使用。</p><h4 id="ZooKeeper-提供了哪些功能？"><a href="#ZooKeeper-提供了哪些功能？" class="headerlink" title="ZooKeeper 提供了哪些功能？"></a>ZooKeeper 提供了哪些功能？</h4><p>答：ZooKeeper 主要提供以下功能：</p><ul><li>分布式服务注册与订阅：在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就须要在这些对等的服务器中选择一个来执行相关的业务逻辑，比较典型的服务注册与订阅，如 Dubbo。</li><li>分布式配置中心：发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到 ZooKeeper 节点上，供订阅者获取数据，实现配置信息的集中式管理和动态更新。</li><li>命名服务：在分布式系统中，通过命名服务客户端应用能够根据指定名字来获取资源、服务地址和提供者等信息。</li><li>分布式锁：这个主要得益于 ZooKeeper 为我们保证了数据的强一致性。</li></ul><h4 id="ZooKeeper-有几种搭建模式？"><a href="#ZooKeeper-有几种搭建模式？" class="headerlink" title="ZooKeeper 有几种搭建模式？"></a>ZooKeeper 有几种搭建模式？</h4><p>答：ZooKeeper 通常有三种搭建模式：</p><ul><li>单机模式：zoo.cfg 中只配置一个 server.id 就是单机模式了，此模式一般用在测试环境，如果当前主机宕机，那么所有依赖于当前 ZooKeeper 服务工作的其他服务器都不能进行正常工作；</li><li>伪分布式模式：在一台机器启动不同端口的 ZooKeeper，配置到 zoo.cfg 中，和单机模式相同，此模式一般用在测试环境；</li><li>分布式模式：多台机器各自配置 zoo.cfg 文件，将各自互相加入服务器列表，上面搭建的集群就是这种完全分布式。</li></ul><h4 id="ZooKeeper-有哪些特性？"><a href="#ZooKeeper-有哪些特性？" class="headerlink" title="ZooKeeper 有哪些特性？"></a>ZooKeeper 有哪些特性？</h4><p>答： ZooKeeper 特性如下：</p><ul><li>顺序一致性（Sequential Consistency）：来自相同客户端提交的事务，ZooKeeper 将严格按照其提交顺序依次执行；</li><li>原子性（Atomicity）：于 ZooKeeper 集群中提交事务，事务将“全部完成”或“全部未完成”，不存在“部分完成”；</li><li>单一系统镜像（Single System Image）：客户端连接到 ZooKeeper 集群的任意节点，其获得的数据视图都是相同的；</li><li>可靠性（Reliability）：事务一旦完成，其产生的状态变化将永久保留，直到其他事务进行覆盖；</li><li>实时性（Timeliness）：事务一旦完成，客户端将于限定的时间段内，获得最新的数据。</li></ul><h4 id="以下关于-ZooKeeper-描述错误的是？"><a href="#以下关于-ZooKeeper-描述错误的是？" class="headerlink" title="以下关于 ZooKeeper 描述错误的是？"></a>以下关于 ZooKeeper 描述错误的是？</h4><p>A：所有的节点都具有稳定的存储能力 B：ZooKeeper 任意节点之间都能够进行通信（消息发送 &amp; 接收） C：为了提高性能，ZooKeeper 允许同一份数据存在一部分节点写成功，另一部分节点写失败 D：ZooKeeper 集群运行期间，只要半数以上节点存活，ZooKeeper 就能正常服务 答：C 题目解析：ZooKeeper 不允许同一份数据存在一部分节点写成功，另一部分节点写失败的情况，这不符合 ZooKeeper“一致性”的原则。</p><h4 id="ZooKeeper-如何实现分布式锁？"><a href="#ZooKeeper-如何实现分布式锁？" class="headerlink" title="ZooKeeper 如何实现分布式锁？"></a>ZooKeeper 如何实现分布式锁？</h4><p>答：ZooKeeper 实现分布式锁的步骤如下：</p><ul><li>客户端连接 ZooKeeper，并在 /lock 下创建临时的且有序的子节点，第一个客户端对应的子节点为 /lock/lock-10000000001，第二个为 /lock/lock-10000000002，以此类推。</li><li>客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，否则监听刚好在自己之前一位的子节点删除消息，获得子节点变更通知后重复此步骤直至获得锁；</li><li>执行业务代码；</li><li>完成业务流程后，删除对应的子节点释放锁。</li></ul><p>整体流程如下图所示：</p><p><img src="/" alt="1" class="lazyload" data-src="https://images.gitbook.cn/a7143b40-db48-11e9-9f9d-c526a5f387ab"></p><h4 id="ZooKeeper-如何实现分布式事务？"><a href="#ZooKeeper-如何实现分布式事务？" class="headerlink" title="ZooKeeper 如何实现分布式事务？"></a>ZooKeeper 如何实现分布式事务？</h4><p>答：ZooKeeper 实现分布式事务，类似于两阶段提交，总共分为以下 4 步：</p><ul><li>客户端先给 ZooKeeper 节点发送写请求；</li><li>ZooKeeper 节点将写请求转发给 Leader 节点，Leader 广播给集群要求投票，等待确认；</li><li>Leader 收到确认，统计投票，票数过半则提交事务；</li><li>事务提交成功后，ZooKeeper 节点告知客户端。</li></ul><h4 id="集群中为什么要有主节点？"><a href="#集群中为什么要有主节点？" class="headerlink" title="集群中为什么要有主节点？"></a>集群中为什么要有主节点？</h4><p>答：在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，这就是主节点存在的意义。</p><h4 id="Dubbo-是什么？"><a href="#Dubbo-是什么？" class="headerlink" title="Dubbo 是什么？"></a>Dubbo 是什么？</h4><p>答：Dubbo 是一款高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p><h4 id="Dubbo-有哪些特性？"><a href="#Dubbo-有哪些特性？" class="headerlink" title="Dubbo 有哪些特性？"></a>Dubbo 有哪些特性？</h4><p>答：Dubbo 特性如下：</p><ul><li>面向接口代理的高性能 RPC 调用：提供高性能的基于代理的远程调用能力，服务以接口为粒度，为开发者屏蔽远程调用底层细节；</li><li>智能负载均衡：内置多种负载均衡策略，智能感知下游节点健康状况，显著减少调用延迟，提高系统吞吐量；</li><li>服务自动注册与发现：支持多种注册中心服务，服务实例上下线实时感知；</li><li>高度可扩展能力：遵循微内核+插件的设计原则，所有核心能力如 Protocol、Transport、Serialization 被设计为扩展点，平等对待内置实现和第三方实现；</li><li>运行期流量调度：内置条件、脚本等路由策略，通过配置不同的路由规则，轻松实现灰度发布，同机房优先等功能；</li><li>可视化的服务治理与运维：提供丰富服务治理、运维工具：随时查询服务元数据、服务健康状态及调用统计，实时下发路由策略、调整配置参数。</li></ul><h4 id="Dubbo-有哪些核心组件？"><a href="#Dubbo-有哪些核心组件？" class="headerlink" title="Dubbo 有哪些核心组件？"></a>Dubbo 有哪些核心组件？</h4><p>答：Dubbo 核心组件如下：</p><ul><li>Provider：服务提供方</li><li>Consumer：服务消费方</li><li>Registry：服务注册与发现的注册中心</li><li>Monitor：主要用来统计服务的调用次数和调用时间</li><li>Container：服务的运行容器</li></ul><h4 id="Dubbo-有哪些负载均衡策略？"><a href="#Dubbo-有哪些负载均衡策略？" class="headerlink" title="Dubbo 有哪些负载均衡策略？"></a>Dubbo 有哪些负载均衡策略？</h4><p>答：Dubbo 负责均衡策略如下：</p><ul><li>随机负载均衡（Random LoadBalance）：按权重设置随机概率，在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重；</li><li>轮询负载均衡（RoundRobin LoadBalance）：按公约后的权重设置轮询比率，存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上；</li><li>最少活跃调用数负载均衡（LeastActive LoadBalance）：使用最少活跃调用数，活跃数指调用前后计数差；</li><li>哈希负载均衡（ConsistentHash LoadBalance）：使用哈希值转发，相同参数的请求总是发到同一提供者。</li></ul><p><strong>负载均衡配置如下</strong>：</p><p>服务端服务级别</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;roundrobin&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>客户端服务级别</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;roundrobin&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>服务端方法级别</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;roundrobin&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure><p>客户端方法级别</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;roundrobin&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Dubbo-不支持以下哪种协议？"><a href="#Dubbo-不支持以下哪种协议？" class="headerlink" title="Dubbo 不支持以下哪种协议？"></a>Dubbo 不支持以下哪种协议？</h4><p>A：dubbo://<br>B：rmi://<br>C：redis://<br>D：restful://</p><p>答：D</p><p>题目解析：restful 是一种编程规范，并不是一种传输协议，也不被 Dubbo 支持。</p><h4 id="Dubbo-默认使用什么注册中心，还有别的选择吗？"><a href="#Dubbo-默认使用什么注册中心，还有别的选择吗？" class="headerlink" title="Dubbo 默认使用什么注册中心，还有别的选择吗？"></a>Dubbo 默认使用什么注册中心，还有别的选择吗？</h4><p>答：推荐使用 ZooKeeper 作为注册中心，还有 Nacos、Redis、Simple 注册中心（普通的 Dubbo 服务）。</p><h4 id="Dubbo-支持多注册中心吗？"><a href="#Dubbo-支持多注册中心吗？" class="headerlink" title="Dubbo 支持多注册中心吗？"></a>Dubbo 支持多注册中心吗？</h4><p>答：Dubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。</p><p>多注册中心注册：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://dubbo.apache.org/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;world&quot;</span>  /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多注册中心配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;hangzhouRegistry&quot;</span> <span class="attr">address</span>=<span class="string">&quot;10.20.141.150:9090&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">id</span>=<span class="string">&quot;qingdaoRegistry&quot;</span> <span class="attr">address</span>=<span class="string">&quot;10.20.141.151:9010&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 向多个注册中心注册 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.alibaba.hello.api.HelloService&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">registry</span>=<span class="string">&quot;hangzhouRegistry,qingdaoRegistry&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Dubbo-支持的连接方式有哪些？"><a href="#Dubbo-支持的连接方式有哪些？" class="headerlink" title="Dubbo 支持的连接方式有哪些？"></a>Dubbo 支持的连接方式有哪些？</h4><p>答：Dubbo 支持的主要连接方式有：组播、直连和 ZooKeeper 等注册中心。</p><p><strong>① 组播方式</strong>，不需要启动任何中心节点，只要广播地址一样，就可以互相发现。</p><p><img src="/" alt="2" class="lazyload" data-src="https://images.gitbook.cn/e3086fe0-db48-11e9-9f9d-c526a5f387ab"></p><ol><li>提供方启动时广播自己的地址</li><li>消费方启动时广播订阅请求</li><li>提供方收到订阅请求时，单播自己的地址给订阅者，如果设置了 unicast=false，则广播给订阅者</li><li>消费方收到提供方地址时，连接该地址进行 RPC 调用</li></ol><p>组播受网络结构限制，只适合小规模应用或开发阶段使用。组播地址段：224.0.0.0 ~ 239.255.255.255</p><p>配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:registry address&#x3D;&quot;multicast:&#x2F;&#x2F;224.5.6.7:1234&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:registry protocol&#x3D;&quot;multicast&quot; address&#x3D;&quot;224.5.6.7:1234&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>为了减少广播量，Dubbo 缺省使用单播发送提供者地址信息给消费者，如果一个机器上同时启了多个消费者进程，消费者需声明 unicast=false，否则只会有一个消费者能收到消息；当服务者和消费者运行在同一台机器上，消费者同样需要声明 unicast=false，否则消费者无法收到消息，导致 No provider available for the service 异常：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:registry address&#x3D;&quot;multicast:&#x2F;&#x2F;224.5.6.7:1234?unicast&#x3D;false&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:registry protocol&#x3D;&quot;multicast&quot; address&#x3D;&quot;224.5.6.7:1234&quot;&gt;</span><br><span class="line">    &lt;dubbo:parameter key&#x3D;&quot;unicast&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dubbo:registry&gt;</span><br></pre></td></tr></table></figure><p><strong>② 直连方式</strong>，注册中心本身就是一个普通的 Dubbo 服务，可以减少第三方依赖，使整体通讯方式一致。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">&quot;zookeeper&quot;</span> <span class="attr">address</span>=<span class="string">&quot;N/A&quot;</span>  <span class="attr">file</span>=<span class="string">&quot;./.dubbo-platform&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>将 Simple 注册中心暴露成 Dubbo 服务：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:dubbo&#x3D;&quot;http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-4.3.xsd http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo http:&#x2F;&#x2F;dubbo.apache.org&#x2F;schema&#x2F;dubbo&#x2F;dubbo.xsd&quot;&gt;</span><br><span class="line">    &lt;!-- 当前应用信息配置 --&gt;</span><br><span class="line">    &lt;dubbo:application name&#x3D;&quot;simple-registry&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- 暴露服务协议配置 --&gt;</span><br><span class="line">    &lt;dubbo:protocol port&#x3D;&quot;9090&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- 暴露服务配置 --&gt;</span><br><span class="line">    &lt;dubbo:service interface&#x3D;&quot;org.apache.dubbo.registry.RegistryService&quot; ref&#x3D;&quot;registryService&quot; registry&#x3D;&quot;N&#x2F;A&quot; ondisconnect&#x3D;&quot;disconnect&quot; callbacks&#x3D;&quot;1000&quot;&gt;</span><br><span class="line">        &lt;dubbo:method name&#x3D;&quot;subscribe&quot;&gt;&lt;dubbo:argument index&#x3D;&quot;1&quot; callback&#x3D;&quot;true&quot; &#x2F;&gt;&lt;&#x2F;dubbo:method&gt;</span><br><span class="line">        &lt;dubbo:method name&#x3D;&quot;unsubscribe&quot;&gt;&lt;dubbo:argument index&#x3D;&quot;1&quot; callback&#x3D;&quot;false&quot; &#x2F;&gt;&lt;&#x2F;dubbo:method&gt;</span><br><span class="line">    &lt;&#x2F;dubbo:service&gt;</span><br><span class="line">    &lt;!-- 简单注册中心实现，可自行扩展实现集群和状态同步 --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;registryService&quot; class&#x3D;&quot;org.apache.dubbo.registry.simple.SimpleRegistryService&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><p>引用 Simple Registry 服务：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:registry address&#x3D;&quot;127.0.0.1:9090&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:service interface&#x3D;&quot;org.apache.dubbo.registry.RegistryService&quot; group&#x3D;&quot;simple&quot; version&#x3D;&quot;1.0.0&quot; ... &gt;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:registry address&#x3D;&quot;127.0.0.1:9090&quot; group&#x3D;&quot;simple&quot; version&#x3D;&quot;1.0.0&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>适用性说明：此 SimpleRegistryService 只是简单实现，不支持集群，可作为自定义注册中心的参考，但不适合直接用于生产环境。</p><p><strong>③ ZooKeeper 注册中心</strong>，Zookeeper 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。</p><p><img src="/" alt="3" class="lazyload" data-src="https://images.gitbook.cn/1c638310-db49-11e9-b7e8-efbebe7dfdf6"></p><p>流程说明：</p><ul><li>服务提供者启动时：向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址</li><li>服务消费者启动时：订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址，并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址</li><li>监控中心启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址</li></ul><p>支持以下功能：</p><ul><li>当提供者出现断电等异常停机时，注册中心能自动删除提供者信息</li><li>当注册中心重启时，能自动恢复注册数据，以及订阅请求</li><li>当会话过期时，能自动恢复注册数据，以及订阅请求</li><li>当设置 <code>&lt;dubbo:registry check=&quot;false&quot; /&gt;</code> 时，记录失败注册和订阅请求，后台定时重试</li><li>可通过 <code>&lt;dubbo:registry username=&quot;admin&quot; password=&quot;1234&quot; /&gt;</code> 设置 zookeeper 登录信息</li><li>可通过 <code>&lt;dubbo:registry group=&quot;dubbo&quot; /&gt;</code> 设置 zookeeper 的根节点，不设置将使用无根树</li><li>支持 <code>*</code> 号通配符 <code>&lt;dubbo:reference group=&quot;*&quot; version=&quot;*&quot; /&gt;</code>，可订阅服务的所有分组和所有版本的提供者</li></ul><p><strong>Zookeeper 使用</strong></p><p>在 provider 和 consumer 中增加 zookeeper 客户端 jar 包依赖：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.zookeeper&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zookeeper&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.3&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>Dubbo 支持 zkclient 和 curator 两种 Zookeeper 客户端实现：</p><blockquote><p>注意：在 2.7.x 的版本中已经移除了 zkclient 的实现，如果要使用 zkclient 客户端，需要自行拓展。</p></blockquote><p><strong>使用 zkclient 客户端</strong></p><p>从 2.2.0 版本开始缺省为 zkclient 实现，以提升 zookeeper 客户端的健状性。<a href="https://github.com/sgroschupf/zkclient">zkclient</a> 是 Datameer 开源的一个 Zookeeper 客户端实现。</p><p>缺省配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:registry ... client&#x3D;&quot;zkclient&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dubbo.registry.client&#x3D;zkclient</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zookeeper:&#x2F;&#x2F;10.20.153.10:2181?client&#x3D;zkclient</span><br></pre></td></tr></table></figure><p>需依赖或直接<a href="http://repo1.maven.org/maven2/com/github/sgroschupf/zkclient">下载</a>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.sgroschupf&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;zkclient&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>使用 curator 客户端</strong></p><p>从 2.3.0 版本开始支持可选 curator 实现。Curator 是 Netflix 开源的一个 Zookeeper 客户端实现。</p><p>如果需要改为 curator 实现，请配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:registry ... client&#x3D;&quot;curator&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dubbo.registry.client&#x3D;curator</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zookeeper:&#x2F;&#x2F;10.20.153.10:2181?client&#x3D;curator</span><br></pre></td></tr></table></figure><p>需依赖或直接下载：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.curator&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.10&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>Zookeeper 单机配置:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;10.20.153.10:2181&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;10.20.153.10:2181&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>Zookeeper 集群配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:registry address&#x3D;&quot;zookeeper:&#x2F;&#x2F;10.20.153.10:2181?backup&#x3D;10.20.153.11:2181,10.20.153.12:2181&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;10.20.153.10:2181,10.20.153.11:2181,10.20.153.12:2181&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>同一 Zookeeper，分成多组注册中心：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:registry id&#x3D;&quot;chinaRegistry&quot; protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;10.20.153.10:2181&quot; group&#x3D;&quot;china&quot; &#x2F;&gt;</span><br><span class="line">&lt;dubbo:registry id&#x3D;&quot;intlRegistry&quot; protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;10.20.153.10:2181&quot; group&#x3D;&quot;intl&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><h4 id="什么是服务熔断？"><a href="#什么是服务熔断？" class="headerlink" title="什么是服务熔断？"></a>什么是服务熔断？</h4><p>答：在应用系统服务中，当依赖服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，临时切断对下游服务的调用。这种牺牲局部，保全整体的措施就叫做熔断。</p><h4 id="Dubbo-可以对结果进行缓存吗？支持的缓存类型都有哪些？"><a href="#Dubbo-可以对结果进行缓存吗？支持的缓存类型都有哪些？" class="headerlink" title="Dubbo 可以对结果进行缓存吗？支持的缓存类型都有哪些？"></a>Dubbo 可以对结果进行缓存吗？支持的缓存类型都有哪些？</h4><p>答：可以，Dubbo 提供了声明式缓存，用于加速热门数据的访问速度，以减少用户加缓存的工作量。</p><p>Dubbo 支持的缓存类型有：</p><ul><li>lru 基于最近最少使用原则删除多余缓存，保持最热的数据被缓存；</li><li>threadlocal 当前线程缓存，比如一个页面渲染，用到很多 portal，每个 portal 都要去查用户信息，通过线程缓存，可以减少这种多余访问；</li><li>jcache 集成，可以桥接各种缓存实现。</li></ul><p>配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span> <span class="attr">cache</span>=<span class="string">&quot;lru&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;com.foo.BarService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;findBar&quot;</span> <span class="attr">cache</span>=<span class="string">&quot;lru&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Dubbo-有几种集群容错模式？"><a href="#Dubbo-有几种集群容错模式？" class="headerlink" title="Dubbo 有几种集群容错模式？"></a>Dubbo 有几种集群容错模式？</h4><p>答：Dubbo 集群容错模式如下。</p><h5 id="Failover-Cluster"><a href="#Failover-Cluster" class="headerlink" title="Failover Cluster"></a>Failover Cluster</h5><p>失败自动切换，当出现失败，重试其他服务器。通常用于读操作，但重试会带来更长延迟。可通过 <code>retries=&quot;2&quot;</code> 来设置重试次数（不含第一次）。</p><p>重试次数配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;findFoo&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="Failfast-Cluster"><a href="#Failfast-Cluster" class="headerlink" title="Failfast Cluster"></a>Failfast Cluster</h5><p>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p><h5 id="Failsafe-Cluster"><a href="#Failsafe-Cluster" class="headerlink" title="Failsafe Cluster"></a>Failsafe Cluster</h5><p>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p><h5 id="Failback-Cluster"><a href="#Failback-Cluster" class="headerlink" title="Failback Cluster"></a>Failback Cluster</h5><p>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p><h5 id="Forking-Cluster"><a href="#Forking-Cluster" class="headerlink" title="Forking Cluster"></a>Forking Cluster</h5><p>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2” 来设置最大并行数。</p><h5 id="Broadcast-Cluster"><a href="#Broadcast-Cluster" class="headerlink" title="Broadcast Cluster"></a>Broadcast Cluster</h5><p>广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p><h2 id="MySQL-面试题汇总"><a href="#MySQL-面试题汇总" class="headerlink" title="MySQL 面试题汇总"></a>MySQL 面试题汇总</h2><h4 id="说一下-MySQL-执行一条查询语句的内部执行过程？"><a href="#说一下-MySQL-执行一条查询语句的内部执行过程？" class="headerlink" title="说一下 MySQL 执行一条查询语句的内部执行过程？"></a>说一下 MySQL 执行一条查询语句的内部执行过程？</h4><p>答：MySQL 执行一条查询的流程如下：</p><ul><li>客户端先通过连接器连接到 MySQL 服务器；</li><li>连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器；</li><li>分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器；</li><li>优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好；</li><li>优化器执行完就进入执行器，执行器则开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。</li></ul><h4 id="MySQL-查询缓存有什么优缺点？"><a href="#MySQL-查询缓存有什么优缺点？" class="headerlink" title="MySQL 查询缓存有什么优缺点？"></a>MySQL 查询缓存有什么优缺点？</h4><p>答：MySQL 查询缓存功能是在连接器之后发生的，它的优点是效率高，如果已经有缓存则会直接返回结果。</p><p>查询缓存的缺点是失效太频繁导致缓存命中率比较低，任何更新表操作都会清空查询缓存，因此导致查询缓存非常容易失效。</p><h4 id="MySQL-的常用引擎都有哪些？"><a href="#MySQL-的常用引擎都有哪些？" class="headerlink" title="MySQL 的常用引擎都有哪些？"></a>MySQL 的常用引擎都有哪些？</h4><p>答：MySQL 的常用引擎有 InnoDB、MyISAM、Memory 等，从 MySQL 5.5.5 版本开始 InnoDB 就成为了默认的存储引擎。</p><h4 id="常用的存储引擎-InnoDB-和-MyISAM-有什么区别？"><a href="#常用的存储引擎-InnoDB-和-MyISAM-有什么区别？" class="headerlink" title="常用的存储引擎 InnoDB 和 MyISAM 有什么区别？"></a>常用的存储引擎 InnoDB 和 MyISAM 有什么区别？</h4><p>答：InnoDB 和 MyISAM 最大的区别是 InnoDB 支持事务，而 MyISAM 不支持事务，它们其他主要区别如下：</p><ul><li>InnoDB 支持崩溃后安全恢复，MyISAM 不支持崩溃后安全恢复；</li><li>InnoDB 支持行级锁，MyISAM 不支持行级锁，只支持到表锁；</li><li>InnoDB 支持外键，MyISAM 不支持外键；</li><li>MyISAM 性能比 InnoDB 高；</li><li>MyISAM 支持 FULLTEXT 类型的全文索引，InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好；</li><li>InnoDB 主键查询性能高于 MyISAM。</li></ul><h4 id="什么叫回表查询？"><a href="#什么叫回表查询？" class="headerlink" title="什么叫回表查询？"></a>什么叫回表查询？</h4><p>答：普通索引查询到主键索引后，回到主键索引树搜索的过程，我们称为回表查询。</p><h4 id="如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？"><a href="#如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？" class="headerlink" title="如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？"></a>如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？</h4><p>答：不是，如果把主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 作为主键。</p><h4 id="一张自增表中有三条数据，删除两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？"><a href="#一张自增表中有三条数据，删除两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？" class="headerlink" title="一张自增表中有三条数据，删除两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？"></a>一张自增表中有三条数据，删除两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？</h4><p>答：如果这张表的引擎是 MyISAM，那么 ID=4，如果是 InnoDB 那么 ID=2（MySQL 8 之前的版本）。</p><h4 id="什么是独立表空间和共享表空间？它们的区别是什么？"><a href="#什么是独立表空间和共享表空间？它们的区别是什么？" class="headerlink" title="什么是独立表空间和共享表空间？它们的区别是什么？"></a>什么是独立表空间和共享表空间？它们的区别是什么？</h4><p>答：共享表空间指的是数据库的所有表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。</p><p>独立表空间：每一个表都将会生成以独立的文件方式来进行存储。</p><p>共享表空间和独立表空间最大的区别是如果把表放再共享表空间，即使表删除了空间也不会删除，因此表依然很大，而独立表空间如果删除表就会清除空间。</p><h4 id="清空表的所有数据性能最好的语句是？"><a href="#清空表的所有数据性能最好的语句是？" class="headerlink" title="清空表的所有数据性能最好的语句是？"></a>清空表的所有数据性能最好的语句是？</h4><p>A：delete from t<br>B：delete t<br>C：drop table t<br>D：truncate table t</p><p>答：D</p><p>题目解析：truncate 清除表数据不会写日志，delete 要写日志，因此 truncate 的效率要高于 delete。</p><h4 id="唯一索引和普通索引哪个性能更好？"><a href="#唯一索引和普通索引哪个性能更好？" class="headerlink" title="唯一索引和普通索引哪个性能更好？"></a>唯一索引和普通索引哪个性能更好？</h4><p>答：唯一索引和普通索引的性能对比分为以下两种情况：</p><ul><li>对于查询来说两者都是从索引树进行查询，性能几乎没有任何区别；</li><li>对于更新操作来说，因为唯一索引需要先将数据读取到内存，然后需要判断是否有冲突，因此比唯一索引要多了判断操作，从而性能就比普通索引性能要低。</li></ul><h4 id="left-join-和-right-join-的区别是什么？"><a href="#left-join-和-right-join-的区别是什么？" class="headerlink" title="left join 和 right join 的区别是什么？"></a>left join 和 right join 的区别是什么？</h4><p>答：left join 和 right join 的区别如下：</p><ul><li>left join（左联结），返回左表全部记录和右表联结字段相等的记录；</li><li>right join（右联结），返回右表全部记录和左表联结字段相等的记录。</li></ul><h4 id="什么是最左匹配原则？它的生效原则有哪些？"><a href="#什么是最左匹配原则？它的生效原则有哪些？" class="headerlink" title="什么是最左匹配原则？它的生效原则有哪些？"></a>什么是最左匹配原则？它的生效原则有哪些？</h4><p>答：最左匹配原则也叫最左前缀原则，是 MySQL 中的一个重要原则，指的是索引以最左边为起点任何连续的索引都能匹配上，当遇到范围查询（&gt;、&lt;、between、like）就会停止匹配。 生效原则来看以下示例，比如表中有一个联合索引字段 index(a,b,c)：</p><ul><li>where a=1 只使用了索引 a；</li><li>where a=1 and b=2 只使用了索引 a,b；</li><li>where a=1 and b=2 and c=3 使用a,b,c；</li><li>where b=1 or where c=1 不使用索引；</li><li>where a=1 and c=3 只使用了索引 a；</li><li>where a=3 and b like ‘xx%’ and c=3 只使用了索引 a,b。</li></ul><h4 id="以下-or-查询有什么问题吗？该如何优化？"><a href="#以下-or-查询有什么问题吗？该如何优化？" class="headerlink" title="以下 or 查询有什么问题吗？该如何优化？"></a>以下 or 查询有什么问题吗？该如何优化？</h4><blockquote><p>select * from t where num=10 or num=20;</p></blockquote><p>答：如果使用 or 查询会使 MySQL 放弃索引而全表扫描，可以改为：</p><blockquote><p>select * from t where num=10</p><p>union</p><p>select * from t where num=20;</p></blockquote><h4 id="事务是什么？它有什么特性？"><a href="#事务是什么？它有什么特性？" class="headerlink" title="事务是什么？它有什么特性？"></a>事务是什么？它有什么特性？</h4><p>答：事务是一系列的数据库操作，是数据库应用的基本单位。</p><p>在 MySQL 中只有 InnoDB 引擎支持事务，它的四个特性如下：</p><ul><li>原子性（Atomic），要么全部执行，要么全部不执行；</li><li>一致性（Consistency），事务的执行使得数据库从一种正确状态转化为另一种正确状态；</li><li>隔离性（Isolation），在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务；</li><li>持久性（Durability），事务提交后，其结果永久保存在数据库中。</li></ul><h4 id="MySQL-中有几种事务隔离级别？分别是什么？"><a href="#MySQL-中有几种事务隔离级别？分别是什么？" class="headerlink" title="MySQL 中有几种事务隔离级别？分别是什么？"></a>MySQL 中有几种事务隔离级别？分别是什么？</h4><p>答：MySQL 中有四种事务隔离级别，分别是：</p><ul><li>read uncommited，未提交读，读到未提交数据；</li><li>read committed，读已提交，也叫不可重复读，两次读取到的数据不一致；</li><li>repetable read，可重复读；</li><li>serializable，串行化，读写数据都会锁住整张表，数据操作不会出错，但并发性能极低，开发中很少用到。</li></ul><p>MySQL 默认使用 repetable read 的事务隔离级别。</p><h4 id="如何设置-MySQL-的事务隔离级别？"><a href="#如何设置-MySQL-的事务隔离级别？" class="headerlink" title="如何设置 MySQL 的事务隔离级别？"></a>如何设置 MySQL 的事务隔离级别？</h4><p>答：MySQL 事务隔离级别 mysql.cnf 文件里设置的（默认目录 /etc/my.cnf），在文件的文末添加配置：</p><blockquote><p>transaction-isolation = REPEATABLE-READ</p></blockquote><p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p><h4 id="MySQL-出现了中文乱码该如何解决？"><a href="#MySQL-出现了中文乱码该如何解决？" class="headerlink" title="MySQL 出现了中文乱码该如何解决？"></a>MySQL 出现了中文乱码该如何解决？</h4><p>答：解决 MySQL 中文乱码的问题，可以设置全局编码或设置某个数据库或表的编码为 utf8。 设置全局编码：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> character_set_client=<span class="string">&#x27;utf8&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> character_set_connection=<span class="string">&#x27;utf8&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> character_set_results=<span class="string">&#x27;utf8&#x27;</span>;</span><br></pre></td></tr></table></figure><p>设置数据库的编码：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> db <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span><br></pre></td></tr></table></figure><p>设置表的编码：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span><br></pre></td></tr></table></figure><h4 id="InnoDB-为什么要使用-B-树，而不是-B-树、Hash、红黑树或二叉树？"><a href="#InnoDB-为什么要使用-B-树，而不是-B-树、Hash、红黑树或二叉树？" class="headerlink" title="InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？"></a>InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？</h4><p>答：因为 B 树、Hash、红黑树或二叉树存在以下问题。</p><ul><li>B 树：不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低。</li><li>Hash：虽然可以快速定位，但是没有顺序，IO 复杂度高。</li><li>二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且 IO 代价高。</li><li>红黑树：树的高度随着数据量增加而增加，IO 代价高。</li></ul><h4 id="MySQL-是如何处理死锁？"><a href="#MySQL-是如何处理死锁？" class="headerlink" title="MySQL 是如何处理死锁？"></a>MySQL 是如何处理死锁？</h4><p>答：MySQL 对待死锁常见的两种策略：</p><ul><li>通过 innodb_lock_wait_timeout 来设置超时时间，一直等待直到超时；</li><li>发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其他事务继续执行。</li></ul><h4 id="什么是全局锁？它的应用场景有哪些？"><a href="#什么是全局锁？它的应用场景有哪些？" class="headerlink" title="什么是全局锁？它的应用场景有哪些？"></a>什么是全局锁？它的应用场景有哪些？</h4><p>答：全局锁就是对整个数据库实例加锁，它的典型使用场景就是做全量逻辑备份，这个时候整个库会处于完全的只读状态。</p><h4 id="使用全局锁会导致什么问题？"><a href="#使用全局锁会导致什么问题？" class="headerlink" title="使用全局锁会导致什么问题？"></a>使用全局锁会导致什么问题？</h4><p>答：使用全局锁会使整个系统不能执行更新操作，所有的更新业务会出于等待状态；如果你是在从库进行备份，则会导致主从同步严重延迟。</p><h4 id="InnoDB-存储引擎有几种锁算法？"><a href="#InnoDB-存储引擎有几种锁算法？" class="headerlink" title="InnoDB 存储引擎有几种锁算法？"></a>InnoDB 存储引擎有几种锁算法？</h4><p>答：InnoDB 的锁算法包括以下三种：</p><ul><li>Record Lock — 单个行记录上的锁；</li><li>Gap Lock — 间隙锁，锁定一个范围，不包括记录本身；</li><li>Next-Key Lock — 锁定一个范围，包括记录本身。</li></ul><h4 id="InnoDB-如何实现行锁？"><a href="#InnoDB-如何实现行锁？" class="headerlink" title="InnoDB 如何实现行锁？"></a>InnoDB 如何实现行锁？</h4><p>答：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则 InnoDB 将使用表锁。使用 for update 来实现行锁，具体脚本如下：</p><blockquote><p>select * from t where id=1 for update</p></blockquote><p>其中 id 字段必须有索引。</p><h4 id="MySQL-性能指标都有哪些？如何得到这些指标？"><a href="#MySQL-性能指标都有哪些？如何得到这些指标？" class="headerlink" title="MySQL 性能指标都有哪些？如何得到这些指标？"></a>MySQL 性能指标都有哪些？如何得到这些指标？</h4><p>答：MySQL 最重要的性能指标有以下两个：</p><ul><li>QPS（Queries Per Second），每秒查询数，一台数据库每秒能够处理的查询次数；</li><li>TPS（Transactions Per Second），每秒处理事务数。</li></ul><p>这些性能指标可以通过 show status 来查询当前数据库状态的结果信息中估算出来，show status 会有 300 多条状态信息记录，其中以下这些信息 QPS 和 TPS 有关系：</p><ul><li>Uptime，服务器已经运行的时间，单位秒；</li><li>Questions，已经发送给数据库查询数；</li><li>Com_select，查询次数，实际查询次数；</li><li>Com_insert，插入次数；</li><li>Com_delete，删除次数；</li><li>Com_update，更新次数；</li><li>Com_commit，事务次数；</li><li>Com_rollback，回滚次数。</li></ul><h4 id="MySQL-中的重要日志分为哪几个？"><a href="#MySQL-中的重要日志分为哪几个？" class="headerlink" title="MySQL 中的重要日志分为哪几个？"></a>MySQL 中的重要日志分为哪几个？</h4><p><strong>① 错误日志</strong>：用来记录 MySQL 服务器运行过程中的错误信息，比如，无法加载 MySQL 数据库的数据文件，或权限不正确等都会被记录在此，还有复制环境下，从服务器进程的信息也会被记录进错误日志。默认情况下，错误日志是开启的，且无法被禁止。默认情况下，错误日志是存储在数据库的数据文件目录中，名称为 hostname.err，其中 hostname 为服务器主机名。在 MySQL 5.5.7 之前，数据库管理员可以删除很长时间之前的错误日志，以节省服务器上的硬盘空间， MySQL 5.5.7 之后，服务器将关闭此项功能，只能使用重命名原来的错误日志文件，手动冲洗日志创建一个新的，命令为：</p><blockquote><p>mv hostname.err hostname.err.old</p><p>mysqladmin flush-logs</p></blockquote><p><strong>② 查询日志</strong>：查询日志在 MySQL 中被称为 general log（通用日志），查询日志里的内容不要被“查询日志”误导，认为里面只存储 select 语句，其实不然，查询日志里面记录了数据库执行的所有命令，不管语句是否正确，都会被记录，具体原因如下:</p><ul><li>insert 查询为了避免数据冲突，如果此前插入过数据，则当前插入的数据如果跟主键或唯一键的数据重复那肯定会报错；</li><li>update 时也会查询因为更新的时候很可能会更新某一块数据；</li><li>delete 查询，只删除符合条件的数据；</li></ul><p>因此都会产生日志，在并发操作非常多的场景下，查询信息会非常多，那么如果都记录下来会导致 IO 非常大，影响 MySQL 性能。因此如果不是在调试环境下，是不建议开启查询日志功能的。</p><p>查询日志的开启有助于帮助我们分析哪些语句执行密集，执行密集的 select 语句对应的数据是否能够被缓存，同时也可以帮助我们分析问题，因此，可以根据自己的实际情况来决定是否开启查询日志。</p><p>查询日志模式是关闭的，可以通过以下命令开启查询日志：</p><blockquote><p>set global general_log=1</p><p>set global log_output=’table’;</p></blockquote><p>general_log=1 为开启查询日志，0 为关闭查询日志，这个设置命令即时生效，不用重启 MySQL 服务器。</p><p><strong>③ 慢日志</strong>：慢查询会导致 CPU、IOPS、内存消耗过高，当数据库遇到性能瓶颈时，大部分时间都是由于慢查询导致的。开启慢查询日志，可以让 MySQL 记录下查询超过指定时间的语句，之后运维人员通过定位分析，能够很好的优化数据库性能。默认情况下，慢查询日志是不开启的，只有手动开启了，慢查询才会被记录到慢查询日志中。使用如下命令记录当前数据库的慢查询语句：</p><blockquote><p>set global slow_query_log=’ON’;</p></blockquote><p>使用 set global slow_query_log=’ON’ 开启慢查询日志，只是对当前数据库有效，如果 MySQL 数据库重启后就会失效。因此如果要永久生效，就要修改配置文件 my.cnf，设置 slow_query_log=1 并重启 MySQL 服务器。</p><p><strong>④ redo log（重做日志）</strong>：为了最大程度的避免数据写入时，因为 IO 瓶颈造成的性能问题，MySQL 采用了这样一种缓存机制，先将数据写入内存中，再批量把内存中的数据统一刷回磁盘。为了避免将数据刷回磁盘过程中，因为掉电或系统故障带来的数据丢失问题，InnoDB 采用 redo log 来解决此问题。</p><p><strong>⑤ undo log（回滚日志）</strong>：用于存储日志被修改前的值，从而保证如果修改出现异常，可以使用 undo log 日志来实现回滚操作。</p><p>undo log 和 redo log 记录物理日志不一样，它是逻辑日志，可以认为当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录，当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。undo log 默认存放在共享表空间中，在 ySQL 5.6 中，undo log 的存放位置还可以通过变量 innodb_undo_directory 来自定义存放目录，默认值为“.”表示 datadir 目录。</p><p><strong>⑥ bin log（二进制日志）</strong>：是一个二进制文件，主要记录所有数据库表结构变更，比如，CREATE、ALTER TABLE 等，以及表数据修改，比如，INSERT、UPDATE、DELETE 的所有操作，bin log 中记录了对 MySQL 数据库执行更改的所有操作，并且记录了语句发生时间、执行时长、操作数据等其他额外信息，但是它不记录 SELECT、SHOW 等那些不修改数据的 SQL 语句。 binlog 的作用如下：</p><ul><li>恢复（recovery）：某些数据的恢复需要二进制日志。比如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行 point-in-time 的恢复；</li><li>复制（replication）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的 MySQL 数据库（一般称为 slave 或者 standby）与一台 MySQL 数据库（一般称为 master 或者 primary）进行实时同步；</li><li>审计（audit）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。</li></ul><p>除了上面介绍的几个作用外，binlog 对于事务存储引擎的崩溃恢复也有非常重要的作用，在开启 binlog 的情况下，为了保证 binlog 与 redo 的一致性，MySQL 将采用事务的两阶段提交协议。当 MySQL 系统发生崩溃时，事务在存储引擎内部的状态可能为 prepared（准备状态）和 commit（提交状态）两种，对于 prepared 状态的事务，是进行提交操作还是进行回滚操作，这时需要参考 binlog，如果事务在 binlog 中存在，那么将其提交；如果不在 binlog 中存在，那么将其回滚，这样就保证了数据在主库和从库之间的一致性。</p><p>binlog 默认是关闭状态，可以在 MySQL 配置文件（my.cnf）中通过配置参数 log-bin = [base-name] 开启记录 binlog 日志，如果不指定 base-name，则默认二进制日志文件名为主机名，并以自增的数字作为后缀，比如：mysql-bin.000001，所在目录为数据库所在目录（datadir）。</p><p>通过以下命令来查询 binlog 是否开启：</p><blockquote><p>show variables like ‘log_%’;</p></blockquote><p><img src="/" alt="1" class="lazyload" data-src="https://images.gitbook.cn/48857550-df7e-11e9-9b80-07a210d8c96e"></p><p>binlog 格式分为 STATEMENT、ROW 和 MIXED 三种。</p><ul><li>STATEMENT 格式的 binlog 记录的是数据库上执行的原生 SQL 语句。这种格式的优点是简单，简单地记录和执行这些语句，能够让主备保持同步，在主服务器上执行的 SQL 语句，在从服务器上执行同样的语句。另一个好处是二进制日志里的时间更加紧凑，因此相对而言，基于语句的复制模式不会使用太多带宽，同时也节约磁盘空间，并且通过 mysqlbinlog 工具容易读懂其中的内容。缺点就是同一条 SQL 在主库和从库上执行的时间可能稍微或很大不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法被正确复制的 SQL，比如，使用 INSERT INTO TB1 VALUE(CUURENT_DATE()) 这一条使用函数的语句插入的数据复制到当前从服务器上来就会发生变化，存储过程和触发器在使用基于语句的复制模式时也可能存在问题；另外一个问题就是基于语句的复制必须是串行化的，比如，InnoDB 的 next-key 锁等，并不是所有的存储引擎都支持基于语句的复制。</li><li>ROW 格式是从 MySQL 5.1 开始支持基于行的复制，也就是基于数据的复制，基于行的更改。这种方式会将实际数据记录在二进制日志中，它有其自身的一些优点和缺点，最大的好处是可以正确地复制每一行数据，一些语句可以被更加有效地复制，另外就是几乎没有基于行的复制模式无法处理的场景，对于所有的 SQL 构造、触发器、存储过程等都能正确执行；它的缺点就是二进制日志可能会很大，而且不直观，因此，你不能使用 mysqlbinlog 来查看二进制日志，也无法通过看二进制日志判断当前执行到那一条 SQL 语句。现在对于 ROW 格式的二进制日志基本是标配了，主要是因为它的优势远远大于缺点，并且由于 ROW 格式记录行数据，因此可以基于这种模式做一些 DBA 工具，比如数据恢复，不同数据库之间数据同步等。</li><li>MIXED 也是 MySQL 默认使用的二进制日志记录方式，但 MIXED 格式默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。比如用到 UUID()、USER()、CURRENT_USER()、ROW_COUNT() 等无法确定的函数。</li></ul><h4 id="redo-log-和-binlog-有什么区别？"><a href="#redo-log-和-binlog-有什么区别？" class="headerlink" title="redo log 和 binlog 有什么区别？"></a>redo log 和 binlog 有什么区别？</h4><p>redo log（重做日志）和 binlog（归档日志）都是 MySQL 的重要的日志，它们的区别如下：</p><ul><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；</li><li>binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”；</li><li>redo log 是 InnoDB 引擎特有的，binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用；</li><li>redo log 是循环写的，空间固定会用完，binlog 是可以追加写入的，“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ul><p>最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，因此 InnoDB 使用另外一套日志系统，也就是 redo log 来实现 crash-safe 能力。</p><h4 id="慢查询日志的获取方式有哪些？"><a href="#慢查询日志的获取方式有哪些？" class="headerlink" title="慢查询日志的获取方式有哪些？"></a>慢查询日志的获取方式有哪些？</h4><p>答：慢查询日志的常见获取方式如下。</p><ul><li>使用 MySQL 自带功能，开启慢查询日志，在 MySQL 的安装目录下找到 my.cnf 文件设置 <code>slow-query-log=On</code> 开启慢查询，慢查询默认时长为 10s，默认存储文件名为 host_name-slow.log。</li><li>使用三方开源方案 zabbix，zabbix 是一个基于 Web 界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案，能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。</li></ul><h4 id="如何定位慢查询？"><a href="#如何定位慢查询？" class="headerlink" title="如何定位慢查询？"></a>如何定位慢查询？</h4><p>答：使用 MySQL 中的 explain 分析执行语句，比如：</p><blockquote><p>explain select * from t where id=5;</p></blockquote><p>如下图所示：</p><p><img src="/" alt="2" class="lazyload" data-src="https://images.gitbook.cn/5ec8ebd0-df7e-11e9-9b80-07a210d8c96e"></p><p>其中：</p><ul><li>id — 选择标识符，id 越大优先级越高，越先被执行</li><li>select_type — 表示查询的类型。</li><li>table — 输出结果集的表</li><li>partitions — 匹配的分区</li><li>type — 表示表的连接类型</li><li>possible_keys — 表示查询时，可能使用的索引</li><li>key — 表示实际使用的索引</li><li>key_len — 索引字段的长度</li><li>ref— 列与索引的比较</li><li>rows — 大概估算的行数</li><li>filtered — 按表条件过滤的行百分比</li><li>Extra — 执行情况的描述和说明</li></ul><p>其中最重要的就是 type 字段，type 值类型如下：</p><ul><li>all — 扫描全表数据</li><li>index — 遍历索引</li><li>range — 索引范围查找</li><li>index_subquery — 在子查询中使用 ref</li><li>unique_subquery — 在子查询中使用 eq_ref</li><li>ref_or_null — 对 null 进行索引的优化的 ref</li><li>fulltext — 使用全文索引</li><li>ref — 使用非唯一索引查找数据</li><li>eq_ref — 在 join 查询中使用主键或唯一索引关联</li><li>const — 将一个主键放置到 where 后面作为条件查询， MySQL 优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器，这个比 eq_ref 效率高一点</li></ul><h4 id="MySQL-中常见的读写分离方案有哪些？"><a href="#MySQL-中常见的读写分离方案有哪些？" class="headerlink" title="MySQL 中常见的读写分离方案有哪些？"></a>MySQL 中常见的读写分离方案有哪些？</h4><p>答：MySQL 中常见的读写分离方案通常为以下两种：</p><ul><li>使用 MySQL 官方提供的数据库代理产品 MySql ProxySQL 搭建自动分配的数据库读写分离环境；</li><li>在程序层面配置多数据源使用代码实现读写分离。</li></ul><h4 id="怎样保证主备数据库无延迟？"><a href="#怎样保证主备数据库无延迟？" class="headerlink" title="怎样保证主备数据库无延迟？"></a>怎样保证主备数据库无延迟？</h4><p>答：通常保证主备数据库无延迟有以下三种方法。</p><ul><li>每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求，seconds_behind_master 参数是用来衡量主备延迟时间的长短。</li><li>对比位点确保主备无延迟。Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点，Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。</li><li>对比 GTID 集合确保主备无延迟。Auto_Position=1 ，表示这对主备关系使用了 GTID 协议。Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合；Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。</li></ul><h4 id="什么是-MySQL-多实例，如何配置-MySQL-多实例？"><a href="#什么是-MySQL-多实例，如何配置-MySQL-多实例？" class="headerlink" title="什么是 MySQL 多实例，如何配置 MySQL 多实例？"></a>什么是 MySQL 多实例，如何配置 MySQL 多实例？</h4><p>答：MySQL 多实例就是在同一台服务器上启用多个 MySQL 服务，它们监听不同的端口，运行多个服务进程，它们相互独立，互不影响的对外提供服务，便于节约服务器资源与后期架构扩展。 多实例的配置方法有两种：</p><ul><li>一个实例一个配置文件，不同端口；</li><li>同一配置文件（my.cnf）下配置不同实例，基于 MySQL 的 d_multi 工具。</li></ul><h4 id="表的优化策略有哪些？"><a href="#表的优化策略有哪些？" class="headerlink" title="表的优化策略有哪些？"></a>表的优化策略有哪些？</h4><p>「参考答案」常见的大表优化策略如下。</p><ul><li>读写分离，主库负责写，从库负责读。</li><li>垂直分区，根据数据属性单独拆表甚至单独拆库。</li><li>水平分区，保持表结构不变，根据策略存储数据分片，这样每一片数据被分散到不同的表或者库中。水平拆分只是解决了单一表数据过大的问题，表数据还在同一台机器上，对于并发能力没有什么意义，因此水平拆分最好分库。另外分片事务难以解决，跨节点 join 性能较差。</li></ul><h4 id="数据库分片方案有哪些？"><a href="#数据库分片方案有哪些？" class="headerlink" title="数据库分片方案有哪些？"></a>数据库分片方案有哪些？</h4><p>「参考答案」数据库分片方案有哪些？ 答：数据库创建的分片方案有两种方式：客户端代理方式和中间件代理方式。</p><ul><li>客户端代理 — 分片逻辑在应用端，封装在 jar 包中，通过修改或者封装 JDBC 层来实现，比如 Sharding-JDBC、阿里 TDDL 等。</li><li>中间件代理 — 在应用层和数据层中间加了一个代理层。分片逻辑统一维护在中间件服务中，比如 MyCat、网易的 DDB 都是中间件代理的典型代表。</li></ul><h4 id="查询语句的优化方案有哪些？"><a href="#查询语句的优化方案有哪些？" class="headerlink" title="查询语句的优化方案有哪些？"></a>查询语句的优化方案有哪些？</h4><p>「参考答案」常见优化方案如下：</p><ul><li>不做列运算，把计算都放入各个业务系统实现；</li><li>查询语句尽可能简单，大语句拆小语句，减少锁时间；</li><li>不使用 select * 查询；</li><li>or 查询改写成 in 查询；</li><li>不用函数和触发器；</li><li>避免 %xx 查询；</li><li>少用 join 查询；</li><li>使用同类型比较，比如 ‘123’ 和 ‘123’、123 和 123；</li><li>尽量避免在 where 子句中使用 != 或者 &lt;&gt; 操作符，查询引用会放弃索引而进行全表扫描；</li><li>列表数据使用分页查询，每页数据量不要太大。</li></ul><h4 id="MySQL-毫无规律的异常重启，可能产生的原因是什么？该如何解决？"><a href="#MySQL-毫无规律的异常重启，可能产生的原因是什么？该如何解决？" class="headerlink" title="MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？"></a>MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？</h4><p>「参考答案」可能是积累的长连接导致内存占用太多，被系统强行杀掉导致的异常重启，因为在 MySQL 中长连接在执行过程中使用的临时内存对象，只有在连接断开的时候才会释放，这就会导致内存不断飙升，解决方案如下：</p><ul><li>定期断开空闲的长连接；</li><li>如果是用的是 MySQL 5.7 以上的版本，可以定期执行 mysql_reset_connection 重新初始化连接资源，这个过程会释放之前使用的内存资源，恢复到连接刚初始化的状态。</li></ul><h2 id="Redis-面试题汇总"><a href="#Redis-面试题汇总" class="headerlink" title="Redis 面试题汇总"></a>Redis 面试题汇总</h2><h4 id="Redis-使用场景有哪些？"><a href="#Redis-使用场景有哪些？" class="headerlink" title="Redis 使用场景有哪些？"></a>Redis 使用场景有哪些？</h4><p>答：Redis 使用场景如下：</p><ul><li>记录帖子点赞数、点击数、评论数</li><li>缓存近期热帖</li><li>缓存文章详情信息</li><li>记录用户会话信息</li></ul><h4 id="Redis-有哪些功能？"><a href="#Redis-有哪些功能？" class="headerlink" title="Redis 有哪些功能？"></a>Redis 有哪些功能？</h4><p>答：Redis 功能如下：</p><ul><li>数据缓存功能</li><li>分布式锁的功能</li><li>支持数据持久化</li><li>支持事务</li><li>支持消息队列</li></ul><h4 id="Redis-支持哪些数据类型？"><a href="#Redis-支持哪些数据类型？" class="headerlink" title="Redis 支持哪些数据类型？"></a>Redis 支持哪些数据类型？</h4><p>答：Redis 支持的数据类型如下：</p><ul><li>String 字符串</li><li>List 列表</li><li>Set 无序集合</li><li>ZSet 有序集合</li><li>Hash 哈希类型</li></ul><h4 id="Redis-相比-Memcached-有哪些优势？"><a href="#Redis-相比-Memcached-有哪些优势？" class="headerlink" title="Redis 相比 Memcached 有哪些优势？"></a>Redis 相比 Memcached 有哪些优势？</h4><p>答：Redis 相比 Memcached 优势如下：</p><ul><li>Memcached 所有的值均是简单的字符串，Redis 支持更为丰富的数据类型</li><li>Redis 的速度比 Memcached 要快</li><li>Redis 可以持久化</li><li>Redis 可以设置过期时间</li><li>Redis 支持主从同步</li></ul><h4 id="Redis-支持哪些淘汰策略？"><a href="#Redis-支持哪些淘汰策略？" class="headerlink" title="Redis 支持哪些淘汰策略？"></a>Redis 支持哪些淘汰策略？</h4><p>答：Redis 淘汰策略如下：</p><ul><li>noeviction：禁止淘汰数据；</li><li>allkeys-lru：尝试回收最少使用的键，使得新添加的数据有空间存放；</li><li>volatile-lru：尝试回收最少使用的键，但仅限于在过期集合的键，使得新添加的数据有空间存放；</li><li>allkeys-random：回收随机的键使得新添加的数据有空间存放；</li><li>volatile-random：回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键；</li><li>volatile-ttl：回收在过期集合的键，并且优先回收存活时间较短的键，使得新添加的数据有空间存放。</li></ul><h4 id="官方为什么不支持-Windows-版本？"><a href="#官方为什么不支持-Windows-版本？" class="headerlink" title="官方为什么不支持 Windows 版本？"></a>官方为什么不支持 Windows 版本？</h4><p>答：Redis 官方是不支持 Windows 版的，因为目前 Linux 版本已经相当稳定，如果开发 Windows 版本，反而会带来兼容性等问题。</p><h4 id="为什么-Redis-是单线程的？"><a href="#为什么-Redis-是单线程的？" class="headerlink" title="为什么 Redis 是单线程的？"></a>为什么 Redis 是单线程的？</h4><p>答：因为 Redis 的瓶颈最有可能是机器内存或者网络带宽，而非单线程，既然单线程不是 Redis 的性能瓶颈，并且单线程又比较容易实现，所以 Redis 就选择使用单线程来实现。</p><p>单线程并不代表运行速度就慢，比如，Nginx 和 NodeJs 都是单线程高性能的代表。</p><h4 id="为什么-Redis-需要把所有数据放到内存中？"><a href="#为什么-Redis-需要把所有数据放到内存中？" class="headerlink" title="为什么 Redis 需要把所有数据放到内存中？"></a>为什么 Redis 需要把所有数据放到内存中？</h4><p>答：Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘，这样 Redis 就拥有了快速查询和数据持久化等特征。</p><h4 id="在-Redis-中-key-的最大容量是多少？"><a href="#在-Redis-中-key-的最大容量是多少？" class="headerlink" title="在 Redis 中 key 的最大容量是多少？"></a>在 Redis 中 key 的最大容量是多少？</h4><p>答：最大容量 512 MB，官方说明如下图所示：</p><p><img src="/" alt="1" class="lazyload" data-src="https://images.gitbook.cn/4ea56a20-e05b-11e9-99bc-59d43b30c641"></p><h4 id="Jedis-和-Redisson-有什么区别？"><a href="#Jedis-和-Redisson-有什么区别？" class="headerlink" title="Jedis 和 Redisson 有什么区别？"></a>Jedis 和 Redisson 有什么区别？</h4><p>答：Jedis 和 Redisson 的区别如下：</p><ul><li>Jedis 是 Redis 的 Java 实现客户端，其 API 提供了比较全面的 Redis 命令的支持；</li><li>Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</li></ul><h4 id="Redis-如何设置过期时间？如何设置永久有效？"><a href="#Redis-如何设置过期时间？如何设置永久有效？" class="headerlink" title="Redis 如何设置过期时间？如何设置永久有效？"></a>Redis 如何设置过期时间？如何设置永久有效？</h4><p>答：Redis 通过 expire() 方法设置过期时间，语法：redis.expire(key, expiration)。当 expire 的过期时间设置为 -1 时，表示永不过期。</p><h4 id="如何保证-Redis-的数据一致性？"><a href="#如何保证-Redis-的数据一致性？" class="headerlink" title="如何保证 Redis 的数据一致性？"></a>如何保证 Redis 的数据一致性？</h4><p>答：可使用以下方法来保证 Redis 的数据一致性：</p><ul><li>合理设置缓存的过期时间；</li><li>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</li></ul><h4 id="Redis-的数据结构是什么？它有什么优缺点？"><a href="#Redis-的数据结构是什么？它有什么优缺点？" class="headerlink" title="Redis 的数据结构是什么？它有什么优缺点？"></a>Redis 的数据结构是什么？它有什么优缺点？</h4><p>答：Redis 的数据结构是跳跃表，跳跃表是一种基于链表的扩展，跳跃表还是一个链表，是一个有序的链表，在遍历的时候基于比较，但普通链表只能遍历，跳跃表加入了一个层的概念，层级越高元素越少，每次先从高层查找，直到找到合适的位置，从图中可以看到高层的节点远远少于底层的节点数，从而实现了跳跃式查找。</p><p><img src="/" alt="2" class="lazyload" data-src="https://images.gitbook.cn/693382a0-e05b-11e9-bc61-0549c31758ee"></p><p>跳跃表优点：</p><ul><li>实现比红黑树简单</li><li>比红黑树更容易扩展</li><li>红黑树插入删除时为了平衡高度需要旋转附近节点，高并发需要锁，跳跃表不需要考虑</li></ul><p>跳跃表缺点：</p><ul><li>比红黑树占用更多的内存，每个节点的大小取决于该节点层数</li><li>空间局部性差导致缓存命中率低，比红黑树略慢</li></ul><h4 id="Redis-为什么用跳跃表来存储？"><a href="#Redis-为什么用跳跃表来存储？" class="headerlink" title="Redis 为什么用跳跃表来存储？"></a>Redis 为什么用跳跃表来存储？</h4><p>答：第一是因为红黑树存储比较复杂，调整涉及到多个节点的并发修改；第二是越接近根节点的地方越容易产生竞争，即使是不同叶子节点的操作由于平衡操作也可能逐级向上涉及到接近根的节点，而跳跃表可以用 CAS（Compare And Swap）来并发操作节点，比较容易实现，且更加局部化。</p><h4 id="什么是缓存穿透？如何解决？"><a href="#什么是缓存穿透？如何解决？" class="headerlink" title="什么是缓存穿透？如何解决？"></a>什么是缓存穿透？如何解决？</h4><p>答：缓存穿透是指查询一个一定不存在的数据，由于缓存中没有，因而每次需要从数据库中查询，但数据库也没有相应的数据，所以不会写入缓存，这就将导致每次请求都会去数据库查询，这种行为就叫缓存穿透。</p><p>解决方案是不管查询数据库是否有数据，都缓存起来，只不过把没有数据的缓存结果的过期时间设置为比较短的一个值，比如 3 分钟。</p><h4 id="什么是缓存雪崩，该如何解决？"><a href="#什么是缓存雪崩，该如何解决？" class="headerlink" title="什么是缓存雪崩，该如何解决？"></a>什么是缓存雪崩，该如何解决？</h4><p>答：指缓存由于某些原因，比如，宕机或者缓存大量过期等，从而导致大量请求到达后端数据库，进而导致数据库崩溃的情况。</p><p>解决缓存雪崩的方案如下：</p><ul><li>分析业务功能，尽量让缓存的失效时间点均匀分布；</li><li>使用 Redis 主备，保证缓存系统的高可用。</li></ul><h4 id="什么是缓存预热？有几种实现方式？"><a href="#什么是缓存预热？有几种实现方式？" class="headerlink" title="什么是缓存预热？有几种实现方式？"></a>什么是缓存预热？有几种实现方式？</h4><p>答：缓存预热是指系统上线后，将相关的缓存数据直接加载到缓存系统，这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。</p><p>缓存预热的实现方式，可分为以下两种：</p><ul><li>数据量不大的时候，工程启动的时候进行加载缓存动作；</li><li>数据量大的时候，设置一个定时任务脚本，进行缓存的刷新。</li></ul><h4 id="在-Java-程序中如何使用-Redis？"><a href="#在-Java-程序中如何使用-Redis？" class="headerlink" title="在 Java 程序中如何使用 Redis？"></a>在 Java 程序中如何使用 Redis？</h4><p>答：在 Java 程序中可使用 Jedis 来操作 Redis，使用步骤如下：</p><p>1）添加 Jedis 引用</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）连接并操作 Redis</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">// 存值</span></span><br><span class="line">jedis.set(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line">jedis.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><h4 id="什么是-Redis-持久化？如何进行-Redis-持久化？"><a href="#什么是-Redis-持久化？如何进行-Redis-持久化？" class="headerlink" title="什么是 Redis 持久化？如何进行 Redis 持久化？"></a>什么是 Redis 持久化？如何进行 Redis 持久化？</h4><p>答：Redis 持久化是指将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis 有以下两种持久化方案：</p><ul><li>RDB（Redis DataBase）：是指在制定的时间间隔内将内存中的数据集快照写入磁盘；</li><li>AOF（Append Only File）：该机制将以日志的形式记录服务器所处理的每一个写操作，在 Redis 服务器启动之初会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的。</li></ul><p>Redis 默认支持的持久化方式是 RDB 方式。</p><h4 id="RDB-和-AOF-有什么区别？"><a href="#RDB-和-AOF-有什么区别？" class="headerlink" title="RDB 和 AOF 有什么区别？"></a>RDB 和 AOF 有什么区别？</h4><p>答：RDB 和 AOF 的区别如下：</p><ul><li>RDB 可能会引起一定程度的数据丢失，AOF 不会造成数据丢失</li><li>RDB 的启动效率更高</li><li>AOF 占用的空间比 RDB 大，AOF 的同步速度比 RDB 慢</li></ul><p>总体来说如果对数据的完整性要求不高，RDB 是最好的解决方案，反之则选择 AOF。</p><h4 id="Redis-的监控工具都有哪些？"><a href="#Redis-的监控工具都有哪些？" class="headerlink" title="Redis 的监控工具都有哪些？"></a>Redis 的监控工具都有哪些？</h4><p>答：常用的 Redis 监控工具如下：</p><ul><li>Redis-stat：采用 Ruby 开发，基于 Redis 的 info 命令来统计，不影响 Redis 的性能；</li><li>RedisLive：采用 Python 开发的可视化及查询分析工具，它是通过监控脚本来 Redis 提供的 MONITOR 命令从被监控 Redis 实例中获取数据，并存储到 Redis 的监控实例中。</li></ul><h4 id="如何定位-Redis-的慢查询？"><a href="#如何定位-Redis-的慢查询？" class="headerlink" title="如何定位 Redis 的慢查询？"></a>如何定位 Redis 的慢查询？</h4><p>答：使用 slowlog get 来定位慢查询操作，如下所示：</p><blockquote><p>127.0.0.1:6379&gt; slowlog get</p><ol><li><ol><li>(integer) 0</li></ol></li><li><p>(integer) 1565937939</p></li><li><p>(integer) 28003</p></li><li><ol><li>“lpush”</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2) &quot;list&quot;</span><br><span class="line"></span><br><span class="line">3) &quot;1&quot;</span><br><span class="line"></span><br><span class="line">4) &quot;2&quot;</span><br><span class="line"></span><br><span class="line">5) &quot;6&quot;</span><br><span class="line"></span><br><span class="line">6) &quot;3&quot;</span><br><span class="line"></span><br><span class="line">7) &quot;4&quot;</span><br><span class="line"></span><br><span class="line">8) &quot;9&quot;</span><br><span class="line"></span><br><span class="line">9) &quot;8&quot;</span><br></pre></td></tr></table></figure></blockquote><p>其中：</p><ol><li><p>表示慢查询记录 id</p></li><li><p>表示发起命令的时间戳</p></li><li><p>表示命令耗时，单位为微秒</p></li><li><p>表示该条记录的命令及参数</p></li></ol><h4 id="SAVE-和-BGSAVE-有什么区别？"><a href="#SAVE-和-BGSAVE-有什么区别？" class="headerlink" title="SAVE 和 BGSAVE 有什么区别？"></a>SAVE 和 BGSAVE 有什么区别？</h4><p>答：SAVE 和 BGSAVE 都是用于 Redis 持久化的，它们的区别如下：</p><ul><li>SAVE 直接调用 rdbSave 函数（用于 Redis 持久化的函数），阻塞 Redis 主进程，直到保存完成为止，在主进程阻塞期间，服务器不能处理客户端的任何请求；</li><li>BGSAVE 则会创建一个子进程，子进程负责调用 rdbSave 函数，并在保存完成之后向主进程发送完成信号，Redis 服务器在 BGSAVE 执行期间仍然可以继续处理客户端的请求。</li></ul><h4 id="Redis-是如何实现同步的？"><a href="#Redis-是如何实现同步的？" class="headerlink" title="Redis 是如何实现同步的？"></a>Redis 是如何实现同步的？</h4><p>答：Redis 可以实现主从同步和从从同步。当第一次同步时，主节点做一次 BGSAVE，并同时将后续修改操作记录到内存中，待完成后将 RDB 文件全量同步到复制节点，复制节点接受完成后将 RDB 镜像加载到内存，加载完成后再通知主节点将期间修改的操作记录，同步到复制节点进行重放，这样就完成了同步过程。</p><h4 id="Redis-可以切换数据库吗？如何切换？"><a href="#Redis-可以切换数据库吗？如何切换？" class="headerlink" title="Redis 可以切换数据库吗？如何切换？"></a>Redis 可以切换数据库吗？如何切换？</h4><p>答：Redis 不像 MySQL 等关系型数据库那样有数据库的概念，不同的数据存在不同的数据库中，Redis 数据库是由一个整数索引标识，而不是一个数据库名称，默认情况下客户端连接到数据库 0，可以在配置文件中控制数据库总数，默认是 16 个。</p><p>可以使用 select index 来切换数据库，如下所示：</p><blockquote><p>127.0.0.1:6379&gt; select 0</p><p>OK</p></blockquote><h4 id="Redis-有哪些集群策略？"><a href="#Redis-有哪些集群策略？" class="headerlink" title="Redis 有哪些集群策略？"></a>Redis 有哪些集群策略？</h4><p>答：Redis 集群策略有以下 3 种：</p><ul><li>主从策略：1 台机器作为写操作，另外 2 台作为读操作，类似于 MySQL 的主从方式；</li><li>哨兵策略：增加 1 台机器作为哨兵，监控 3 台主从机器，当主节点挂机的时候，机器内部进行选举，从集群中从节点里指定一台机器升级为主节点，从而实现高可用。当主节点恢复的时候，加入到从节点中继续提供服务；</li><li>集群策略：Redis 3.0 之后增加了集群的概念，可实现多主多从的结构，实现真正的高可用。</li></ul><h4 id="Redis-集群方案都有哪些？"><a href="#Redis-集群方案都有哪些？" class="headerlink" title="Redis 集群方案都有哪些？"></a>Redis 集群方案都有哪些？</h4><p>答：Redis 集群实现方案如下：</p><ul><li>Twemproxy 是 Twitter 开源的 Redis 代理，它的使用和普通 Redis 完全一致，它会以一个代理的身份接收请求，并使用 hash 算法将请求转接到具体 Redis，将结果再返回 Twemproxy；</li><li>Codis 是开源解决方案，也是目前用的最多的集群方案，基本和 Twemproxy 效果一致，但它支持在节点数量改变情况下，旧节点数据可恢复到新 hash 节点；</li><li>Redis Cluster 是 Redis 3.0 自带的集群方案，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概念，以及自身支持节点设置从节点；</li><li>业务代码层实现，创建几个独立的 Redis 实例，在代码层对 key 进行 hash 计算，然后去对应的 Redis 实例操作数据。这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复、实例的监控等。</li></ul><h4 id="Redis-如何做内存优化？"><a href="#Redis-如何做内存优化？" class="headerlink" title="Redis 如何做内存优化？"></a>Redis 如何做内存优化？</h4><p>答：把相关的信息整体存储，而不是把每个信息独立存储，这样就可以有效的减少内存使用。</p><h4 id="分布式锁设计时需要注意哪些事项？"><a href="#分布式锁设计时需要注意哪些事项？" class="headerlink" title="分布式锁设计时需要注意哪些事项？"></a>分布式锁设计时需要注意哪些事项？</h4><p>答：通常分布式锁在设计时，需同时满足以下四个约束条件。</p><ul><li>互斥性：在任意时刻，只有一个客户端能持有锁。</li><li>安全性：即不会形成死锁，当一个客户端在持有锁的期间崩溃而没有主动解锁的情况下，其持有的锁也能够被正确释放，并保证后续其他客户端能加锁。</li><li>可用性：就 Redis 而言，当提供锁服务的 Redis master 节点发生宕机等不可恢复性故障时，slave 节点能够升主并继续提供服务，支持客户端加锁和解锁；对基于分布式一致性算法实现的锁服务，如 ETCD 而言，当 leader 节点宕机时，follow 节点能够选举出新的 leader 继续提供锁服务。</li><li>对称性：对于任意一个锁，其加锁和解锁必须是同一个客户端，即，客户端 A 不能把客户端 B 加的锁给解了。</li></ul><h4 id="Redis-集群实现的原理是什么？"><a href="#Redis-集群实现的原理是什么？" class="headerlink" title="Redis 集群实现的原理是什么？"></a>Redis 集群实现的原理是什么？</h4><p>答：集群的实现原理和集群的实现方式有关，如下所述：</p><ul><li>Redis Sentinal 着眼于高可用，在 Master 宕机时会自动将 Slave 提升为 Master，继续提供服务；</li><li>Redis Cluster 着眼于扩展性，在单个 Redis 内存不足时，使用 Cluster 进行分片存储。</li></ul><h4 id="Redis-常见的性能问题有哪些？"><a href="#Redis-常见的性能问题有哪些？" class="headerlink" title="Redis 常见的性能问题有哪些？"></a>Redis 常见的性能问题有哪些？</h4><p>答：Redis 常见性能问题如下：</p><ul><li>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，因此主服务器最好不要写内存快照；</li><li>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</li></ul><h2 id="设计模式常见面试题汇总"><a href="#设计模式常见面试题汇总" class="headerlink" title="设计模式常见面试题汇总"></a>设计模式常见面试题汇总</h2><h4 id="说一下设计模式？你都知道哪些？"><a href="#说一下设计模式？你都知道哪些？" class="headerlink" title="说一下设计模式？你都知道哪些？"></a>说一下设计模式？你都知道哪些？</h4><p>答：设计模式总共有 23 种，总体来说可以分为三大类：创建型模式（ Creational Patterns ）、结构型模式（ Structural Patterns ）和行为型模式（ Behavioral Patterns ）。</p><table><thead><tr><th align="left"><strong>分类</strong></th><th align="left"><strong>包含</strong></th><th align="left"><strong>关注点</strong></th></tr></thead><tbody><tr><td align="left">创建型模式</td><td align="left">工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式</td><td align="left">关注于对象的创建，同时隐藏创建逻辑</td></tr><tr><td align="left">结构型模式</td><td align="left">适配器模式、过滤器模式、装饰模式、享元模式、代理模式、外观模式、组合模式、桥接模式</td><td align="left">关注类和对象之间的组合</td></tr><tr><td align="left">行为型模式</td><td align="left">责任链模式、命令模式、中介者模式、观察者模式、状态模式、策略模式、模板模式、空对象模式、备忘录模式、迭代器模式、解释器模式、访问者模式</td><td align="left">关注对象之间的通信</td></tr></tbody></table><p>下面会对常用的设计模式分别做详细的说明。</p><h4 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h4><p>答：单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。</p><p>优点：不会频繁地创建和销毁对象，浪费系统资源。</p><p>使用场景：IO 、数据库连接、Redis 连接等。</p><p>单例模式代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例模式调用代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lesson7_3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton1 = Singleton.getInstance();</span><br><span class="line">        Singleton singleton2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton1 == singleton2); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果：true</p><p>可以看出以上单例模式是在类加载的时候就创建了，这样会影响程序的启动速度，那如何实现单例模式的延迟加载？在使用时再创建？</p><p>单例延迟加载代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单例模式-延迟加载版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上为非线程安全的，单例模式如何支持多线程？</p><p>使用 synchronized 来保证，单例模式的线程安全代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么是简单工厂模式？"><a href="#什么是简单工厂模式？" class="headerlink" title="什么是简单工厂模式？"></a>什么是简单工厂模式？</h4><p>答：简单工厂模式又叫静态工厂方法模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。比如，一台咖啡机就可以理解为一个工厂模式，你只需要按下想喝的咖啡品类的按钮（摩卡或拿铁），它就会给你生产一杯相应的咖啡，你不需要管它内部的具体实现，只要告诉它你的需求即可。</p><p><strong>优点</strong>：</p><ul><li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象；</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量；</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li></ul><p><strong>缺点</strong>：</p><ul><li>不易拓展，一旦添加新的产品类型，就不得不修改工厂的创建逻辑；</li><li>产品类型较多时，工厂的创建逻辑可能过于复杂，一旦出错可能造成所有产品的创建失败，不利于系统的维护。</li></ul><p>简单工厂示意图如下：</p><p><img src="/" alt="1" class="lazyload" data-src="https://images.gitbook.cn/35024ce0-e066-11e9-bc61-0549c31758ee"></p><p>简单工厂<strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createProduct</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (product) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Mocca&quot;</span>:</span><br><span class="line">                result = <span class="string">&quot;摩卡&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Latte&quot;</span>:</span><br><span class="line">                result = <span class="string">&quot;拿铁&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                result = <span class="string">&quot;其他&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么是抽象工厂模式？"><a href="#什么是抽象工厂模式？" class="headerlink" title="什么是抽象工厂模式？"></a>什么是抽象工厂模式？</h4><p>答：抽象工厂模式是在简单工厂的基础上将未来可能需要修改的代码抽象出来，通过继承的方式让子类去做决定。</p><p>比如，以上面的咖啡工厂为例，某天我的口味突然变了，不想喝咖啡了想喝啤酒，这个时候如果直接修改简单工厂里面的代码，这种做法不但不够优雅，也不符合软件设计的“开闭原则”，因为每次新增品类都要修改原来的代码。这个时候就可以使用抽象工厂类了，抽象工厂里只声明方法，具体的实现交给子类（子工厂）去实现，这个时候再有新增品类的需求，只需要新创建代码即可。</p><p>抽象工厂实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 抽象工厂</span></span><br><span class="line">       String result = (<span class="keyword">new</span> CoffeeFactory()).createProduct(<span class="string">&quot;Latte&quot;</span>);</span><br><span class="line">       System.out.println(result); <span class="comment">// output:拿铁</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">createProduct</span><span class="params">(String product)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 啤酒工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeerFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">createProduct</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">       String result = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">switch</span> (product) &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">&quot;Hans&quot;</span>:</span><br><span class="line">               result = <span class="string">&quot;汉斯&quot;</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">&quot;Yanjing&quot;</span>:</span><br><span class="line">               result = <span class="string">&quot;燕京&quot;</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               result = <span class="string">&quot;其他啤酒&quot;</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 咖啡工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">createProduct</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">       String result = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">switch</span> (product) &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">&quot;Mocca&quot;</span>:</span><br><span class="line">               result = <span class="string">&quot;摩卡&quot;</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">&quot;Latte&quot;</span>:</span><br><span class="line">               result = <span class="string">&quot;拿铁&quot;</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               result = <span class="string">&quot;其他咖啡&quot;</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么是观察者模式？"><a href="#什么是观察者模式？" class="headerlink" title="什么是观察者模式？"></a>什么是观察者模式？</h4><p>观察者模式是定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 <strong>优点</strong>：</p><ul><li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色；</li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合；</li><li>观察者模式支持广播通信；</li><li>观察者模式符合开闭原则（对拓展开放，对修改关闭）的要求。</li></ul><p><strong>缺点</strong>：</p><ul><li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间；</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃；</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ul><p>在观察者模式中有如下角色：</p><ul><li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象；</li><li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知；</li><li>Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己；</li><li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li></ul><p>观察者模式实现代码如下。</p><h5 id="定义观察者（消息接收方）"><a href="#定义观察者（消息接收方）" class="headerlink" title="定义观察者（消息接收方）"></a>定义观察者（消息接收方）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 观察者（消息接收方）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 具体的观察者（消息接收方）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcrereObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcrereObserver</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定义被观察者（消息发送方）"><a href="#定义被观察者（消息发送方）" class="headerlink" title="定义被观察者（消息发送方）"></a>定义被观察者（消息发送方）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 被观察者（消息发布方）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 增加订阅者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">// 删除订阅者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">// 通知订阅者更新消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 具体被观察者（消息发布方）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 订阅者列表（存储信息）</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; list = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        list.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        list.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : list) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码调用"><a href="#代码调用" class="headerlink" title="代码调用"></a>代码调用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义发布者</span></span><br><span class="line">        ConcreteSubject concreteSubject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        <span class="comment">// 定义订阅者</span></span><br><span class="line">        ConcrereObserver concrereObserver = <span class="keyword">new</span> ConcrereObserver(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        ConcrereObserver concrereObserver2 = <span class="keyword">new</span> ConcrereObserver(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        <span class="comment">// 添加订阅</span></span><br><span class="line">        concreteSubject.attach(concrereObserver);</span><br><span class="line">        concreteSubject.attach(concrereObserver2);</span><br><span class="line">        <span class="comment">// 发布信息</span></span><br><span class="line">        concreteSubject.notify(<span class="string">&quot;更新了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果如下：</p><blockquote><p>老王：更新了</p><p>Java：更新了</p></blockquote><h4 id="什么是装饰器模式？"><a href="#什么是装饰器模式？" class="headerlink" title="什么是装饰器模式？"></a>什么是装饰器模式？</h4><p>答：装饰器模式是指动态地给一个对象增加一些额外的功能，同时又不改变其结构。</p><p>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p><p>装饰器模式的关键：装饰器中使用了被装饰的对象。</p><p>比如，创建一个对象“laowang”，给对象添加不同的装饰，穿上夹克、戴上帽子……，这个执行过程就是装饰者模式，实现代码如下。</p><h5 id="定义顶层对象，定义行为"><a href="#定义顶层对象，定义行为" class="headerlink" title="定义顶层对象，定义行为"></a>定义顶层对象，定义行为</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定义装饰器超类"><a href="#定义装饰器超类" class="headerlink" title="定义装饰器超类"></a>定义装饰器超类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoratorBase</span> <span class="keyword">implements</span> <span class="title">IPerson</span></span>&#123;</span><br><span class="line">    IPerson iPerson;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecoratorBase</span><span class="params">(IPerson iPerson)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iPerson = iPerson;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        iPerson.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定义具体装饰器"><a href="#定义具体装饰器" class="headerlink" title="定义具体装饰器"></a>定义具体装饰器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jacket</span> <span class="keyword">extends</span> <span class="title">DecoratorBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Jacket</span><span class="params">(IPerson iPerson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(iPerson);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行已有功能</span></span><br><span class="line">        iPerson.show();</span><br><span class="line">        <span class="comment">// 定义新行为</span></span><br><span class="line">        System.out.println(<span class="string">&quot;穿上夹克&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hat</span> <span class="keyword">extends</span> <span class="title">DecoratorBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hat</span><span class="params">(IPerson iPerson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(iPerson);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行已有功能</span></span><br><span class="line">        iPerson.show();</span><br><span class="line">        <span class="comment">// 定义新行为</span></span><br><span class="line">        System.out.println(<span class="string">&quot;戴上帽子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定义具体对象"><a href="#定义具体对象" class="headerlink" title="定义具体对象"></a>定义具体对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LaoWang</span> <span class="keyword">implements</span> <span class="title">IPerson</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;什么都没穿&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="装饰器模式调用"><a href="#装饰器模式调用" class="headerlink" title="装饰器模式调用"></a>装饰器模式调用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LaoWang laoWang = <span class="keyword">new</span> LaoWang();</span><br><span class="line">        Jacket jacket = <span class="keyword">new</span> Jacket(laoWang);</span><br><span class="line">        Hat hat = <span class="keyword">new</span> Hat(jacket);</span><br><span class="line">        hat.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么是模板方法模式？"><a href="#什么是模板方法模式？" class="headerlink" title="什么是模板方法模式？"></a>什么是模板方法模式？</h4><p>答：模板方法模式是指定义一个模板结构，将具体内容延迟到子类去实现。</p><p><strong>优点</strong>：</p><ul><li>提高代码复用性：将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中；</li><li>实现了反向控制：通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制并且符合开闭原则。</li></ul><p>以给冰箱中放水果为例，比如，我要放一个香蕉：开冰箱门 → 放香蕉 → 关冰箱门；如果我再要放一个苹果：开冰箱门 → 放苹果 → 关冰箱门。可以看出它们之间的行为模式都是一样的，只是存放的水果品类不同而已，这个时候就非常适用模板方法模式来解决这个问题，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 添加模板方法 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Refrigerator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开冰箱门&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关冰箱门&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">extends</span> <span class="title">Refrigerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;放香蕉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Refrigerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;放苹果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 调用模板方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Refrigerator refrigerator = <span class="keyword">new</span> Banana();</span><br><span class="line">        refrigerator.open();</span><br><span class="line">        refrigerator.put();</span><br><span class="line">        refrigerator.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><blockquote><p>开冰箱门</p><p>放香蕉</p><p>关冰箱门</p></blockquote><h4 id="什么是代理模式？"><a href="#什么是代理模式？" class="headerlink" title="什么是代理模式？"></a>什么是代理模式？</h4><p>代理模式是给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p><p><strong>优点</strong>：</p><ul><li>代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；</li><li>可以灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务。</li></ul><p><strong>缺点</strong>：</p><ul><li>由于使用了代理模式，因此程序的性能没有直接调用性能高；</li><li>使用代理模式提高了代码的复杂度。</li></ul><p>举一个生活中的例子：比如买飞机票，由于离飞机场太远，直接去飞机场买票不太现实，这个时候我们就可以上携程 App 上购买飞机票，这个时候携程 App 就相当于是飞机票的代理商。</p><p>代理模式实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义售票接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IAirTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义飞机场售票</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirTicket</span> <span class="keyword">implements</span> <span class="title">IAirTicket</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 代理售票平台</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyAirTicket</span> <span class="keyword">implements</span> <span class="title">IAirTicket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AirTicket airTicket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyAirTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        airTicket = <span class="keyword">new</span> AirTicket();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        airTicket.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 代理模式调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IAirTicket airTicket = <span class="keyword">new</span> ProxyAirTicket();</span><br><span class="line">        airTicket.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么是策略模式？"><a href="#什么是策略模式？" class="headerlink" title="什么是策略模式？"></a>什么是策略模式？</h4><p>答：策略模式是指定义一系列算法，将每个算法都封装起来，并且使他们之间可以相互替换。</p><p><strong>优点</strong>：遵循了开闭原则，扩展性良好。</p><p><strong>缺点</strong>：随着策略的增加，对外暴露越来越多。</p><p>以生活中的例子来说，比如我们要出去旅游，选择性很多，可以选择骑车、开车、坐飞机、坐火车等，就可以使用策略模式，把每种出行作为一种策略封装起来，后面增加了新的交通方式了，如超级高铁、火箭等，就可以不需要改动原有的类，新增交通方式即可，这样也符合软件开发的开闭原则。 策略模式实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 声明旅行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITrip</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">going</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bike</span> <span class="keyword">implements</span> <span class="title">ITrip</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">going</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;骑自行车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drive</span> <span class="keyword">implements</span> <span class="title">ITrip</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">going</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义出行类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trip</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ITrip trip;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trip</span><span class="params">(ITrip trip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.trip = trip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTrip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.trip.going();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执行方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Trip trip = <span class="keyword">new</span> Trip(<span class="keyword">new</span> Bike());</span><br><span class="line">        trip.doTrip();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行的结果：</p><blockquote><p>骑自行车</p></blockquote><h4 id="什么是适配器模式？"><a href="#什么是适配器模式？" class="headerlink" title="什么是适配器模式？"></a>什么是适配器模式？</h4><p>答：适配器模式是将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口不匹配而无法一起工作的两个类能够在一起工作。</p><p><strong>优点</strong>：</p><ul><li>可以让两个没有关联的类一起运行，起着中间转换的作用；</li><li>灵活性好，不会破坏原有的系统。</li></ul><p><strong>缺点</strong>：过多地使用适配器，容易使代码结构混乱，如明明看到调用的是 A 接口，内部调用的却是 B 接口的实现。</p><p>以生活中的例子来说，比如有一个充电器是 MicroUSB 接口，而手机充电口却是 TypeC 的，这个时候就需要一个把 MicroUSB 转换成 TypeC 的适配器，如下图所示：</p><p><img src="/" alt="2" class="lazyload" data-src="https://images.gitbook.cn/55a69fa0-e066-11e9-bc61-0549c31758ee"></p><p>适配器实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 传统的充电线 MicroUSB</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MicroUSB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">charger</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TypeC 充电口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITypeC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">charger</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeC</span> <span class="keyword">implements</span> <span class="title">ITypeC</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TypeC 充电&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 适配器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdapterMicroUSB</span> <span class="keyword">implements</span> <span class="title">MicroUSB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TypeC typeC;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdapterMicroUSB</span><span class="params">(TypeC typeC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.typeC = typeC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        typeC.charger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TypeC typeC = <span class="keyword">new</span> TypeC();</span><br><span class="line">        MicroUSB microUSB = <span class="keyword">new</span> AdapterMicroUSB(typeC);</span><br><span class="line">        microUSB.charger();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><blockquote><p>TypeC 充电</p></blockquote><h4 id="JDK-类库常用的设计模式有哪些？"><a href="#JDK-类库常用的设计模式有哪些？" class="headerlink" title="JDK 类库常用的设计模式有哪些？"></a>JDK 类库常用的设计模式有哪些？</h4><p>答：JDK 常用的设计模式如下：</p><h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><p>java.text.DateFormat 工具类，它用于格式化一个本地日期或者时间。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style,Locale locale)</span></span>;</span><br></pre></td></tr></table></figure><p>加密类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">&quot;DESede&quot;</span>);</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">&quot;DESede&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h5><p>把其他类适配为集合类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; arrayList = java.util.Arrays.asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">List&lt;Integer&gt; arrayList = java.util.Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><p>如 JDK 本身的动态代理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The dog is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The cat is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK 代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target; <span class="comment">// 代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="comment">// 取得代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用前&quot;</span>);</span><br><span class="line">        Object result = method.invoke(target, args); <span class="comment">// 方法调用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// JDK 动态代理调用</span></span><br><span class="line">    AnimalProxy proxy = <span class="keyword">new</span> AnimalProxy();</span><br><span class="line">    Animal dogProxy = (Animal) proxy.getInstance(<span class="keyword">new</span> Dog());</span><br><span class="line">    dogProxy.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>全局只允许有一个实例，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime();</span><br></pre></td></tr></table></figure><h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h5><p>为一个对象动态的加上一系列的动作，而不需要因为这些动作的不同而产生大量的继承类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.BufferedInputStream(InputStream);  </span><br><span class="line">java.io.DataInputStream(InputStream);  </span><br><span class="line">java.io.BufferedOutputStream(OutputStream);  </span><br><span class="line">java.util.zip.ZipOutputStream(OutputStream);  </span><br><span class="line">java.util.Collections.checkedList(List list, Class type) ;</span><br></pre></td></tr></table></figure><h5 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h5><p>定义一个操作中算法的骨架，将一些步骤的执行延迟到其子类中。</p><p>比如，Arrays.sort() 方法，它要求对象实现 Comparable 接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Person person = (Person)o;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age.compareTo(person.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">SortTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">10</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">5</span>);</span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="number">15</span>);</span><br><span class="line">        Person[] persons = &#123;p1,p2,p3&#125;;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(persons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IO-使用了什么设计模式？"><a href="#IO-使用了什么设计模式？" class="headerlink" title="IO 使用了什么设计模式？"></a>IO 使用了什么设计模式？</h4><p>答：IO 使用了适配器模式和装饰器模式。</p><ul><li>适配器模式：由于 InputStream 是字节流不能享受到字符流读取字符那么便捷的功能，借助 InputStreamReader 将其转为 Reader 子类，因而可以拥有便捷操作文本文件方法；</li><li>装饰器模式：将 InputStream 字节流包装为其他流的过程就是装饰器模式，比如，包装为 FileInputStream、ByteArrayInputStream、PipedInputStream 等。</li></ul><h4 id="Spring-中都使用了哪些设计模式？"><a href="#Spring-中都使用了哪些设计模式？" class="headerlink" title="Spring 中都使用了哪些设计模式？"></a>Spring 中都使用了哪些设计模式？</h4><p>答：Spring 框架使用的设计模式如下。</p><ul><li>代理模式：在 AOP 中有使用</li><li>单例模式：bean 默认是单例模式</li><li>模板方法模式：jdbcTemplate</li><li>工厂模式：BeanFactory</li><li>观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用，比如，ContextStartedEvent 就是 ApplicationContext 启动后触发的事件</li><li>适配器模式：Spring MVC 中也是用到了适配器模式适配 Controller</li></ul><h2 id="算法常用面试题汇总"><a href="#算法常用面试题汇总" class="headerlink" title="算法常用面试题汇总"></a>算法常用面试题汇总</h2><h4 id="说一下什么是二分法？使用二分法时需要注意什么？如何用代码实现？"><a href="#说一下什么是二分法？使用二分法时需要注意什么？如何用代码实现？" class="headerlink" title="说一下什么是二分法？使用二分法时需要注意什么？如何用代码实现？"></a>说一下什么是二分法？使用二分法时需要注意什么？如何用代码实现？</h4><p>二分法查找（Binary Search）也称折半查找，是指当每次查询时，将数据分为前后两部分，再用中值和待搜索的值进行比较，如果搜索的值大于中值，则使用同样的方式（二分法）向后搜索，反之则向前搜索，直到搜索结束为止。</p><p>二分法使用的时候需要注意：二分法只适用于有序的数据，也就是说，数据必须是从小到大，或是从大到小排序的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lesson7_4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二分法查找</span></span><br><span class="line">        <span class="keyword">int</span>[] binaryNums = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">27</span>, <span class="number">50</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> findValue = <span class="number">27</span>;</span><br><span class="line">        <span class="keyword">int</span> binaryResult = binarySearch(binaryNums, <span class="number">0</span>, binaryNums.length - <span class="number">1</span>, findValue);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素第一次出现的位置（从0开始）：&quot;</span> + binaryResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找，返回该值第一次出现的位置（下标从 0 开始）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums      查询数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start     开始下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end       结束下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> findValue 要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> findValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="comment">// 中间位置</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 中间的值</span></span><br><span class="line">            <span class="keyword">int</span> middleValue = nums[middle];</span><br><span class="line">            <span class="keyword">if</span> (findValue == middleValue) &#123;</span><br><span class="line">                <span class="comment">// 等于中值直接返回</span></span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findValue &lt; middleValue) &#123;</span><br><span class="line">                <span class="comment">// 小于中值，在中值之前的数据中查找</span></span><br><span class="line">                <span class="keyword">return</span> binarySearch(nums, start, middle - <span class="number">1</span>, findValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 大于中值，在中值之后的数据中查找</span></span><br><span class="line">                <span class="keyword">return</span> binarySearch(nums, middle + <span class="number">1</span>, end, findValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><blockquote><p>元素第一次出现的位置（从0开始）：4</p></blockquote><h4 id="什么是斐波那契数列？用代码如何实现？"><a href="#什么是斐波那契数列？用代码如何实现？" class="headerlink" title="什么是斐波那契数列？用代码如何实现？"></a>什么是斐波那契数列？用代码如何实现？</h4><p>斐波那契数列（Fibonacci Sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711…… 在数学上，斐波那契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用。</p><p>斐波那契数列之所以又称黄金分割数列，是因为随着数列项数的增加，前一项与后一项之比越来越逼近黄金分割的数值 0.6180339887……</p><p>斐波那契数列指的是这样一个数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711……</p><p><strong>斐波那契数列的特征</strong>：第三项开始（含第三项）它的值等于前两项之和。</p><p>斐波那契数列代码实现示例，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lesson7_4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 斐波那契数列</span></span><br><span class="line">        <span class="keyword">int</span> fibonacciIndex = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> fibonacciResult = fibonacci(fibonacciIndex);</span><br><span class="line">        System.out.println(<span class="string">&quot;下标(从0开始)&quot;</span> + fibonacciIndex + <span class="string">&quot;的值为：&quot;</span> + fibonacciResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 斐波那契数列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 斐波那契数列的下标（从0开始）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span> || index == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fibonacci(index - <span class="number">1</span>) + fibonacci(index - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><blockquote><p>下标(从0开始)7的值为：13</p></blockquote><h4 id="一般而言，兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。如果所有兔子都不死，那么一年以后可以繁殖多少对兔子？请使用代码实现。"><a href="#一般而言，兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。如果所有兔子都不死，那么一年以后可以繁殖多少对兔子？请使用代码实现。" class="headerlink" title="一般而言，兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。如果所有兔子都不死，那么一年以后可以繁殖多少对兔子？请使用代码实现。"></a>一般而言，兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。如果所有兔子都不死，那么一年以后可以繁殖多少对兔子？请使用代码实现。</h4><p>先来分析一下，本题目</p><ul><li>第一个月：有 1 对小兔子；</li><li>第二个月：小兔子变成大兔子；</li><li>第三个月：大兔子下了一对小兔子；</li><li>第四个月：大兔子又下了一对小兔子，上个月的一对小兔子变成了大兔子；</li><li>……</li></ul><p>最后总结的规律如下列表所示：</p><table><thead><tr><th align="left">月数</th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th><th align="left">8</th><th align="left">9</th><th align="left">10</th><th align="left">11</th><th align="left">12</th><th align="left">…</th></tr></thead><tbody><tr><td align="left">幼仔对数</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">2</td><td align="left">3</td><td align="left">5</td><td align="left">8</td><td align="left">13</td><td align="left">21</td><td align="left">34</td><td align="left">55</td><td align="left">…</td></tr><tr><td align="left">成兔对数</td><td align="left">0</td><td align="left">1</td><td align="left">1</td><td align="left">2</td><td align="left">3</td><td align="left">5</td><td align="left">8</td><td align="left">13</td><td align="left">21</td><td align="left">34</td><td align="left">55</td><td align="left">89</td><td align="left"></td></tr><tr><td align="left">总对数</td><td align="left">1</td><td align="left">1</td><td align="left">2</td><td align="left">3</td><td align="left">5</td><td align="left">8</td><td align="left">13</td><td align="left">21</td><td align="left">34</td><td align="left">55</td><td align="left">89</td><td align="left">144</td><td align="left"></td></tr></tbody></table><p>可以看出，兔子每个月的总对数刚好符合斐波那契数列，第 12 个月的时候，总共有 144 对兔子。 实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lesson7_4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 兔子的总对数</span></span><br><span class="line">        <span class="keyword">int</span> rabbitNumber = fibonacci(<span class="number">12</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;第 12 个月兔子的总对数是：&quot;</span> + rabbitNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 斐波那契数列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 斐波那契数列的下标（从0开始）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span> || index == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fibonacci(index - <span class="number">1</span>) + fibonacci(index - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><blockquote><p>第 12 个月兔子的总对数是：144</p></blockquote><h4 id="什么是冒泡排序？用代码如何实现？"><a href="#什么是冒泡排序？用代码如何实现？" class="headerlink" title="什么是冒泡排序？用代码如何实现？"></a>什么是冒泡排序？用代码如何实现？</h4><p>冒泡排序（Bubble Sort）算法是所有排序算法中最简单、最基础的一个，它的实现思路是通过相邻数据的交换达到排序的目的。</p><p>冒泡排序的执行流程是：</p><ul><li>对数组中相邻的数据，依次进行比较；</li><li>如果前面的数据大于后面的数据，则把前面的数据交换到后面。经过一轮比较之后，就能把数组中最大的数据排到数组的最后面了；</li><li>再用同样的方法，把剩下的数据逐个进行比较排序，最后得到就是从小到大排序好的数据。</li></ul><p>冒泡排序算法代码实现，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lesson7_4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 冒泡排序调用</span></span><br><span class="line">        <span class="keyword">int</span>[] bubbleNums = &#123;<span class="number">132</span>, <span class="number">110</span>, <span class="number">122</span>, <span class="number">90</span>, <span class="number">50</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span> + Arrays.toString(bubbleNums));</span><br><span class="line">        bubbleSort(bubbleNums);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后：&quot;</span> + Arrays.toString(bubbleNums));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冒泡排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    temp = nums[j];</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次排序：&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(nums));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><blockquote><p>排序前：[132, 110, 122, 90, 50]</p><p>第1次排序：[110, 122, 90, 50, 132]</p><p>第2次排序：[110, 90, 50, 122, 132]</p><p>第3次排序：[90, 50, 110, 122, 132]</p><p>第4次排序：[50, 90, 110, 122, 132]</p><p>排序后：[50, 90, 110, 122, 132]</p></blockquote><h4 id="什么是选择排序？用代码如何实现？"><a href="#什么是选择排序？用代码如何实现？" class="headerlink" title="什么是选择排序？用代码如何实现？"></a>什么是选择排序？用代码如何实现？</h4><p>选择排序（Selection Sort）算法也是比较简单的排序算法，其实现思路是每一轮循环找到最小的值，依次排到数组的最前面，这样就实现了数组的有序排列。</p><p>比如，下面是一组数据使用选择排序的执行流程：</p><ul><li>初始化数据：18, 1, 6, 27, 15</li><li>第一次排序：1, 18, 6, 27, 15</li><li>第二次排序：1, 6, 18, 27, 15</li><li>第三次排序：1, 6, 15, 27, 18</li><li>第四次排序：1, 6, 15, 18, 27</li></ul><p>选择排序算法代码实现，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lesson7_4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 选择排序调用</span></span><br><span class="line">        <span class="keyword">int</span>[] selectNums = &#123;<span class="number">18</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">27</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span> + Arrays.toString(selectNums));</span><br><span class="line">        selectSort(selectNums);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后：&quot;</span> + Arrays.toString(selectNums));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[index]) &#123;</span><br><span class="line">                    index = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index != i) &#123;</span><br><span class="line">                temp = nums[i];</span><br><span class="line">                nums[i] = nums[index];</span><br><span class="line">                nums[index] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次排序：&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(nums));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><blockquote><p>排序前：[18, 1, 6, 27, 15]</p><p>第0次排序：[1, 18, 6, 27, 15]</p><p>第1次排序：[1, 6, 18, 27, 15]</p><p>第2次排序：[1, 6, 15, 27, 18]</p><p>第3次排序：[1, 6, 15, 18, 27]</p><p>排序后：[1, 6, 15, 18, 27]</p></blockquote><h4 id="什么是插入排序？用代码如何实现？"><a href="#什么是插入排序？用代码如何实现？" class="headerlink" title="什么是插入排序？用代码如何实现？"></a>什么是插入排序？用代码如何实现？</h4><p>插入排序（Insertion Sort）算法是指依次把当前循环的元素，通过对比插入到合适位置的排序算法。 比如，下面是一组数据使用插入排序的执行流程：</p><ul><li>初始化数据：18, 1, 6, 27, 15</li><li>第一次排序：1, 18, 6, 27, 15</li><li>第二次排序：1, 6, 18, 27, 15</li><li>第三次排序：1, 6, 18, 27, 15</li><li>第四次排序：1, 6, 15, 18, 27</li></ul><p>插入排序算法代码实现，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lesson7_4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入排序调用</span></span><br><span class="line">        <span class="keyword">int</span>[] insertNums = &#123;<span class="number">18</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">27</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span> + Arrays.toString(insertNums));</span><br><span class="line">        insertSort(insertNums);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后：&quot;</span> + Arrays.toString(insertNums));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, k;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            k = nums[i];</span><br><span class="line">            j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 对 i 之前的数据，给当前元素找到合适的位置</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; k &lt; nums[j]) &#123;</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">                <span class="comment">// j-- 继续往前寻找</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j + <span class="number">1</span>] = k;</span><br><span class="line">            System.out.print(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次排序：&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(nums));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><blockquote><p>排序前：[18, 1, 6, 27, 15]</p><p>第1次排序：[1, 18, 6, 27, 15]</p><p>第2次排序：[1, 6, 18, 27, 15]</p><p>第3次排序：[1, 6, 18, 27, 15]</p><p>第4次排序：[1, 6, 15, 18, 27]</p><p>排序后：[1, 6, 15, 18, 27]</p></blockquote><h4 id="什么是快速排序？用代码如何实现？"><a href="#什么是快速排序？用代码如何实现？" class="headerlink" title="什么是快速排序？用代码如何实现？"></a>什么是快速排序？用代码如何实现？</h4><p>快速排序（Quick Sort）算法和冒泡排序算法类似，都是基于交换排序思想实现的，快速排序算法是对冒泡排序算法的改进，从而具有更高的执行效率。</p><p>快速排序是通过多次比较和交换来实现排序的执行流程如下：</p><ul><li>首先设定一个分界值，通过该分界值把数组分为左右两个部分；</li><li>将大于等于分界值的元素放到分界值的右边，将小于分界值的元素放到分界值的左边；</li><li>然后对左右两边的数据进行独立的排序，在左边数据中取一个分界值，把小于分界值的元素放到分界值的左边，大于等于分界值的元素，放到数组的右边；右边的数据也执行同样的操作；</li><li>重复上述操作，当左右各数据排序完成后，整个数组也就完成了排序。</li></ul><p>快速排序算法代码实现，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lesson7_4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快速排序调用</span></span><br><span class="line">        <span class="keyword">int</span>[] quickNums = &#123;<span class="number">18</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">27</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span> + Arrays.toString(quickNums));</span><br><span class="line">        quickSort(quickNums, <span class="number">0</span>, quickNums.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后：&quot;</span> + Arrays.toString(quickNums));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f, t;</span><br><span class="line">        <span class="keyword">int</span> ltemp = left;</span><br><span class="line">        <span class="keyword">int</span> rtemp = right;</span><br><span class="line">        <span class="comment">// 分界值</span></span><br><span class="line">        f = nums[(left + right) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span> (ltemp &lt; rtemp) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[ltemp] &lt; f) &#123;</span><br><span class="line">                ++ltemp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (nums[rtemp] &gt; f) &#123;</span><br><span class="line">                --rtemp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ltemp &lt;= rtemp) &#123;</span><br><span class="line">                t = nums[ltemp];</span><br><span class="line">                nums[ltemp] = nums[rtemp];</span><br><span class="line">                nums[rtemp] = t;</span><br><span class="line">                --rtemp;</span><br><span class="line">                ++ltemp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ltemp == rtemp) &#123;</span><br><span class="line">            ltemp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; rtemp) &#123;</span><br><span class="line">            <span class="comment">// 递归调用</span></span><br><span class="line">            quickSort(nums, left, ltemp - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; ltemp) &#123;</span><br><span class="line">            <span class="comment">// 递归调用</span></span><br><span class="line">            quickSort(nums, rtemp + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><blockquote><p>排序前：[18, 1, 6, 27, 15]</p><p>排序后：[1, 6, 15, 18, 27]</p></blockquote><h4 id="什么是堆排序？用代码如何实现？"><a href="#什么是堆排序？用代码如何实现？" class="headerlink" title="什么是堆排序？用代码如何实现？"></a>什么是堆排序？用代码如何实现？</h4><p>堆排序（Heap Sort）算法是利用堆结构和二叉树的一些特性来完成排序的。 堆结构是一种树结构，准确来说是一个完全二叉树。完全二叉树每个节点应满足以下条件：</p><ul><li>如果按照从小到大的顺序排序，要求非叶节点的数据要大于等于，其左、右子节点的数据；</li><li>如果按照从大到小的顺序排序，要求非叶节点的数据小于等于，其左、右子节点的数据。</li></ul><p>可以看出，堆结构对左、右子节点的大小没有要求，只规定叶节点要和子节点（左、右）的数据满足大小关系。</p><p>比如，下面是一组数据使用堆排序的执行流程：</p><p><img src="/" alt="1" class="lazyload" data-src="https://images.gitbook.cn/98e41070-e7de-11e9-a117-ebe8fd595e2b"></p><p>堆排序算法代码实现，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lesson7_4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 堆排序调用</span></span><br><span class="line">        <span class="keyword">int</span>[] heapNums = &#123;<span class="number">18</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">27</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;堆排序前：&quot;</span> + Arrays.toString(heapNums));</span><br><span class="line">        heapSort(heapNums, heapNums.length);</span><br><span class="line">        System.out.println(<span class="string">&quot;堆排序后：&quot;</span> + Arrays.toString(heapNums));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 待排序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n    堆大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, k, temp;</span><br><span class="line">        <span class="comment">// 将 nums[0,n-1] 建成大根堆</span></span><br><span class="line">        <span class="keyword">for</span> (i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 第 i 个节点，有右子树</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                j = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> ((j + <span class="number">1</span>) &lt; n) &#123;</span><br><span class="line">                    <span class="comment">// 右左子树小于右子树，则需要比较右子树</span></span><br><span class="line">                    <span class="keyword">if</span> (nums[j] &lt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="comment">// 序号增加 1，指向右子树</span></span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">                    <span class="comment">// 交换数据</span></span><br><span class="line">                    temp = nums[i];</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    nums[j] = temp;</span><br><span class="line">                    <span class="comment">// 堆被破坏，重新调整</span></span><br><span class="line">                    i = j;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 左右子节点均大，则堆未被破坏，不需要调整</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 与第 i 个记录交换</span></span><br><span class="line">            temp = nums[<span class="number">0</span>];</span><br><span class="line">            nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">            k = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 第 i 个节点有右子树</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt; i) &#123;</span><br><span class="line">                j = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> ((j + <span class="number">1</span>) &lt; i) &#123;</span><br><span class="line">                    <span class="comment">// 右左子树小于右子树，则需要比较右子树</span></span><br><span class="line">                    <span class="keyword">if</span> (nums[j] &lt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="comment">// 序号增加 1，指向右子树</span></span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[k] &lt; nums[j]) &#123;</span><br><span class="line">                    <span class="comment">// 交换数据</span></span><br><span class="line">                    temp = nums[k];</span><br><span class="line">                    nums[k] = nums[j];</span><br><span class="line">                    nums[j] = temp;</span><br><span class="line">                    <span class="comment">// 堆被破坏，重新调整</span></span><br><span class="line">                    k = j;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 左右子节点均大，则堆未被破坏，不需要调整</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 输出每步排序结果</span></span><br><span class="line">            System.out.print(<span class="string">&quot;第&quot;</span> + (n - i) + <span class="string">&quot;次排序：&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(nums));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><blockquote><p>堆排序前：[18, 1, 6, 27, 15]</p><p>第1次排序：[18, 15, 6, 1, 27]</p><p>第2次排序：[15, 1, 6, 18, 27]</p><p>第3次排序：[6, 1, 15, 18, 27]</p><p>第4次排序：[1, 6, 15, 18, 27]</p><p>堆排序后：[1, 6, 15, 18, 27]</p></blockquote><h4 id="总结-24"><a href="#总结-24" class="headerlink" title="总结"></a>总结</h4><p>对于应届毕业生来说，算法是大厂必考的一大重点科目，因为对于没有太多实际项目经验的应届生来说，考察的重点是逻辑思考能力和学习力，这两项能力的掌握情况都体现在算法上，因此除了本文的这些内容外，对于校招的同学来说还需要配合 LeeCode，来把算法这一关的能力构建起来，对于社招的同学来说，一般算法问到的可能性相对比较少，最常见的算法问题应该就是对冒泡和快排的掌握情况了，对于这两个算法来说，最好能到达手写代码的情况。</p><h2 id="JVM-面试题汇总"><a href="#JVM-面试题汇总" class="headerlink" title="JVM 面试题汇总"></a>JVM 面试题汇总</h2><h4 id="什么是-JVM？它有什么作用？"><a href="#什么是-JVM？它有什么作用？" class="headerlink" title="什么是 JVM？它有什么作用？"></a>什么是 JVM？它有什么作用？</h4><p>答：JVM 是 Java Virtual Machine（Java 虚拟机）的缩写，顾名思义它是一个虚拟计算机，也是 Java 程序能够实现跨平台的基础。它的作用是加载 Java 程序，把字节码翻译成机器码再交由 CPU 执行的一个虚拟计算器。</p><h4 id="JVM-主要组成部分有哪些？"><a href="#JVM-主要组成部分有哪些？" class="headerlink" title="JVM 主要组成部分有哪些？"></a>JVM 主要组成部分有哪些？</h4><p>答：JVM 主要组成部分如下：</p><ul><li>类加载器（ClassLoader）</li><li>运行时数据区（Runtime Data Area）</li><li>执行引擎（Execution Engine）</li><li>本地库接口（Native Interface）</li></ul><h4 id="JVM-是如何工作的？"><a href="#JVM-是如何工作的？" class="headerlink" title="JVM 是如何工作的？"></a>JVM 是如何工作的？</h4><p>答：首先程序在执行之前先要把 Java 代码（.java）转换成字节码（.class），JVM 通过类加载器（ClassLoader）把字节码加载到内存中，但字节码文件是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine） 将字节码翻译成底层机器码，再交由 CPU 去执行，CPU 执行的过程中需要调用本地库接口（Native Interface）来完成整个程序的运行。</p><h4 id="JVM-内存布局是怎样的？"><a href="#JVM-内存布局是怎样的？" class="headerlink" title="JVM 内存布局是怎样的？"></a>JVM 内存布局是怎样的？</h4><p>答：不同虚拟机实现可能略微有所不同，但都会遵从 Java 虚拟机规范，Java 8 虚拟机规范规定，Java 虚拟机所管理的内存将会包括以下几个区域：</p><ul><li>程序计数器（Program Counter Register）</li><li>Java 虚拟机栈（Java Virtual Machine Stacks）</li><li>本地方法栈（Native Method Stack）</li><li>Java 堆（Java Heap）</li><li>方法区（Methed Area）</li></ul><hr><p><strong>① 程序计数器</strong></p><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解析器的工作是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于 JVM 的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，也就是任何时刻，一个处理器（或者说一个内核）都只会执行一条线程中的指令。因此为了线程切换后能恢复到正确的执行位置，每个线程都有独立的程序计数器。</p><p>如果线程正在执行 Java 中的方法，程序计数器记录的就是正在执行虚拟机字节码指令的地址，如果是 Native 方法，这个计数器就为空（undefined），因此该内存区域是唯一一个在 Java 虚拟机规范中没有规定 OutOfMemoryError 的区域。</p><p><strong>② Java 虚拟机栈</strong></p><p>Java 虚拟机栈（Java Virtual Machine Stacks）描述的是 Java 方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，都对应着一个线帧在虚拟机栈中入栈到出栈的过程。</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的栈深度就会抛出 StackOverflowError 异常。</li><li>如果虚拟机是可以动态扩展的，如果扩展时无法申请到足够的内存就会抛出 OutOfMemoryError 异常。</li></ul><hr><p><strong>③ 本地方法栈</strong></p><p>本地方法栈（Native Method Stack）与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的。</p><p>在 Java 虚拟机规范中对于本地方法栈没有特殊的要求，虚拟机可以自由的实现它，因此在 Sun HotSpot 虚拟机直接把本地方法栈和虚拟机栈合二为一了。</p><p><strong>④ Java 堆</strong></p><p>Java 堆（Java Heap）是 JVM 中内存最大的一块，是被所有线程共享的，在虚拟机启动时候创建，Java 堆唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存，随着JIT编译器的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化的技术将会导致一些微妙的变化，所有的对象都分配在堆上渐渐变得不那么绝对了。</p><p>如果在堆中没有内存完成实例分配，并且堆不可以再扩展时，将会抛出 OutOfMemoryError。 Java 虚拟机规范规定，Java 堆可以处在物理上不连续的内存空间中，只要逻辑上连续即可，就像我们的磁盘空间一样。在实现上也可以是固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是可扩展的，通过 -Xmx 和 -Xms 控制。</p><p><strong>⑤ 方法区</strong></p><p>方法区（Methed Area）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p><p>很多人把方法区称作“永久代”（Permanent Generation），本质上两者并不等价，只是 HotSpot 虚拟机垃圾回收器团队把 GC 分代收集扩展到了方法区，或者说是用来永久代来实现方法区而已，这样能省去专门为方法区编写内存管理的代码，但是在 JDK 8 也移除了“永久代”，使用 Native Memory 来实现方法区。</p><p>当方法无法满足内存分配需求时会抛出 OutOfMemoryError 异常。</p><h4 id="在-Java-中负责字节码解释执行的是？"><a href="#在-Java-中负责字节码解释执行的是？" class="headerlink" title="在 Java 中负责字节码解释执行的是？"></a>在 Java 中负责字节码解释执行的是？</h4><p>A：应用服务器<br>B：垃圾回收器<br>C：虚拟机<br>D：编译器</p><p>答：C</p><h4 id="静态变量存储在哪个区？"><a href="#静态变量存储在哪个区？" class="headerlink" title="静态变量存储在哪个区？"></a>静态变量存储在哪个区？</h4><p>A：栈区<br>B：堆区<br>C：全局区<br>D：常量区</p><p>答：C</p><p>题目解析：栈区存放函数的参数值，局部变量的值等；堆区存放的是程序员创建的对象；全局区存放全局变量和静态变量；常量区存放常量字符串。</p><h4 id="垃圾回收算法有哪些？"><a href="#垃圾回收算法有哪些？" class="headerlink" title="垃圾回收算法有哪些？"></a>垃圾回收算法有哪些？</h4><p>答：垃圾回收算法如下。</p><ul><li>引用计数器算法：引用计算器判断对象是否存活的算法是这样的，给每一个对象设置一个引用计数器，每当有一个地方引用这个对象的时候，计数器就加 1，与之相反，每当引用失效的时候就减 1。</li><li>可达性分析算法：在主流的语言的主流实现中，比如 Java、C#，甚至是古老的 Lisp 都是使用的可达性分析算法来判断对象是否存活的。这个算法的核心思路就是通过一些列的“GC Roots”对象作为起始点，从这些对象开始往下搜索，搜索所经过的路径称之为“引用链”。当一个对象到 GC Roots 没有任何引用链相连的时候，证明此对象是可以被回收的。</li><li>复制算法：复制算法是将内存分为大小相同的两块，当这一块使用完了，就把当前存活的对象复制到另一块，然后一次性清空当前区块。此算法的缺点是只能利用一半的内存空间。</li><li>标记-清除算法：此算法执行分两阶段，第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</li><li>标记-整理：此算法结合了“标记-清除”和“复制”两个算法的优点。分为两个阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</li></ul><h4 id="哪些对象可以作为引用链的-Root-对象？"><a href="#哪些对象可以作为引用链的-Root-对象？" class="headerlink" title="哪些对象可以作为引用链的 Root 对象？"></a>哪些对象可以作为引用链的 Root 对象？</h4><p>答：引用链的 Root 对象可以为以下内容：</p><ul><li>Java 虚拟机栈中的引用对象；</li><li>本地方法栈中 JNI（既一般说的 Native 方法）引用的对象；</li><li>方法区中类静态常量的引用对象；</li><li>方法区中常量的引用对象。</li></ul><h4 id="对象引用关系都有哪些？"><a href="#对象引用关系都有哪些？" class="headerlink" title="对象引用关系都有哪些？"></a>对象引用关系都有哪些？</h4><p>答：不管是引用计数法还是可达性分析算法都与对象的“引用”有关，这说明对象的引用决定了对象的生死，对象的引用关系如下。</p><ul><li>强引用：在代码中普遍存在的，类似 <code>Object obj = new Object()</code> 这类引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。</li><li>软引用：是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当JVM 认为内存不足时，才会去试图回收软引用指向的对象，JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。</li><li>弱引用：非必需对象，但它的强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。</li><li>虚引用：也称为幽灵引用或幻影引用，是最弱的一种引用关系，无法通过虚引用来获取一个对象实例，为对象设置虚引用的目的只有一个，就是当着个对象被收集器回收时收到一条系统通知。</li></ul><h4 id="内存溢出和内存泄漏的区别是什么？"><a href="#内存溢出和内存泄漏的区别是什么？" class="headerlink" title="内存溢出和内存泄漏的区别是什么？"></a>内存溢出和内存泄漏的区别是什么？</h4><p>答：内存溢出和内存泄漏的区别如下：</p><ul><li>内存溢出是指程序申请内存时，没有足够的内存，就会报错 OutOfMemory；</li><li>内存泄漏是指垃圾对象无法回收，可以使用 Memory Analyzer 等工具排出内存泄漏。</li></ul><h4 id="垃圾回收的分类都有哪些？"><a href="#垃圾回收的分类都有哪些？" class="headerlink" title="垃圾回收的分类都有哪些？"></a>垃圾回收的分类都有哪些？</h4><p>答：垃圾回收的分类如下：</p><ul><li>新生代回收器：Serial、ParNew、Parallel Scavenge</li><li>老年代回收器：Serial Old、Parallel Old、CMS</li><li>整堆回收器：G1</li></ul><h4 id="分代垃圾回收器的组成部分有哪些？"><a href="#分代垃圾回收器的组成部分有哪些？" class="headerlink" title="分代垃圾回收器的组成部分有哪些？"></a>分代垃圾回收器的组成部分有哪些？</h4><p>答：分代垃圾回收器是由：新生代（Young Generation）和老生代（Tenured Generation）组成的，默认情况下新生代和老生代的内存比例是 1:2。</p><h4 id="新生代的组成部分有哪些？"><a href="#新生代的组成部分有哪些？" class="headerlink" title="新生代的组成部分有哪些？"></a>新生代的组成部分有哪些？</h4><p>答：新生代是由：Eden、Form Survivor、To Survivor 三个区域组成的，它们内存默认占比是 8:1:1。</p><h4 id="新生代垃圾回收是怎么执行的？"><a href="#新生代垃圾回收是怎么执行的？" class="headerlink" title="新生代垃圾回收是怎么执行的？"></a>新生代垃圾回收是怎么执行的？</h4><p>答：新生代垃圾回收的执行过程如下：</p><p>① Eden 区 + From Survivor 区存活着的对象复制到 To Survivor 区；<br>② 清空 Eden 和 From Survivor 分区；<br>③ From Survivor 和 To Survivor 分区交换（From 变 To，To 变 From）。</p><h4 id="为什么新生代有两个-Survivor-分区？"><a href="#为什么新生代有两个-Survivor-分区？" class="headerlink" title="为什么新生代有两个 Survivor 分区？"></a>为什么新生代有两个 Survivor 分区？</h4><p>答：当新生代的 Survivor 分区为 2 个的时候，不论是空间利用率还是程序运行的效率都是最优的。</p><ul><li>如果 Survivor 是 0 的话，也就是说新生代只有一个 Eden 分区，每次垃圾回收之后，存活的对象都会进入老生代，这样老生代的内存空间很快就被占满了，从而触发最耗时的 Full GC ，显然这样的收集器的效率是我们完全不能接受的。</li><li>如果 Survivor 分区是 1 个的话，假设把两个区域分为 1:1，那么任何时候都有一半的内存空间是闲置的，显然空间利用率太低不是最佳的方案。但如果设置内存空间的比例是 8:2 ，只是看起来似乎“很好”，假设新生代的内存为 100 MB（ Survivor 大小为 20 MB ），现在有 70 MB 对象进行垃圾回收之后，剩余活跃的对象为 15 MB 进入 Survivor 区，这个时候新生代可用的内存空间只剩了 5 MB，这样很快又要进行垃圾回收操作，显然这种垃圾回收器最大的问题就在于，需要频繁进行垃圾回收。</li><li>如果 Survivor 分区有 2 个分区，我们就可以把 Eden、From Survivor、To Survivor 分区内存比例设置为 8:1:1 ，那么任何时候新生代内存的利用率都 90% ，这样空间利用率基本是符合预期的。再者就是虚拟机的大部分对象都符合“朝生夕死”的特性，因此每次新对象的产生都在空间占比比较大的 Eden 区，垃圾回收之后再把存活的对象方法存入 Survivor 区，如果是 Survivor 区存活的对象，那么“年龄”就 +1 ，当年龄增长到 15 （可通过 -XX:+MaxTenuringThreshold 设定）对象就升级到老生代。</li></ul><p>经过以上对比，可以得出结论，当新生代的 Survivor 分区为 2 个的时候，不论是空间利用率还是程序运行的效率都是最优的。</p><h4 id="什么是-CMS-垃圾回收器？"><a href="#什么是-CMS-垃圾回收器？" class="headerlink" title="什么是 CMS 垃圾回收器？"></a>什么是 CMS 垃圾回收器？</h4><p>答：CMS（Concurrent Mark Sweep）一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</p><h4 id="CMS-垃圾回收器有哪些优缺点？"><a href="#CMS-垃圾回收器有哪些优缺点？" class="headerlink" title="CMS 垃圾回收器有哪些优缺点？"></a>CMS 垃圾回收器有哪些优缺点？</h4><p>答：CMS 垃圾回收器的优点是使用多线程，标记清除垃圾的，它缺点如下。</p><ul><li>对 CPU 资源要求敏感：CMS 回收器过分依赖于多线程环境，默认情况下，开启的线程数为（CPU 的数量 + 3）/ 4，当 CPU 数量少于 4 个时，CMS 对用户本身的操作的影响将会很大，因为要分出一半的运算能力去执行回收器线程；</li><li>CMS 无法清除浮动垃圾：浮动垃圾指的是 CMS 清除垃圾的时候，还有用户线程产生新的垃圾，这部分未被标记的垃圾叫做“浮动垃圾”，只能在下次 GC 的时候进行清除；</li><li>CMS 垃圾回收会产生大量空间碎片：CMS 使用的是标记-清除算法，所有在垃圾回收的时候回产生大量的空间碎片。</li></ul><h4 id="什么是-G1-垃圾回收器？"><a href="#什么是-G1-垃圾回收器？" class="headerlink" title="什么是 G1 垃圾回收器？"></a>什么是 G1 垃圾回收器？</h4><p>答：G1 垃圾回收器是一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。G1 可以直观的设定停顿时间的目标，相比于 CMS CG，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</p><p>G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个 Region。Region 之间是复制算法，但整体上实际可看作是标记 - 整理（Mark-Compact）算法，可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1 的优势更加明显。</p><h4 id="垃圾回收的调优参数有哪些？"><a href="#垃圾回收的调优参数有哪些？" class="headerlink" title="垃圾回收的调优参数有哪些？"></a>垃圾回收的调优参数有哪些？</h4><p>答：垃圾回收的常用调优如下：</p><ul><li>-Xmx:512 设置最大堆内存为 512 M；</li><li>-Xms:215 初始堆内存为 215 M；</li><li>-XX:MaxNewSize 设置最大年轻区内存；</li><li>-XX:MaxTenuringThreshold=5 设置新生代对象经过 5 次 GC 晋升到老年代；</li><li>-XX:PretrnureSizeThreshold 设置大对象的值，超过这个值的大对象直接进入老生代；</li><li>-XX:NewRatio 设置分代垃圾回收器新生代和老生代内存占比；</li><li>-XX:SurvivorRatio 设置新生代 Eden、Form Survivor、To Survivor 占比。</li></ul><h2 id="常见面试题翻车合集"><a href="#常见面试题翻车合集" class="headerlink" title="常见面试题翻车合集"></a>常见面试题翻车合集</h2><h4 id="去掉-main-方法的-static-修饰符，程序会怎样？"><a href="#去掉-main-方法的-static-修饰符，程序会怎样？" class="headerlink" title="去掉 main 方法的 static 修饰符，程序会怎样？"></a>去掉 main 方法的 static 修饰符，程序会怎样？</h4><p>A：程序无法编译</p><p>B：程序正常编译，正常运行</p><p>C：程序正常编译，正常运行一下马上退出</p><p>D：程序正常编译，运行时报错</p><p>答：D</p><p>题目解析：运行时异常如下：</p><blockquote><p>错误: main 方法不是类 xxx 中的 static, 请将 main 方法定义为:</p><p>public static void main(String[] args)</p></blockquote><h4 id="以下程序运行的结果是？"><a href="#以下程序运行的结果是？" class="headerlink" title="以下程序运行的结果是？"></a>以下程序运行的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getLength());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String s = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> result = s.length();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：3</p><p>B：2</p><p>C：4</p><p>D：程序无法编译</p><p>答：D</p><p>题目解析：成员变量 s 不能使用任何修饰符（private/protected/public）修饰，否则编译会报错。</p><h4 id="以下程序有几处错误？"><a href="#以下程序有几处错误？" class="headerlink" title="以下程序有几处错误？"></a>以下程序有几处错误？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">myAbstractClass</span></span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">abstract</span> <span class="title">String</span> <span class="title">method</span>()</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：1</p><p>B：2</p><p>C：3</p><p>D：4</p><p>答：C</p><p>题目解析：类少一个“{”类开始标签、抽象方法不能包含方法体、抽象方法访问修饰符不能为 private，因此总共有 3 处错误。</p><h4 id="以下程序执行的结果是？-7"><a href="#以下程序执行的结果是？-7" class="headerlink" title="以下程序执行的结果是？"></a>以下程序执行的结果是？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        x = B.y + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> y = A.x + <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;x=%d,y=%d&quot;</span>, A.x, B.y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：程序无法编译</p><p>B：程序正常编译，运行报错</p><p>C：x=1,y=2</p><p>D：x=0,y=1</p><p>答：C</p><h4 id="switch-语法可以配合-return-一起使用吗？return-和-break-在-switch-使用上有何不同？"><a href="#switch-语法可以配合-return-一起使用吗？return-和-break-在-switch-使用上有何不同？" class="headerlink" title="switch 语法可以配合 return 一起使用吗？return 和 break 在 switch 使用上有何不同？"></a>switch 语法可以配合 return 一起使用吗？return 和 break 在 switch 使用上有何不同？</h4><p>答：switch 可以配合 return 一起使用。return 和 break 的区别在于 switch 结束之后的代码，比如以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;red&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;红&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;blue&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;蓝&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;未知&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">    String result = <span class="string">&quot;未知&quot;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;red&quot;</span>:</span><br><span class="line">            result = <span class="string">&quot;红&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;blue&quot;</span>:</span><br><span class="line">            result = <span class="string">&quot;蓝&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以上这种 switch 之后没有特殊业务处理的程序来说，return 和 break 的效果是等效的。然而，对于以下这种代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;red&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;红&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;blue&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;蓝&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;未知&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">    String result = <span class="string">&quot;未知&quot;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;red&quot;</span>:</span><br><span class="line">            result = <span class="string">&quot;红&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;blue&quot;</span>:</span><br><span class="line">            result = <span class="string">&quot;蓝&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.equals(<span class="string">&quot;未知&quot;</span>)) &#123;</span><br><span class="line">        result = <span class="string">&quot;透明&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result += <span class="string">&quot;色&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 switch 之后还有特殊的业务处理，那么 return 和 break 就有很大的区别了。</p><h4 id="一个栈的入栈顺序是-A、B、C、D、E-则出栈不可能的顺序是？"><a href="#一个栈的入栈顺序是-A、B、C、D、E-则出栈不可能的顺序是？" class="headerlink" title="一个栈的入栈顺序是 A、B、C、D、E 则出栈不可能的顺序是？"></a>一个栈的入栈顺序是 A、B、C、D、E 则出栈不可能的顺序是？</h4><p>A：E D C B A</p><p>B：D E C B A</p><p>C：D C E A B</p><p>D：A B C D E</p><p>答：C</p><p>题目解析：栈是后进先出的，因此：</p><ul><li>A 选项：入栈顺序 A B C D E 出栈顺序就是 E D C B A 是正确的；</li><li>B 选项：A B C D 先入栈，D 先出栈，这个时候 E 在入栈，E 在出栈，顺序 D E C B A 也是正确的；</li><li>C 选项：D 先出栈，说明 A B C 一定已入栈，因为题目说了入栈的顺序是 A B C D E，所以出栈的顺序一定是 C B A，而 D C E A B 的顺序 A 在 B 前面是永远不可能发生的，所以选择是 C；</li><li>D 选项 A B C D E 依次先入栈、出栈，顺序就是 A B C D E。</li></ul><h4 id="可以在-finally-块中使用-return吗？"><a href="#可以在-finally-块中使用-return吗？" class="headerlink" title="可以在 finally 块中使用 return吗？"></a>可以在 finally 块中使用 return吗？</h4><p>答：不可以，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。</p><h4 id="FileInputStream-可以实现什么功能？-1"><a href="#FileInputStream-可以实现什么功能？-1" class="headerlink" title="FileInputStream 可以实现什么功能？"></a>FileInputStream 可以实现什么功能？</h4><p>A：文件夹目录获取</p><p>B：文件写入</p><p>C：文件读取</p><p>D：文件夹目录写入</p><p>答：C</p><p>题目解析：FileInputStream 是文件读取，FileOutputStream 才是用来写入文件的，FileInputStream 和 FileOutputStream 很容易搞混。</p><h4 id="以下程序打印的结果是什么？"><a href="#以下程序打印的结果是什么？" class="headerlink" title="以下程序打印的结果是什么？"></a>以下程序打印的结果是什么？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m T1.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.setPriority(<span class="number">3</span>);</span><br><span class="line">t1.start();</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m T2.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t2.setPriority(<span class="number">0</span>);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><p>答：程序报错 java.lang.IllegalArgumentException，setPriority(n) 方法用于设置程序的优先级，优先级的取值为 1-10，当设置为 0 时，程序会报错。</p><h4 id="如何设置守护线程？"><a href="#如何设置守护线程？" class="headerlink" title="如何设置守护线程？"></a>如何设置守护线程？</h4><p>答：设置 Thead 类的 setDaemon(true) 方法设置当前的线程为守护线程。</p><p>守护线程的使用示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread daemonThread = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置为守护线程</span></span><br><span class="line">daemonThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">daemonThread.start();</span><br></pre></td></tr></table></figure><h4 id="以下说法中关于线程通信的说法错误的是？"><a href="#以下说法中关于线程通信的说法错误的是？" class="headerlink" title="以下说法中关于线程通信的说法错误的是？"></a>以下说法中关于线程通信的说法错误的是？</h4><p>A：可以调用 wait()、notify()、notifyAll() 三个方法实现线程通信</p><p>B：wait() 必须在 synchronized 方法或者代码块中使用</p><p>C：wait() 有多个重载的方法，可以指定等待的时间</p><p>D：wait()、notify()、notifyAll() 是 Object 类提供的方法，子类可以重写</p><p>答：D</p><p>题目解析：wait()、notify()、notifyAll() 都是被 final 修饰的方法，不能再子类中重写。选项 B，使用 wait() 方法时，必须先持有当前对象的锁，否则会抛出异常 java.lang.IllegalMonitorStateException。</p><h4 id="ReentrantLock-默认创建的是公平锁还是非公平锁？"><a href="#ReentrantLock-默认创建的是公平锁还是非公平锁？" class="headerlink" title="ReentrantLock 默认创建的是公平锁还是非公平锁？"></a>ReentrantLock 默认创建的是公平锁还是非公平锁？</h4><p>答：默认创建的是非公平锁，看以下源码可以得知：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nonfair 为非公平的意思，ReentrantLock() 等同于代码 ReentrantLock(false)。</p><h4 id="ReentrantLock-如何在一段时间内无阻塞尝试访问锁？"><a href="#ReentrantLock-如何在一段时间内无阻塞尝试访问锁？" class="headerlink" title="ReentrantLock 如何在一段时间内无阻塞尝试访问锁？"></a>ReentrantLock 如何在一段时间内无阻塞尝试访问锁？</h4><p>答：使用 tryLock(long timeout, TimeUnit unit) 方法，就可以在一段时间内无堵塞的访问锁。</p><h4 id="枚举比较使用-equals-还是-？"><a href="#枚举比较使用-equals-还是-？" class="headerlink" title="枚举比较使用 equals 还是 ==？"></a>枚举比较使用 equals 还是 ==？</h4><p>答：枚举比较调用 equals 和 == 的结果是一样，查看 Enum 的源码可知 equals 其实是直接调用了 ==，源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>==other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在-Spring-中使用-Value-赋值静态变量为什么-null？怎么解决？"><a href="#在-Spring-中使用-Value-赋值静态变量为什么-null？怎么解决？" class="headerlink" title="在 Spring 中使用 @Value 赋值静态变量为什么 null？怎么解决？"></a>在 Spring 中使用 @Value 赋值静态变量为什么 null？怎么解决？</h4><p>答：因为在 Springframework 框架中，当类加载器加载静态变量时，Spring 上下文尚未加载，因此类加载器不会在 bean 中正确注入静态类，导致了结果为 null。可使用 Setter() 方法给静态变量赋值，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigValue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String accessKey;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAccessKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accessKey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;accessKey&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccessKey</span><span class="params">(String accessKey)</span> </span>&#123;</span><br><span class="line">        ConfigValue.accessKey = accessKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 调用赋值变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConfigValue configValue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读取配置文件</span></span><br><span class="line">        configValue.getAccessKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何自己实现一个定时任务？"><a href="#如何自己实现一个定时任务？" class="headerlink" title="如何自己实现一个定时任务？"></a>如何自己实现一个定时任务？</h4><p>答：启动一个后台线程，循环执行任务。代码示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread getTocketThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行业务方法</span></span><br><span class="line">                TimeUnit.HOURS.sleep(<span class="number">2</span>); <span class="comment">// 每两小时执行一次</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (!getTocketThread.isAlive()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;启动线程&quot;</span>);</span><br><span class="line">    getTocketThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何定义一个不定长度的数组？"><a href="#如何定义一个不定长度的数组？" class="headerlink" title="如何定义一个不定长度的数组？"></a>如何定义一个不定长度的数组？</h4><p>答：在 Java 中使用数组必须要指定长度，如果长度不固定可使用 ArrayList、LinkedList 等容器接收完数据，再使用 toArray() 方法转换成固定数组。</p><h4 id="如何优雅的格式化百分比小数？"><a href="#如何优雅的格式化百分比小数？" class="headerlink" title="如何优雅的格式化百分比小数？"></a>如何优雅的格式化百分比小数？</h4><p>答：使用数字格式化类 DecimalFormat 来处理，具体实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> num = <span class="number">0.37500</span>;</span><br><span class="line">DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;0.0%&quot;</span>);</span><br><span class="line">System.out.println(df.format(num)); <span class="comment">// 执行结果：37.5%</span></span><br></pre></td></tr></table></figure><h4 id="什么是跨域问题？为什么会产生跨域问题？"><a href="#什么是跨域问题？为什么会产生跨域问题？" class="headerlink" title="什么是跨域问题？为什么会产生跨域问题？"></a>什么是跨域问题？为什么会产生跨域问题？</h4><p>答：跨域问题指的是不同站点直接，使用 ajax 无法相互调用的问题。跨域问题是浏览器的行为，是为了保证用户信息的安全，防止恶意网站窃取数据，所做的限制，如果没有跨域限制就会导致信息被随意篡改和提交，会导致不可预估的安全问题，所以也会造成不同站点间“正常”请求的跨域问题。</p><h4 id="跨域的解决方案有哪些？"><a href="#跨域的解决方案有哪些？" class="headerlink" title="跨域的解决方案有哪些？"></a>跨域的解决方案有哪些？</h4><p>答：常见跨域问题的解决方案如下：</p><ul><li>jsonp（只支持 get 请求）；</li><li>nginx 请求转发，把不同站点应用配置到同一个域名下；</li><li>服务器端设置运行跨域访问，如果使用的是 Spring 框架可通过 @CrossOrigin 注解的方式声明某个类或方法运行跨域访问，或者配置全局跨域配置，请参考以下代码：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个跨域配置</span></span><br><span class="line"><span class="meta">@CrossOrigin(origins = &quot;http://xxx&quot;, maxAge = 3600)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testController</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">corsConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurerAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addMapping(<span class="string">&quot;/api/**&quot;</span>).allowedOrigins(<span class="string">&quot;https://xxx&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么原因会导致-Nginx-转发时丢失部分-header-信息？该如何解决？"><a href="#什么原因会导致-Nginx-转发时丢失部分-header-信息？该如何解决？" class="headerlink" title="什么原因会导致 Nginx 转发时丢失部分 header 信息？该如何解决？"></a>什么原因会导致 Nginx 转发时丢失部分 header 信息？该如何解决？</h4><p>答：部分 header 信息丢失的原因是，丢失的 header 的 key 值中有下划线，因为 Nginx 转发时，默认会忽略带下划线的 header 信息。</p><p>解决方案有两个，一是去掉 key 值中的下划线，二是在 Nginx 的配置文件 http 中添加“underscores<em>in</em>headers on;” 不忽略有下划线的 header 信息。</p><h4 id="如何设计一个高效的系统？"><a href="#如何设计一个高效的系统？" class="headerlink" title="如何设计一个高效的系统？"></a>如何设计一个高效的系统？</h4><p>答：要设计一个高效的系统，通常要包含以下几个方面。</p><h5 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h5><p>代码优化分为两种情况：</p><ul><li>代码问题导致系统资源消耗过多的问题，比如，某段代码导致内存溢出，往往是将 JVM 中的内存用完了，这个时候系统的内存资源消耗殆尽了，同时也会引发 JVM 频繁地发生垃圾回收，导致 CPU 100% 以上居高不下，这个时候又消耗了系统的 CPU 资源。这种情况下需要使用相应的排查工具 VisualVM 或 JConsole，找到对应的问题代码再进行优化；</li><li>还有一种是非问题代码，这种代码不容易发现，比如，LinkedList 集合如果使用 for 循环遍历，则它的效率是很低的，因为 LinkedList 是链表实现的，如果使用 for 循环获取元素，在每次循环获取元素时，都会去遍历一次 List，这样会降低读的效率，这个时候应该改用 Iterator （迭代器）迭代循环该集合。</li></ul><h5 id="设计优化"><a href="#设计优化" class="headerlink" title="设计优化"></a>设计优化</h5><p>有很多问题可以通过我们的设计优化来提高程序的执行性能，比如，使用单例模式来减少频繁地创建和销毁对象所带来的性能消耗，从而提高了程序的执行性能。</p><h5 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h5><p>JVM 和 Web 容器的参数调优，对系统的执行性能也是也很大帮助的。比如，我们的业务中会创建大量的大对象，我们可以通过设置，将这些大对象直接放进老年代，这样可以减少年轻代频繁发生小的垃圾回收（Minor GC），减少 CPU 占用时间，从而提升了程序的执行性能。Web 容器的线程池设置以及 Linux 操作系统的内核参数设置，也对程序的运行性能有着很大的影响，我们根据自己的业务场景优化这两项内容。</p><h5 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存"></a>使用缓存</h5><p>缓存的使用分为前端和后端：</p><ul><li>前端可使用浏览器缓存或者 CDN，CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术；</li><li>后端缓存，使用第三方缓存 Redis 或 Memcache 来缓存查询结果，以提高查询的响应速度。</li></ul><h5 id="优化数据库"><a href="#优化数据库" class="headerlink" title="优化数据库"></a>优化数据库</h5><p>数据库是最宝贵的资源，通常也是影响程序响应速度的罪魁祸首，它的优化至关重要，通常分为以下六个方面：</p><ul><li>合理使用数据库引擎</li><li>合理设置事务隔离级别，合理使用事务</li><li>正确使用 SQL 语句和查询索引</li><li>合理分库分表</li><li>使用数据库中间件实现数据库读写分离</li><li>设置数据库主从读写分离</li></ul><h5 id="屏蔽无效和恶意访问"><a href="#屏蔽无效和恶意访问" class="headerlink" title="屏蔽无效和恶意访问"></a>屏蔽无效和恶意访问</h5><p>前端禁止重复提交：用户提交之后按钮置灰，禁止重复提交；</p><p>用户限流，在某一时间段内只允许用户提交一次请求，比如，采取 IP 限流。</p><h5 id="搭建分布式环境，使用负载分发"><a href="#搭建分布式环境，使用负载分发" class="headerlink" title="搭建分布式环境，使用负载分发"></a>搭建分布式环境，使用负载分发</h5><p>可以把程序部署到多台服务器上，通过负载均衡工具，比如 Nginx，将并发请求分配到不同的服务器，从而提高了系统处理并发的能力。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 知识点总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
